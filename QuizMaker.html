<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QuizMaker</title>
  <link rel="icon" href="data:,">
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
  <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
  <link rel="preload" href="quizData.json" as="fetch" crossorigin="anonymous">
  <link rel="preload" href="imageData.json" as="fetch" crossorigin="anonymous">
  <style>
    /* Ensure formatted spans do not disrupt line spacing */
    #editor span {
      display: inline;
      line-height: normal;
      vertical-align: baseline;
    }
    /* Slim, subtle scrollbar for the questions list */
    #sectionsContainer {
      scrollbar-width: thin;
      scrollbar-color: rgba(0,0,0,0.3) transparent;
    }
    #sectionsContainer::-webkit-scrollbar {
      width: 6px;
    }
    #sectionsContainer::-webkit-scrollbar-track {
      background: transparent;
    }
    #sectionsContainer::-webkit-scrollbar-thumb {
      background-color: rgba(0,0,0,0.3);
      border-radius: 3px;
    }
    #sectionsContainer::-webkit-scrollbar-thumb:hover {
      background-color: rgba(0,0,0,0.5);
    }
    /* —— Reset & Base —— */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      display: flex; height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #ecf0f1; color: #333;
    }
    body.loading {
      display: block;
    }
    body.loading #sidebar,
    body.loading #main,
    body.loading #mobileStart {
      display: none;
    }
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      align-items: center;
      justify-content: center;
      background: #ecf0f1;
      color: #333;
      font-size: 1.2rem;
    }
    body.loading #loadingScreen {
      display: flex;
    }

    /* —— Form Control Normalization —— */
    button,
    input,
    select,
    textarea {
      font-family: inherit;
      font-size: 0.9rem;
      line-height: 1.2;
      color: inherit;
    }
    button,
    input[type="button"],
    input[type="submit"],
    input[type="reset"] {
      -webkit-appearance: none;
      appearance: none;
      border: 1px solid transparent;
      border-radius: 6px;
      padding: 4px 10px;
      background-color: #fdfdfd;
    }
    button:focus-visible,
    input[type="button"]:focus-visible,
    input[type="submit"]:focus-visible,
    input[type="reset"]:focus-visible {
      outline: 2px solid #2980b9;
      outline-offset: 2px;
    }

    /* —— Sidebar —— */
    #sidebar {
      width: 240px;
      background: #2c3e50;
      color: #ecf0f1;
      padding: 20px;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #folderSection {
      margin-bottom: 16px;
    }
    #folderSection.collapsed {
      margin-bottom: 6px;
    }
    #folderToggle {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: none;
      border: none;
      color: #ecf0f1;
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: .5px;
      padding: 0;
      cursor: pointer;
      transition: color .2s ease;
    }
    #folderToggle .title {
      flex: 1;
      text-align: left;
    }
    #folderToggle:hover {
      color: #ffffff;
    }
    #folderToggle:hover .chevron {
      border-color: rgba(236,240,241,0.5);
      background: rgba(236,240,241,0.12);
    }
    #folderToggle:focus-visible {
      outline: 2px solid #f1c40f;
      outline-offset: 4px;
    }
    #folderToggle .chevron {
      flex: 0 0 auto;
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(236,240,241,0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      transition: border-color .2s ease, background .2s ease;
    }
    #folderToggle .chevron::before {
      content: '\25BC';
      display: inline-block;
      transition: transform .25s ease;
    }
    #folderSection.collapsed #folderToggle .chevron::before {
      transform: rotate(-90deg);
    }
    #folderSection.collapsed #folderToggle .chevron {
      background: rgba(236,240,241,0.1);
      border-color: rgba(236,240,241,0.2);
    }
    #folderSection.collapsed #folderToggle:hover .chevron {
      border-color: rgba(236,240,241,0.35);
      background: rgba(236,240,241,0.16);
    }
    #folderSection .collapsible-body {
      display: grid;
      grid-template-rows: 1fr;
      overflow: hidden;
      transition: grid-template-rows .28s ease, opacity .2s ease;
      opacity: 1;
    }
    #folderSection .collapsible-body.no-animate {
      transition: none !important;
    }
    #folderSection.collapsed .collapsible-body {
      grid-template-rows: 0fr;
      opacity: 0;
      pointer-events: none;
    }
    #folderSection .collapsible-content {
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-top: 10px;
    }
    #folderSection .folder-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    /* QuestionControls button accents */
    #addFillBtn { border-left: 4px solid #1abc9c; }
    #addLabelBtn { border-left: 4px solid #e67e22; }
    #addAcronymBtn { border-left: 4px solid #8e44ad; }
    #toggleDeleteBtn { border-left: 4px solid #c0392b; }

    /* QuestionControls buttons base styling */
    #questionControls button {
      padding: 5px 10px;
      line-height: 1.25;
      border-top: none;
      border-right: none;
      border-bottom: none;
      border-radius: 4px;
      background: #fff;
      color: #2c3e50;
      cursor: pointer;
      transition: background .2s;
    }
    #questionControls button:hover {
      background: #ecf0f1;
    }

    /* Mode switch button accents */
    #editModeBtn { border-left: 4px solid #1abc9c; }
    #quizModeBtn { border-left: 4px solid #8e44ad; }
    #quizAllBtn { border-left: 4px solid #e67e22; }
    #sidebar h3 {
      margin-bottom: 10px;
      font-size: 1.1rem;
      letter-spacing: .5px;
    }
    .nav { list-style: none; margin-bottom: 20px; }
    .nav li {
      padding: 8px 12px;
      border-radius: 4px;
      margin-bottom: 4px;
      cursor: pointer;
      transition: background .2s;
    }
    /* Question type accents */
    .nav li.type-fill {
      border-left: 4px solid #1abc9c;
      padding-left: 8px;
    }
    .nav li.type-diagram {
      border-left: 4px solid #e67e22;
      padding-left: 8px;
    }
    .nav li.type-acronym {
      border-left: 4px solid #8e44ad;
      padding-left: 8px;
    }
    .nav li:hover { background: #34495e; }

    /* Dynamic selected background based on question type */
    .nav li.selected {
      font-weight: bold;
    }
    .nav li.type-fill.selected {
      background: #1abc9c;
      color: #2c3e50;
    }
    .nav li.type-diagram.selected {
      background: #e67e22;
      color: #2c3e50;
    }
    .nav li.type-acronym.selected {
      background: #8e44ad;
      color: #fff;
    }
    #newFolderName {
      width: calc(100% - 100px);
      padding: 6px;
      margin-bottom: 8px;
      border: none;
      border-radius: 4px;
    }
    #folderSection .folder-actions #newFolderName {
      flex: 1;
      width: auto;
      margin-bottom: 0;
    }
    #addFolderBtn, #addSectionBtn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: #e67e22;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #folderSection .folder-actions #addFolderBtn {
      flex: 0 0 auto;
      white-space: nowrap;
    }
    #addFolderBtn:hover, #addSectionBtn:hover { background: #d35400; }
    #folderSection .folder-divider {
      border: 1px solid #34495e;
      opacity: .2;
      margin: 12px 0 4px;
    }

    /* —— Main Area & Header —— */
    #main { flex: 1; display: flex; flex-direction: column; }
    #header {
      background: #1abc9c;
      color: #fff;
      padding: 16px 24px;
      font-size: 1.3rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
    }
    #folderBadge {
      display: none;
      margin-right: 8px;
      padding: 4px 10px;
      border-radius: 4px;
      background: #34495e;
      color: #fff;
      font-size: 1.1rem;
      font-weight: bold;
    }
    #controls {
      display: flex;
      gap: 10px;
      padding: 12px 24px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    #controls .mode-btn {
      flex: 1;
      padding: 6px;
      border: none;
      border-radius: 4px;
      background: #3498db;
      color: #fff;
      font-weight: 500;
      cursor: pointer;
      transition: background .2s;
    }
    #controls .mode-btn:hover { background: #2980b9; }
    #editorArea img {
      max-width: 100%;
      height: auto;
    }

    /* —— Editor & Preview —— */
    #formatToolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #fff;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      padding: 4px;
      margin-bottom: 12px;
    }
    #formatToolbar button {
      font-weight:bold;
      padding:4px 8px;
      cursor:pointer;
    }
    #formatToolbar select, #formatToolbar input[type="color"] {
      cursor:pointer;
    }
    .delete-icon {
      display: none;
      margin-left: 4px;
      color: red;
      cursor: pointer;
    }
    #editorArea, #quizArea { flex: 1; padding: 24px; overflow-y: auto; }
    #editor {
      width: 100%;
      height: auto;
      max-height: none;
      min-height: 180px;
      overflow-y: hidden;
      padding: 12px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      font-family: Menlo, monospace;
      background: #fff;
      white-space: pre-wrap;
    }
    #preview {
      margin-top: 20px;
      padding: 16px;
      background: #fff;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      min-height: 120px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    /* Custom preview line class to control vertical spacing */
    .preview-line {
      margin: 0 0 6px 0;
      display: block;
      line-height: 1.4;
    }
    .word {
      display: inline-block;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 3px 5px 3px 0;
      padding: 4px 6px;
      border-radius: 4px;
      transition: background .2s;
      cursor: pointer;
    }
    .word:hover { background: #dfe6e9; }
    .word.hidden {
      color: transparent;
      text-shadow: 0 0 5px #000;
      border-bottom: 1px dashed #f39c12;
    }
    .word.hidden.reveal { border-bottom: 1px dotted #8e44ad; }
    #editor .hidden-reveal, #editor .hidden-reveal.pending { display: none; }
    #preview .hidden-reveal, #quizContent .hidden-reveal { display: none; }
    .popup-word {
      cursor: pointer;
      border-bottom: 1px dashed #3498db;
    }
    .popup-word:hover { background: #dfe6e9; }
    .popup-word .blank input {
      border-bottom-color: #3498db;
      border-bottom-style: dashed;
    }
    .popup-word .blank input:focus {
      border-bottom-color: #2980b9;
    }
    #addPictureBtn, #resumeQuizBtn {
      margin-top: 12px;
      margin-right: 8px;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #1abc9c;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #addPictureBtn:hover, #resumeQuizBtn:hover { background: #1e8449; }

    /* —— Alternate Answers UI —— */
    #altContainer {
      margin-top: 20px; padding: 16px;
      background: #fdfdfd;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
    }
    #altContainer h4 { margin-bottom: 10px; font-size: 1rem; color: #2c3e50; }
    .alt-input {
      width: 120px;             /* fixed small width */
      padding: 2px 4px;
      margin-bottom: 4px;
      margin-right: 8px;
      font-size: 0.8rem;
      border: 1px solid #7f8c8d;
      border-radius: 4px;
    }
    .reveal-input {
      width: 200px;
      padding: 2px 4px;
      margin-bottom: 4px;
      margin-right: 8px;
      font-size: 0.8rem;
      border: 1px solid #7f8c8d;
      border-radius: 4px;
    }

    /* Override the generic #labelEditor input rule so alternate‑answer boxes stay compact */
    #labelEditor .alt-input {
      width: 120px;
      padding: 2px 4px;
      margin-bottom: 4px;
      margin-right: 8px;
      font-size: 0.8rem;
    }
    #labelEditor .reveal-input {
      width: 200px;
      padding: 2px 4px;
      margin-bottom: 4px;
      margin-right: 8px;
      font-size: 0.8rem;
    }

    #labelDefinitions h4 { font-size: 1.1rem; margin-bottom: 4px; }

    /* —— Quiz Mode & Blanks —— */
    #quizContent {
      white-space: pre-wrap;
      word-break: break-word;
      padding: 24px;
      background: #fff;
      border: 2px solid #bdc3c7;
      border-radius: 4px;
      font-size: 1.1rem;
      line-height: 1.5;
    }

    .quiz-question-title {
      margin-bottom: 22px;
      font-size: clamp(1.35rem, 2.4vw, 1.7rem);
      font-weight: 700;
      color: #2c3e50;
      letter-spacing: 0.015em;
      line-height: 1.28;
    }
    .quiz-question-title .quiz-title-word {
      display: inline-block;
      padding: 0.1em 0.25em;
      border-radius: 6px;
      background: rgba(52,152,219,0.08);
    }
    .quiz-question-title .quiz-title-word:nth-child(odd) {
      background: rgba(26,188,156,0.12);
    }

    .question-section-card {
      position: relative;
      margin: 18px 0;
      padding: 18px 18px 20px 28px;
      border-radius: 18px;
      background: rgba(255,255,255,0.94);
      border: 1px solid rgba(44,62,80,0.09);
      box-shadow: 0 18px 34px -24px rgba(44,62,80,0.6);
      transition: transform 0.25s ease, box-shadow 0.25s ease;
      animation: sectionCardFade 0.45s ease forwards;
      animation-delay: calc(0.045s * (var(--section-index, 1) - 1));
      opacity: 0;
    }
    .question-section-card::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(135deg, rgba(26,188,156,0.08), rgba(52,152,219,0.08));
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    .question-section-card::after {
      content: '';
      position: absolute;
      left: 14px;
      top: 18px;
      bottom: 18px;
      width: 5px;
      border-radius: 999px;
      background: linear-gradient(180deg, #1abc9c, #3498db);
      opacity: 0.9;
    }
    .question-section-card:hover,
    .question-section-card:focus-within {
      transform: translateY(-2px);
      box-shadow: 0 22px 36px -24px rgba(44,62,80,0.65);
    }
    .question-section-card:hover::before,
    .question-section-card:focus-within::before {
      opacity: 1;
    }
    body.mobile .question-section-card.mobile-answer-active {
      transform: translateY(-2px);
      box-shadow: 0 22px 36px -24px rgba(26,188,156,0.65);
    }
    body.mobile .question-section-card.mobile-answer-active::before {
      opacity: 1;
    }

    .question-section-header {
      display: flex;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 10px;
    }
    .question-section-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 2.4rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      background: linear-gradient(135deg, #1abc9c, #16a085);
      color: #fff;
      font-size: 0.78rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 12px 22px -18px rgba(26,188,156,0.9);
    }
    .question-section-heading {
      font-size: 1.12rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #2c3e50;
    }
    .question-section-body {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      font-size: 1.1rem;
      line-height: 1.6;
      color: #34495e;
    }
    .question-section-body > * {
      margin: 0;
    }
    .question-section-body ul,
    .question-section-body ol {
      padding-left: 1.25rem;
    }
    .question-section-body.empty::before {
      content: 'No details provided for this section yet.';
      font-style: italic;
      color: #7f8c8d;
    }

    @keyframes sectionCardFade {
      from {
        transform: translateY(10px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @media (max-width: 700px) {
      .quiz-question-title {
        margin-bottom: 18px;
      }
      .question-section-card {
        margin: 14px 0;
        padding: 16px 16px 18px 22px;
        border-radius: 16px;
      }
      .question-section-card::after {
        left: 10px;
        top: 16px;
        bottom: 16px;
      }
      .question-section-heading {
        font-size: 1.02rem;
      }
      .question-section-body {
        font-size: 0.98rem;
        gap: 0.55rem;
      }
      .question-section-badge {
        min-width: 2rem;
        padding: 0.28rem 0.55rem;
        font-size: 0.7rem;
      }
    }

    body.mobile #editorArea .question-section-card.whw-section {
      margin: 20px 0;
      padding: 18px 18px 22px 24px;
    }
    body.mobile #editorArea .question-section-card.whw-section:not(:last-child) {
      margin-bottom: 24px;
    }
    body.mobile #editorArea .question-section-card.whw-section .question-section-header {
      margin-bottom: 14px;
    }
    body.mobile #editorArea .question-section-card.whw-section .question-section-body {
      gap: 0.75rem;
    }

    #editorArea .question-section-card.whw-section .question-section-body.empty {
      position: relative;
      padding: 0.95rem 0 0.65rem;
      min-height: 2.6rem;
    }
    #editorArea .question-section-card.whw-section .question-section-body.empty::before {
      content: '';
      display: block;
      height: 1.2rem;
      border-radius: 14px;
      background: linear-gradient(90deg, rgba(26,188,156,0.18), rgba(52,152,219,0.18));
      opacity: 0.65;
    }
    #editorArea .question-section-card.whw-section .question-section-body.empty::after {
      content: '';
      display: block;
      height: 0.9rem;
    }

    #quizArea .question-section-heading.whw-heading {
      font-size: clamp(1.22rem, 2.8vw, 1.45rem);
      line-height: 1.3;
      letter-spacing: 0.045em;
    }

    @media (prefers-reduced-motion: reduce) {
      .question-section-card {
        animation: none;
        opacity: 1;
        transform: none !important;
        box-shadow: 0 12px 26px -24px rgba(44,62,80,0.55);
      }
    }

    /* —— Enlarged Text & Inputs for Edit and Quiz Modes —— */
    #editor {
      font-size: 1.2rem;
    }
    #labelEditor input, #acroEditor input {
      font-size: 1.2rem;
      padding: 6px;
    }
    #quizArea, #quizContent {
      font-size: 1.2rem;
    }
    #labelEditor img.main-image {
      max-width: 100%;
      height: auto;
    }
    /* —— Fill-In Quiz Font & Size —— */
    #quizContent .blank input {
      font-size: inherit;
      font-family: inherit;
      padding: 0 2px;
    }
    #quizContent .blank {
      font-family: Arial, sans-serif;
    }
    .blank-input { box-sizing: border-box; }
    #quizContent .blank .reveal {
      margin-left: 6px;
      color: #555;
      font-style: italic;
    }
    /* —— Acronym Quiz Font & Width —— */
    #quizContent input[type="text"] {
      font-family: Arial, sans-serif;
      min-width: 0ch;
    }

    /* Definition wrapper styling and drag-and-drop container */
    .definition-list {
      display: flex;
      flex-direction: column;
    }
    .definition-wrapper {
      border: 1px solid #bdc3c7;
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 4px;
      background: #fff;
      cursor: move;
    }
    /* Grading full border for correct inputs */
    input.correct {
      border: 2px solid #27ae60 !important;
    }
    input.incorrect {
      border: 2px solid #c0392b !important;
    }
    .blank { position: relative; display: inline-block; margin: 0 2px; }
    .blank::before {
      content: '';
    }
    .blank input {
      position: relative; background: transparent;
      border: none; border-bottom: 1px solid #7f8c8d;
      font-family: Menlo, monospace; font-size: 1.1rem;
      padding: 0; margin: 0; box-sizing: content-box;
      min-width: 1ch;
    }
    .blank input:focus { outline: none; border-bottom-color: #3498db; }
    .blank input.correct { border-bottom-color: #27ae60; }
    .blank input.incorrect { border-bottom-color: #c0392b; }
    .blank input.bank-flash {
      animation: bankFillFlash 0.24s ease-out;
    }
    @keyframes bankFillFlash {
      from { background: rgba(26, 188, 156, 0.25); }
      to { background: transparent; }
    }
    @media (max-width: 600px) {
      #quizArea,
      #quizContent {
        font-size: 1rem;
      }
      #quizArea {
        padding: 18px 12px;
      }
      #quizContent {
        padding: 18px 14px;
      }
      .question-section-card {
        margin: 12px 0;
        padding: 14px 14px 16px 18px;
        border-radius: 14px;
      }
      .question-section-card::after {
        left: 8px;
        top: 14px;
        bottom: 14px;
        width: 4px;
      }
      #quizContent .blank input,
      .blank input {
        font-size: 1rem;
      }
    }
    #nextBtn, #backBtn {
      margin-top: 20px; padding: 6px 18px;
      border: none; border-radius: 4px;
      background: #8e44ad; color: #fff;
      cursor: pointer; transition: background .2s;
    }
    #nextBtn:hover, #backBtn:hover { background: #71368a; }
    #hintBtn, #editQuestionBtn {
      margin-top: 20px;
      padding: 6px 18px;
      border: none;
      border-radius: 4px;
      background: #8e44ad;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #hintBtn:hover, #editQuestionBtn:hover {
      background: #71368a;
    }
    #toggleAnswersBtn {
      margin-top: 20px;
      padding: 6px 18px;
      border: none;
      border-radius: 4px;
      background: #8e44ad;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #toggleAnswersBtn:hover {
      background: #71368a;
    }

    #ttsControls {
      display: none;
      margin-top: 20px;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    #ttsControls button {
      padding: 6px 18px;
      border: none;
      border-radius: 4px;
      background: #8e44ad;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #ttsControls button:hover:not(:disabled) {
      background: #71368a;
    }
    #ttsControls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #ttsControls select,
    #ttsControls input[type="range"] {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid rgba(44, 62, 80, 0.25);
      background: #fff;
      color: #2c3e50;
      font-size: 0.9rem;
    }
    #ttsControls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: #2c3e50;
    }
    #ttsRateValue {
      font-variant-numeric: tabular-nums;
      min-width: 3.5ch;
      text-align: right;
    }
    #ttsHint {
      font-size: 0.85rem;
      color: #2c3e50;
      flex-basis: 100%;
    }
    .tts-start-marker {
      outline: 2px dashed #8e44ad;
      outline-offset: 6px;
      position: relative;
    }
    .tts-start-marker::after {
      content: '🔊';
      position: absolute;
      top: -0.9rem;
      right: -0.9rem;
      background: #fff;
      border-radius: 50%;
      padding: 2px 4px;
      font-size: 0.85rem;
      color: #8e44ad;
      box-shadow: 0 0 0 2px #fff;
    }
    #quizContent {
      position: relative;
    }
    #ttsHighlightLayer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      pointer-events: none;
      z-index: 5;
    }
    .tts-highlight-box {
      position: absolute;
      background: rgba(52, 152, 219, 0.28);
      border-radius: 4px;
    }
    .quiz-tts-outline {
      outline: 2px solid rgba(52, 152, 219, 0.4);
      outline-offset: 4px;
      transition: outline 0.15s ease;
    }

    #answerBank {
      display: none;
      margin-top: 12px;
    }
    body.mobile #quizContent .mobile-floating-answer-bank {
      width: 100%;
      margin-top: 12px;
      margin-bottom: 4px;
    }
    body.mobile #quizContent .mobile-floating-toggle {
      width: 100%;
      box-sizing: border-box;
      margin-top: 12px;
    }
    #answerBank .answer-label {
      display: inline-block;
      margin: 4px;
      padding: 6px 8px;
      background: #ecf0f1;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      cursor: grab;
      touch-action: manipulation;
      user-select: none;
    }
    .drag-ghost {
      padding: 6px 8px;
      background: #ecf0f1;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      position: fixed;
      pointer-events: none;
      z-index: 1000;
    }

    #progressStatus {
      text-align: center;
      font-size: 1rem;
    }

    /* Enforce pixel sizes for Quill size picker */
    .ql-size-8px  { font-size: 8px !important; }
    .ql-size-10px { font-size: 10px !important; }
    .ql-size-12px { font-size: 12px !important; }
    .ql-size-14px { font-size: 14px !important; }
    .ql-size-16px { font-size: 16px !important; }
    .ql-size-18px { font-size: 18px !important; }
    .ql-size-20px { font-size: 20px !important; }
    .ql-size-24px { font-size: 24px !important; }
    .ql-size-28px { font-size: 28px !important; }
    .ql-size-32px { font-size: 32px !important; }


    /* Ensure bullets render properly across views */
    #preview     ul.ql-list.ql-bullet,
    #quizContent ul.ql-list.ql-bullet,
    .ql-editor  ul.ql-list.ql-bullet {
      padding-left: 2em;
      margin: 0.5em 0;
    }

    /* Show diamonds instead of discs when editing */
    .ql-editor ul.ql-list.ql-bullet {
      list-style: none;
    }
    .ql-editor ul.ql-list.ql-bullet li { position: relative; }
    .ql-editor ul.ql-list.ql-bullet li::before {
      content: "\25C6"; /* diamond */
      position: absolute;
      left: -1em;
    }

    /* Preview/quiz should keep default bullets */
    #preview     ul.ql-list.ql-bullet,
    #quizContent ul.ql-list.ql-bullet {
      list-style: disc;
    }
    /* Remove the editor diamonds in non-edit views */
    #preview     ul.ql-list.ql-bullet li::before,
    #quizContent ul.ql-list.ql-bullet li::before {
      content: none;
    }

    /* Fallback: indent any unordered list in quiz content */
    #quizContent ul {
      list-style-type: disc;
      list-style-position: outside;
      margin-left: 1.5em; /* indent bullet + text */
      padding-left: 0;    /* prevent double indent */
    }

    /* ----- Mobile layout ----- */
    body.mobile { flex-direction: column; }
    body.mobile #sidebar { display: none; }
    body.mobile #controls { display: none; }
    body.mobile #main { flex: 1; }
    #mobileStart { display: none; padding: 16px; width: 100%; }
    #mobileStart input { width: 100%; padding: 8px; margin-bottom: 12px; }
    #mobileFolderList, #mobileSearchResults { list-style: none; padding: 0; margin: 0; }
    #mobileFolderList > li { padding: 0; }
    #mobileFolderList > li > div.folder-header {
      position: relative;
      display: flex;
      align-items: center;
      padding: 12px;
      border-bottom: 1px solid #ccc;
      cursor: pointer;
      overflow: hidden;
    }
    #mobileFolderList > li > div.folder-header .completion-counter {
      margin-left: auto;
      background: #3498db;
      color: #fff;
      border-radius: 12px;
      padding: 2px 6px;
      font-size: 0.8rem;
    }
    #mobileFolderList.random-select > li > div.folder-header {
      padding-left: 40px;
    }
    #mobileFolderList > li > div.folder-header input.folder-select {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      margin: 0;
      display: none;
    }
    #mobileFolderList.random-select > li > div.folder-header input.folder-select {
      display: block;
    }
    #mobileSearchResults li {
      padding: 12px;
      border-bottom: 1px solid #ccc;
      cursor: pointer;
    }
    #mobileFolderList li ul { list-style: none; padding-left: 20px; }
    #mobileFolderList li ul li {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      background: #f9f9f9;
      position: relative;
      overflow: hidden;
      touch-action: pan-y;
    }

    #mobileFolderList > li > .folder-header {
      position: relative;
      overflow: hidden;
      touch-action: pan-y;
    }

    .swipe-content {
      display: flex;
      align-items: center;
      width: 100%;
      transition: transform 0.2s ease;
    }
    .mobile-delete {
      position: absolute;
      right: -60px;
      top: 0;
      bottom: 0;
      width: 60px;
      background: #e74c3c;
      color: #fff;
      border: none;
      transition: right 0.2s;
    }
    #mobileFolderList li ul li.add-question {
      text-align: center;
      font-weight: bold;
      background: #e0e0e0;
    }
    #mobileRandomBtn {
      margin-top: 12px;
      padding: 10px;
      width: 100%;
      border: none;
      border-radius: 4px;
      background: #3498db;
      color: #fff;
      font-weight: 500;
    }
    .copy-local-btn {
      margin-top: 12px;
      padding: 10px;
      width: 100%;
      border: none;
      border-radius: 4px;
      background: #8e44ad;
      color: #fff;
      font-weight: 500;
    }
    .clear-local-btn {
      margin-top: 12px;
      padding: 10px;
      width: 100%;
      border: none;
      border-radius: 4px;
      background: #e74c3c;
      color: #fff;
      font-weight: 500;
    }

    /* Compact side-by-side local storage buttons for desktop and mobile */
    #desktopLocalBtns,
    #mobileLocalBtns {
      margin-top: 8px;
      display: flex;
      gap: 8px;
    }
    #desktopLocalBtns .copy-local-btn,
    #desktopLocalBtns .clear-local-btn {
      flex: 1;
      padding: 6px;
      margin-top: 0;
      width: auto;
    }
    #mobileLocalBtns .copy-local-btn,
    #mobileLocalBtns .clear-local-btn {
      flex: 1;
      padding: 10px;
      margin-top: 0;
      width: auto;
    }
    #resumeRandomBtn,
    #mobileRandomGo {
      margin-top: 12px;
      padding: 10px;
      width: 100%;
      border: none;
      border-radius: 4px;
      background: #27ae60;
      color: #fff;
      font-weight: 500;
      display: none;
    }
    body.mobile.quiz-active #mobileStart { display: none; }
    body.mobile.quiz-active #main { display: flex; }
    body.mobile:not(.quiz-active) #main { display: none; }
    body.mobile:not(.quiz-active) #mobileStart { display: block; }
    body.mobile.quiz-active #header { cursor: pointer; }
    body.mobile #homeBtn { display: none !important; }
    /* Ensure quiz images scale to fit smaller screens (mobile only) */
    body.mobile #quizContent img {
      max-width: 100%;
      height: auto;
    }

    /* Desktop toggle for mobile experience */
    #mobileToggleContainer {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 9999;
    }
    #mobileViewToggleBtn {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: rgba(44, 62, 80, 0.9);
      color: #ecf0f1;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      cursor: pointer;
      font-weight: 600;
      transition: transform .2s ease, box-shadow .2s ease;
    }
    #mobileViewToggleBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }
    #mobileViewToggleBtn:active {
      transform: translateY(0);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    body.mobile:not(.mobile-simulated) #mobileToggleContainer {
      display: none;
    }

    body.mobile.mobile-simulated {
      background: linear-gradient(160deg, #dfe6e9 0%, #f8f9fa 100%);
      padding-top: 72px;
    }
    body.mobile.mobile-simulated #mobileStart,
    body.mobile.mobile-simulated #main {
      width: min(540px, 100%);
      margin: 0 auto 32px auto;
      box-shadow: 0 18px 45px rgba(0,0,0,0.12);
      border-radius: 16px;
    }
    body.mobile.mobile-simulated #mobileStart {
      background: #ffffff;
      padding: 24px;
    }
    body.mobile.mobile-simulated #mobileStart button,
    body.mobile.mobile-simulated #mobileStart input {
      font-size: 1rem;
    }
    body.mobile.mobile-simulated.quiz-active #main {
      display: flex;
    }
    body.mobile.mobile-simulated #header {
      border-radius: 16px 16px 0 0;
    }
    body.mobile.mobile-simulated #quizArea,
    body.mobile.mobile-simulated #editorArea {
      border-radius: 0 0 16px 16px;
      background: #ffffff;
    }
  </style>
  <style id="linkingStyles"></style>
</head>
<body class="loading">

  <script>
    const earlyMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth <= 768;
    if (earlyMobile) {
      document.body.classList.add('mobile');
    }
    // Remove loading state immediately so mobile devices aren't stuck on the splash
    // screen and the initial UI can render as soon as possible.
    requestAnimationFrame(() => {
      document.body.classList.remove('loading');
    });
  </script>
  <div id="loadingScreen">Loading...</div>

  <div id="mobileToggleContainer">
    <button id="mobileViewToggleBtn" type="button" aria-pressed="false">📱 Mobile View</button>
  </div>

  <div id="mobileStart">
    <input type="text" id="mobileSearch" placeholder="Search questions...">
    <ul id="mobileFolderList"><li class="loading">Loading folders...</li></ul>
    <ul id="mobileSearchResults" style="display:none;"></ul>
    <button id="mobileRandomBtn">Random Quiz</button>
    <div id="mobileLocalBtns">
      <button id="copyLocalBtn" class="copy-local-btn">Copy Local Changes</button>
      <button id="clearLocalBtn" class="clear-local-btn">Clear Local Storage</button>
    </div>
    <button id="resumeRandomBtn" style="display:none;">Resume</button>
    <button id="mobileRandomGo">Go</button>
  </div>

  <div id="sidebar">
    <div id="folderSection" class="collapsible expanded">
      <button id="folderToggle" type="button" aria-expanded="true" aria-controls="foldersSectionBody">
        <span class="title">Folders</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <div id="foldersSectionBody" class="collapsible-body">
        <div class="collapsible-content">
          <ul id="folders" class="nav"></ul>
          <div class="folder-actions">
            <input id="newFolderName" placeholder="New folder name">
            <button id="addFolderBtn">Add Folder</button>
          </div>
          <div id="desktopLocalBtns">
            <button id="copyLocalBtnDesktop" class="copy-local-btn">Copy Local Changes</button>
            <button id="clearLocalBtnDesktop" class="clear-local-btn">Clear Local Storage</button>
          </div>
          <hr class="folder-divider">
        </div>
      </div>
    </div>
    <h3>Questions</h3>
    <div style="position: relative; margin-bottom: 8px;">
      <input type="text" id="sectionSearch"
             placeholder="Search questions..."
             style="width: calc(100% - 30px);
                    padding: 6px;
                    border: none;
                    border-radius: 4px;">
      <span id="clearSearchBtn"
            style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%);
                   cursor: pointer; font-size: 14px; display: none; color: #ecf0f1;">✖</span>
    </div>
    <!-- Scrollable questions list -->
    <div id="sectionsContainer" style="flex:1; overflow-y:auto; padding-right:12px;">
      <ul id="sections" class="nav"></ul>
    </div>
    <div id="questionControls" style="position: sticky; bottom: 0; background: #2c3e50; padding: 8px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
      <button id="addFillBtn" style="padding: 2px 10px; white-space: nowrap; overflow: hidden; text-align: center; line-height: 1.1; display: inline-flex; align-items: center; justify-content: center; gap: 4px;">+ Fill-In</button>
      <button id="addLabelBtn" style="padding: 2px 10px; white-space: nowrap; overflow: hidden; text-align: center; line-height: 1.1; display: inline-flex; align-items: center; justify-content: center; gap: 4px;">+ Diagram</button>
      <button id="addAcronymBtn" style="padding: 2px 10px; white-space: nowrap; overflow: hidden; text-align: center; line-height: 1.1; display: inline-flex; align-items: center; justify-content: center; gap: 4px;">+ Acronym</button>
      <button id="toggleDeleteBtn" style="padding: 2px 10px; white-space: nowrap; overflow: hidden; text-align: center; line-height: 1.1; display: inline-flex; align-items: center; justify-content: center; gap: 4px;">🗑️ Delete</button>
      <input type="file" id="labelImageInput" accept="image/*" style="display:none;">
    </div>
  </div>

  <div id="main">
    <div id="header"><span id="folderBadge"></span><span id="headerTitle">QuizMaker</span></div>
    <div id="controls">
      <button class="mode-btn" id="editModeBtn">✏️ Edit Mode</button>
      <button class="mode-btn" id="quizModeBtn">📝 Quiz Question</button>
      <button class="mode-btn" id="quizAllBtn">🎲 Random Quiz</button>
    </div>

    <div id="progressStatus" style="display:none; margin:8px 24px;">
      <div id="progressText" style="font-weight:bold;"></div>
      <div id="progressBarContainer" style="height:8px; background:#ccc; border-radius:4px; margin-top:4px;">
        <div id="progressBar" style="height:100%; width:0; background:#1abc9c; border-radius:4px;"></div>
      </div>
    </div>

    <div id="editorArea">
      <div id="toolbar">
        <select class="ql-size">
          <option value="" selected>Normal</option>
          <option value="8px">8px</option>
          <option value="10px">10px</option>
          <option value="12px">12px</option>
          <option value="14px">14px</option>
          <option value="16px">16px</option>
          <option value="18px">18px</option>
          <option value="20px">20px</option>
          <option value="24px">24px</option>
          <option value="28px">28px</option>
          <option value="32px">32px</option>
        </select>
        <button class="ql-bold"></button>
        <button class="ql-italic"></button>
        <button class="ql-underline"></button>
        <button class="ql-undo" type="button">↺</button>
        <button class="ql-redo" type="button">↻</button>
        <button class="ql-list" value="bullet"></button>
        <select class="ql-color"></select>
        <button id="addImageWordBtn">🖼️</button>
      </div>
      <div id="editor" style="height: 200px; background: #fff;"></div>
      <div style="margin-top:12px;">
        <button id="resumeQuizBtn" style="display:none;">Back to Quiz</button>
        <button id="addPictureBtn" style="display:none;">Add Picture</button>
      </div>
      <div id="preview"></div>
      <div id="labelEditor" style="display:none; position: relative;"></div>
      <div id="altContainer" style="display:none;">
        <h4>Alternate answers for blanks (comma-separated):</h4>
      </div>
    </div>

    <div id="quizArea" style="display:none;">
      <div id="quizContent"></div>
      <div id="ttsControls">
        <button id="ttsSpeakBtn" type="button">🔊 Listen</button>
        <button id="ttsPauseBtn" type="button" disabled>⏸️ Pause</button>
        <button id="ttsStopBtn" type="button" disabled>⏹️ Stop</button>
        <button id="ttsRefreshBtn" type="button">🔄 Refresh Voices</button>
        <label id="ttsVoiceLabel" style="display:none;">
          Voice
          <select id="ttsVoiceSelect"></select>
        </label>
        <label id="ttsRateLabel" style="display:none;">
          Speed
          <input id="ttsRateSlider" type="range" min="0.7" max="1.3" step="0.05" value="1">
          <span id="ttsRateValue">1.0×</span>
        </label>
        <span id="ttsHint"></span>
      </div>
      <div id="answerBank"></div>
      <button id="toggleAnswersBtn" style="display:none;">Show Answers</button>
      <button id="backBtn">⬅️ Back</button>
      <button id="nextBtn">Next Section ➡️</button>
      <button id="hintBtn">Hint</button>
      <button id="editQuestionBtn" style="display:none;">Edit</button>
      <button id="homeBtn" style="display:none;">Home</button>
    </div>
  </div>

  <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
  <script>
    (async () => {
      try {
      // IndexedDB and persistent storage logic removed.
      // Function to position definitions container and add button absolutely below the image container
      function updateDefPosition() {
        const cont = document.getElementById('labelContainer');
        const addBtn = document.getElementById('addDefinitionBtn');
        const defCont = document.getElementById('labelDefinitions');
        if (cont && addBtn && defCont) {
          const parent = document.getElementById('labelEditor');
          parent.style.position = 'relative';
          const topOffset = cont.offsetTop + cont.offsetHeight + 10;
          // Position the Add Definition button
          addBtn.style.position = 'absolute';
          addBtn.style.top = topOffset + 'px';
          addBtn.style.left = cont.offsetLeft + 'px';
          // Make definitions span the rest of the editor width
          defCont.style.width = (parent.clientWidth - cont.offsetLeft) + 'px';
          // Position the definitions container below the button
          defCont.style.position = 'absolute';
          defCont.style.top = (topOffset + addBtn.offsetHeight + 10) + 'px';
          defCont.style.left = cont.offsetLeft + 'px';
        }
        positionExtraImages();
      }

      const EXTRA_GAP = 20;
      function positionExtras(cont) {
        if (!cont) return;
        const mainImg = cont.querySelector('#labelImg, .main-image');
        const extras = Array.from(cont.querySelectorAll('div.extra-wrapper'));
        if (!mainImg) return;
        let left = mainImg.offsetWidth + EXTRA_GAP;
        extras.forEach(wrap => {
          wrap.style.left = left + 'px';
          wrap.style.top = '0px';
          left += wrap.offsetWidth + EXTRA_GAP;
        });
      }
      function positionExtraImages() {
        const cont = document.getElementById('labelContainer');
        positionExtras(cont);
      }

      function scaleLabels(container, baseWidth, baseHeight) {
        const img = container.querySelector('img');
        if (!img || !baseWidth || !baseHeight) return;
        const scale = img.clientWidth / baseWidth;
        container.querySelectorAll('[data-orig-x]').forEach(el => {
          const x = parseFloat(el.dataset.origX);
          const y = parseFloat(el.dataset.origY);
          el.style.left = (x * scale) + 'px';
          el.style.top  = (y * scale) + 'px';
          if (el.dataset.origFont) {
            el.style.fontSize = (parseFloat(el.dataset.origFont) * scale) + 'px';
          }
          if (el.dataset.origH) {
            const h = parseFloat(el.dataset.origH) * scale;
            el.style.height = h + 'px';
            if (el.dataset.origLineHeight) {
              el.style.lineHeight = h + 'px';
            }
          }
          if (el.dataset.origW) {
            const scaledW = parseFloat(el.dataset.origW) * scale;
            let needed = scaledW;
            const txt = el.value || el.textContent || '';
            if (txt) {
              const meas = document.createElement('span');
              Object.assign(meas.style, {
                visibility: 'hidden',
                position: 'absolute',
                whiteSpace: 'pre',
                fontFamily: el.style.fontFamily,
                fontSize: el.style.fontSize,
                left: '-9999px',
                top: '-9999px',
                pointerEvents: 'none'
              });
              meas.textContent = txt;
              document.body.appendChild(meas);
              needed = Math.max(needed, meas.offsetWidth + 12);
              document.body.removeChild(meas);
            }
            el.style.width = needed + 'px';
          }
        });
      }

      function setupExtraImageInteractions(img, overlay, sec, ex) {
        if (document.body.classList.contains('mobile')) {
          ex.labels.forEach(lbl => {
            const mark = document.createElement('div');
            mark.textContent = lbl.text;
            Object.assign(mark.style, {
              position: 'absolute',
              display: 'inline-block',
              padding: '2px 4px',
              left: lbl.x + 'px',
              top: lbl.y + 'px',
              background: '#ffffff',
              border: '1px solid #7f8c8d',
              overflow: 'auto',
              whiteSpace: 'nowrap',
              textOverflow: 'ellipsis',
              userSelect: 'none'
            });
            mark.addEventListener('click', evt => {
              if (!isAddingDefinition) return;
              evt.stopPropagation();
              sec.definitions = sec.definitions || [];
              sec.definitions.push({
                labelText: lbl.text,
                rawText: '',
                hidden: [],
                alts: {},
                hideUntilSolved: false
              });
              saveData();
              isAddingDefinition = false;
              const btn = document.getElementById('addDefinitionBtn');
              if (btn) btn.textContent = 'Add Definition';
              loadSection();
            });
            mark.ondblclick = evt => {
              evt.stopPropagation();
              evt.preventDefault();
              const newText = prompt('Edit label text:', lbl.text);
              if (newText !== null) {
                lbl.text = newText;
                mark.textContent = lbl.text;
                lbl.w = mark.offsetWidth;
                lbl.h = mark.offsetHeight;
                mark.style.width = lbl.w + 'px';
                mark.style.height = lbl.h + 'px';
                saveData();
              }
            };
            mark.style.fontSize = lbl.fontSize + 'px';
            overlay.appendChild(mark);
            if (!lbl.w) {
              lbl.w = mark.offsetWidth;
              lbl.h = mark.offsetHeight;
              saveData();
            }
            mark.style.width = lbl.w + 'px';
            mark.style.height = lbl.h + 'px';
          });
          return;
        }
        overlay.ondblclick = evt => {
          if (evt.metaKey) return;
          const rect = img.getBoundingClientRect();
          const x = evt.clientX - rect.left;
          const y = evt.clientY - rect.top;
          const text = prompt('Enter label text:');
          if (text) {
            ex.labels.push({ x, y, text, fontSize: 16 });
            saveData();
            loadSection();
          }
        };
        ex.labels.forEach(lbl => {
          const mark = document.createElement('div');
          mark.textContent = lbl.text;
          Object.assign(mark.style, {
            position: 'absolute',
            display: 'inline-block',
            padding: '2px 4px',
            left: lbl.x + 'px',
            top: lbl.y + 'px',
            background: '#ffffff',
            border: '1px solid #7f8c8d',
            overflow: 'auto',
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            cursor: 'move',
            resize: 'both',
            userSelect: 'none',
            touchAction: 'none'
          });
          mark.addEventListener('contextmenu', evt => {
            if (!evt.metaKey) return;
            evt.preventDefault();
            evt.stopPropagation();
            if (confirm('Delete this label?')) {
              const idx = ex.labels.indexOf(lbl);
              if (idx >= 0) {
                ex.labels.splice(idx, 1);
                saveData();
                loadSection();
              }
            }
          });
          mark.addEventListener('click', evt => {
            if (!isAddingDefinition) return;
            evt.stopPropagation();
            sec.definitions = sec.definitions || [];
            sec.definitions.push({
              labelText: lbl.text,
              rawText: '',
              hidden: [],
              alts: {},
              hideUntilSolved: false
            });
            saveData();
            isAddingDefinition = false;
            const btn = document.getElementById('addDefinitionBtn');
            if (btn) btn.textContent = 'Add Definition';
            loadSection();
          });
          mark.ondblclick = evt => {
            evt.stopPropagation();
            evt.preventDefault();
            const newText = prompt('Edit label text:', lbl.text);
            if (newText !== null) {
              lbl.text = newText;
              mark.textContent = lbl.text;
              lbl.w = mark.offsetWidth;
              lbl.h = mark.offsetHeight;
              mark.style.width = lbl.w + 'px';
              mark.style.height = lbl.h + 'px';
              saveData();
            }
          };
          mark.oncontextmenu = evt => {
            evt.preventDefault();
            evt.stopPropagation();
            const input = prompt('Font size in px:', lbl.fontSize);
            const newSize = parseInt(input, 10);
            if (!isNaN(newSize) && newSize > 0) {
              lbl.fontSize = newSize;
              mark.style.fontSize = lbl.fontSize + 'px';
              lbl.w = mark.offsetWidth;
              lbl.h = mark.offsetHeight;
              mark.style.width = lbl.w + 'px';
              mark.style.height = lbl.h + 'px';
              saveData();
            }
          };
          mark.onmousedown = evt => {
            if (evt.button !== 0) return;
            evt.preventDefault();
            let startX = evt.clientX, startY = evt.clientY;
            const origX = lbl.x, origY = lbl.y;
            function onMouseMove(e) {
              lbl.x = origX + (e.clientX - startX);
              lbl.y = origY + (e.clientY - startY);
              mark.style.left = lbl.x + 'px';
              mark.style.top = lbl.y + 'px';
            }
            function onMouseUp() {
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              saveData();
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          };
          mark.ontouchstart = evt => {
            evt.preventDefault();
            const touch = evt.touches[0];
            let startX = touch.clientX, startY = touch.clientY;
            const origX = lbl.x, origY = lbl.y;
            function onMove(e) {
              const t = e.touches[0];
              lbl.x = origX + (t.clientX - startX);
              lbl.y = origY + (t.clientY - startY);
              mark.style.left = lbl.x + 'px';
              mark.style.top = lbl.y + 'px';
            }
            function onEnd() {
              document.removeEventListener('touchmove', onMove);
              document.removeEventListener('touchend', onEnd);
              saveData();
            }
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onEnd);
          };
          mark.style.fontSize = lbl.fontSize + 'px';
          overlay.appendChild(mark);
          if (!lbl.w) {
            lbl.w = mark.offsetWidth;
            lbl.h = mark.offsetHeight;
            saveData();
          }
          mark.style.width = lbl.w + 'px';
          mark.style.height = lbl.h + 'px';
          mark.addEventListener('mouseup', () => {
            lbl.w = mark.offsetWidth;
            lbl.h = mark.offsetHeight;
            saveData();
          });
          mark.addEventListener('touchend', () => {
            lbl.w = mark.offsetWidth;
            lbl.h = mark.offsetHeight;
            saveData();
          });
        });
        let svgOverlay = overlay.querySelector('svg');
        if (!svgOverlay) {
          svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svgOverlay.setAttribute('style', 'position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;');
          overlay.appendChild(svgOverlay);
        } else {
          while (svgOverlay.firstChild) svgOverlay.removeChild(svgOverlay.firstChild);
        }
        if (ex.arrows) {
          ex.arrows.forEach((a, idx) => {
            const angle = Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
            const arrowLength = a.width * 3;
            const arrowWidth = a.width * 2;
            const lineEndX = a.x2 - arrowLength * Math.cos(angle);
            const lineEndY = a.y2 - arrowLength * Math.sin(angle);
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', a.x1);
            line.setAttribute('y1', a.y1);
            line.setAttribute('x2', lineEndX);
            line.setAttribute('y2', lineEndY);
            line.setAttribute('stroke', a.color);
            line.setAttribute('stroke-width', a.width);
            line.setAttribute('pointer-events', 'all');
            svgOverlay.appendChild(line);
            const xBase1 = a.x2 - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
            const yBase1 = a.y2 - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);
            const xBase2 = a.x2 - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
            const yBase2 = a.y2 - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
            const points = `${a.x2},${a.y2} ${xBase1},${yBase1} ${xBase2},${yBase2}`;
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', points);
            polygon.setAttribute('fill', a.color);
            polygon.setAttribute('pointer-events', 'all');
            svgOverlay.appendChild(polygon);
            [line, polygon].forEach(el => {
              el.addEventListener('contextmenu', evt => {
                if (!evt.metaKey) return;
                evt.preventDefault();
                if (confirm('Delete this arrow?')) {
                  ex.arrows.splice(idx, 1);
                  saveData();
                  loadSection();
                  return;
                }
              });
            });
          });
        }
        let drawing = false;
        let startX = 0, startY = 0;
        let tempLine = null;
        overlay.addEventListener('mousedown', evt => {
          if (!evt.metaKey || evt.button !== 0) return;
          const rect = img.getBoundingClientRect();
          startX = evt.clientX - rect.left;
          startY = evt.clientY - rect.top;
          drawing = true;
          tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          tempLine.setAttribute('x1', startX);
          tempLine.setAttribute('y1', startY);
          tempLine.setAttribute('x2', startX);
          tempLine.setAttribute('y2', startY);
          tempLine.setAttribute('stroke', '#e74c3c');
          tempLine.setAttribute('stroke-width', '2');
          svgOverlay.appendChild(tempLine);
          evt.preventDefault();
        });
        overlay.addEventListener('mousemove', evt => {
          if (!drawing) return;
          const rect = img.getBoundingClientRect();
          const currX = evt.clientX - rect.left;
          const currY = evt.clientY - rect.top;
          tempLine.setAttribute('x2', currX);
          tempLine.setAttribute('y2', currY);
        });
        document.addEventListener('mouseup', evt => {
          if (!drawing) return;
          drawing = false;
          const rect = img.getBoundingClientRect();
          const endX = evt.clientX - rect.left;
          const endY = evt.clientY - rect.top;
          svgOverlay.removeChild(tempLine);
          tempLine = null;
          if (endX !== startX || endY !== startY) {
            if (!ex.arrows) ex.arrows = [];
            ex.arrows.push({ x1: startX, y1: startY, x2: endX, y2: endY, color: '#e74c3c', width: 2 });
            saveData();
            loadSection();
          }
        });
      }

      function setupExtraResize(wrap, img, ex, del) {
        if (document.body.classList.contains('mobile')) return;
        let lastContext = 0;
        wrap.addEventListener('contextmenu', e => {
          e.preventDefault();
          const now = Date.now();
          if (now - lastContext < 400) {
            const existing = wrap.querySelector('.resize-handle');
            if (existing) {
              existing.remove();
              if (del && !deleteMode) del.style.display = 'none';
            } else {
              const handle = document.createElement('div');
              handle.className = 'resize-handle';
              handle.style.position = 'absolute';
              handle.style.width = '16px';
              handle.style.height = '16px';
              handle.style.bottom = '0';
              handle.style.right = '0';
              handle.style.background = '#3498db';
              handle.style.cursor = 'se-resize';
              handle.style.zIndex = '1000';
              wrap.appendChild(handle);
              if (del) del.style.display = 'inline';
              handle.addEventListener('mousedown', ev => {
                ev.preventDefault();
                const startX = ev.clientX;
                const startW = wrap.offsetWidth;
                const aspect = img.naturalHeight / img.naturalWidth || 1;
                function onMove(mv) {
                  const newW = startW + (mv.clientX - startX);
                  const newH = newW * aspect;
                  wrap.style.width = newW + 'px';
                  wrap.style.height = newH + 'px';
                  img.style.width = '100%';
                  img.style.height = 'auto';
                  positionExtraImages();
                }
                function onUp() {
                  document.removeEventListener('mousemove', onMove);
                  document.removeEventListener('mouseup', onUp);
                  img.style.width = '100%';
                  img.style.height = 'auto';
                  ex.imgWidth = wrap.offsetWidth;
                  ex.imgHeight = wrap.offsetHeight;
                  saveData();
                  positionExtraImages();
                }
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
              });
              handle.addEventListener('touchstart', ev => {
                ev.preventDefault();
                const startX = ev.touches[0].clientX;
                const startW = wrap.offsetWidth;
                const aspect = img.naturalHeight / img.naturalWidth || 1;
                function onMove(mv) {
                  const newW = startW + (mv.touches[0].clientX - startX);
                  const newH = newW * aspect;
                  wrap.style.width = newW + 'px';
                  wrap.style.height = newH + 'px';
                  img.style.width = '100%';
                  img.style.height = 'auto';
                  positionExtraImages();
                }
                function onUp() {
                  document.removeEventListener('touchmove', onMove);
                  document.removeEventListener('touchend', onUp);
                  img.style.width = '100%';
                  img.style.height = 'auto';
                  ex.imgWidth = wrap.offsetWidth;
                  ex.imgHeight = wrap.offsetHeight;
                  saveData();
                  positionExtraImages();
                }
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onUp);
              }, { passive: false });
            }
          }
          lastContext = now;
        });
      }

      function renderExtraImages(sec) {
        const cont = document.getElementById('labelContainer');
        if (!cont) return;
        cont.querySelectorAll('div.extra-wrapper').forEach(e => e.remove());
        if (sec.extraImages) {
          sec.extraImages.forEach((ex, idx) => {
            const wrap = document.createElement('div');
            wrap.className = 'extra-wrapper';
            wrap.style.position = 'absolute';
            const img = document.createElement('img');
            img.className = 'extra-image';
            const base = ex.image || '';
            img.src = base;
            if (ex.imageRef) {
              applyImageRef(img, ex.imageRef);
            }
            img.style.display = 'block';
            img.style.userSelect = 'none';
            if (ex.imgWidth && ex.imgHeight) {
              wrap.style.width = ex.imgWidth + 'px';
              wrap.style.height = ex.imgHeight + 'px';
              img.style.width = '100%';
              img.style.height = 'auto';
            }
            wrap.appendChild(img);
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            wrap.appendChild(overlay);
            const del = document.createElement('span');
            del.className = 'delete-icon';
            del.textContent = '✖';
            del.style.position = 'absolute';
            del.style.right = '0';
            del.style.top = '0';
            del.style.display = deleteMode ? 'inline' : 'none';
            del.onclick = evt => {
              evt.stopPropagation();
              if (confirm('Delete this picture?')) {
                sec.extraImages.splice(idx, 1);
                saveData();
                loadSection();
              }
            };
            wrap.appendChild(del);
            cont.appendChild(wrap);
            img.onload = () => {
              if (!ex.imgWidth || !ex.imgHeight) {
                wrap.style.width = img.naturalWidth + 'px';
                wrap.style.height = img.naturalHeight + 'px';
                ex.imgWidth = img.naturalWidth;
                ex.imgHeight = img.naturalHeight;
                saveData();
              }
              positionExtraImages();
            };
            setupExtraResize(wrap, img, ex, del);
            setupExtraImageInteractions(img, overlay, sec, ex);
          });
          positionExtraImages();
        }
      }

      function renderQuizExtras(sec, container) {
        container.querySelectorAll('div.extra-wrapper').forEach(e => e.remove());
        if (!sec.extraImages) return;
        sec.extraImages.forEach(ex => {
          const wrap = document.createElement('div');
          wrap.className = 'extra-wrapper';
          wrap.style.position = 'absolute';
          const img = document.createElement('img');
          img.className = 'extra-image';
          const base = ex.image || '';
          img.src = base;
          if (ex.imageRef) {
            applyImageRef(img, ex.imageRef);
          }
          img.style.display = 'block';
          img.style.userSelect = 'none';
          let baseW = 0, baseH = 0;
          if (ex.imgWidth && ex.imgHeight) {
            wrap.style.width = ex.imgWidth + 'px';
            wrap.style.height = ex.imgHeight + 'px';
            img.style.width = '100%';
            img.style.height = 'auto';
          }
          wrap.appendChild(img);
          const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
          svg.setAttribute('style','position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;');
          wrap.appendChild(svg);
          if (ex.arrows) {
            ex.arrows.forEach(a => {
              const angle = Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
              const arrowLength = a.width * 3;
              const arrowWidth = a.width * 2;
              const lineEndX = a.x2 - arrowLength * Math.cos(angle);
              const lineEndY = a.y2 - arrowLength * Math.sin(angle);
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', a.x1);
              line.setAttribute('y1', a.y1);
              line.setAttribute('x2', lineEndX);
              line.setAttribute('y2', lineEndY);
              line.setAttribute('stroke', a.color);
              line.setAttribute('stroke-width', a.width);
              svg.appendChild(line);
              const xBase1 = a.x2 - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
              const yBase1 = a.y2 - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);
              const xBase2 = a.x2 - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
              const yBase2 = a.y2 - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
              const points = `${a.x2},${a.y2} ${xBase1},${yBase1} ${xBase2},${yBase2}`;
              const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
              poly.setAttribute('points', points);
              poly.setAttribute('fill', a.color);
              svg.appendChild(poly);
            });
          }
          const scaleThis = () => {
            scaleLabels(wrap, baseW, baseH);
            positionExtras(container);
          };
          img.onload = () => {
            baseW = ex.imgWidth || img.naturalWidth;
            baseH = ex.imgHeight || img.naturalHeight;
            if (!ex.imgWidth || !ex.imgHeight) {
              wrap.style.width = img.naturalWidth + 'px';
              wrap.style.height = img.naturalHeight + 'px';
            }
            svg.setAttribute('viewBox', `0 0 ${baseW} ${baseH}`);
            scaleThis();
            window.addEventListener('resize', scaleThis);
          };
          ex.labels.forEach(lbl => {
            const inp = document.createElement('input');
            inp.classList.add('blank-input');
            inp.dataset.label = '1';
            inp.setAttribute('data-answer', JSON.stringify([lbl.text]));
            inp.type = 'text';
            inp.style.position = 'absolute';
            inp.style.left = lbl.x + 'px';
            inp.style.top = lbl.y + 'px';
            inp.style.border = '1px solid #7f8c8d';
            inp.style.background = '#ffffff';
            inp.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
            inp.style.fontSize = lbl.fontSize + 'px';
            inp.style.color = '#000';
            inp.style.padding = '0 2px';
            inp.style.boxSizing = 'border-box';
            inp.style.minWidth = '0';
            inp.style.borderRadius = '2px';
            inp.style.cursor = 'text';
            inp.style.caretColor = '#000';
            inp.addEventListener('focus', () => {
              lastHintTarget = inp;
              activeBlankInput = inp;
              inp.style.width = getWidth(inp.value || lbl.text);
            });
            const meas = document.createElement('span');
            Object.assign(meas.style, {
              visibility: 'hidden',
              position: 'absolute',
              whiteSpace: 'pre',
              fontFamily: inp.style.fontFamily,
              fontSize: inp.style.fontSize,
              left: '-9999px',
              top: '-9999px',
              pointerEvents: 'none'
            });
            document.body.appendChild(meas);
            const getWidth = txt => {
              meas.textContent = txt;
              // extra padding so caret doesn't overlap last character
              return Math.max(meas.offsetWidth + 12, 24);
            };
            const calcW = lbl.w ? lbl.w : getWidth(lbl.text);
            const calcH = lbl.h || inp.offsetHeight;
            inp.style.width = calcW + 'px';
            inp.style.height = calcH + 'px';
            inp.style.lineHeight = calcH + 'px';
            inp.dataset.origLineHeight = calcH;
            inp.dataset.origX = lbl.x;
            inp.dataset.origY = lbl.y;
            inp.dataset.origFont = lbl.fontSize;
            inp.dataset.origW = calcW;
            inp.dataset.origH = calcH;
            inp.addEventListener('input', () => {
              inp.style.width = getWidth(inp.value);
              const val = inp.value.trim().toLowerCase();
              const ok = val === lbl.text.trim().toLowerCase();
              if (ok) {
                const txt = document.createElement('span');
                txt.textContent = lbl.text;
                txt.style.position = 'absolute';
                txt.style.left = lbl.x + 'px';
                txt.style.top = lbl.y + 'px';
                txt.style.fontSize = lbl.fontSize + 'px';
                txt.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                txt.style.background = '#ffffff';
                txt.style.border = '1px solid #27ae60';
                txt.style.padding = '0 2px';
                txt.style.borderRadius = '2px';
                const w = parseFloat(inp.dataset.origW);
                const h = parseFloat(inp.dataset.origH);
                txt.style.width = w + 'px';
                txt.style.height = h + 'px';
                txt.style.lineHeight = h + 'px';
                txt.dataset.origX = lbl.x;
                txt.dataset.origY = lbl.y;
                txt.dataset.origFont = lbl.fontSize;
                txt.dataset.origW = w;
                txt.dataset.origH = h;
                txt.dataset.origLineHeight = h;
                txt.style.color = '#000';
                txt.style.pointerEvents = 'none';
                wrap.appendChild(txt);
                inp.remove();
                scaleLabels(wrap, baseW, baseH);
              } else {
                inp.classList.remove('correct');
                inp.classList.add('incorrect');
                inp.style.borderColor = '#c0392b';
              }
            });
            inp.addEventListener('blur', () => meas.remove());
            wrap.appendChild(inp);
          });
          container.appendChild(wrap);
        });
        positionExtras(container);
      }
      let isQuizMode = true;   // start in quiz mode by default
      let lastHintTarget = null;  // track last focused blank for hint
      let activeBlankInput = null; // track the blank input selected for answer-bank clicks
      let deleteMode = false;     // controls red‑X visibility, must exist before render functions run
      let quizOrder = [], quizPos = 0;  // initialize quiz sequence and position early
      let lastSectionOrder = null;
      let currentFolder = null, currentSection = null;
      const mobileOpenFolders = new Set();
      // Track progress and random order per folder
      const quizProgress = {};  // { completed:Set, total, order:Array|null, pos:Number }
      let multiFolderMode = false;
      let multiProgress = { completed: new Set(), total: 0 };
      let randomSelectMode = false;
      let resumeRandomBtn;
      let completionCounts = JSON.parse(localStorage.getItem('folderCompletionCounts') || '{}');
      let justCompleted = false;
      let answersVisible = false;
      let inlineImageFallbackNotified = false;
      const wrongAnswerTimers = new WeakMap();
      let answerControlsHome = null;
      let currentAnswerAnchorCard = null;
      let selectionMoveTimer = null;

      function getCompletionCount(idx) {
        return completionCounts[String(idx)] || 0;
      }
      function setCompletionCount(idx, val) {
        completionCounts[String(idx)] = val;
        localStorage.setItem('folderCompletionCounts', JSON.stringify(completionCounts));
      }
      function incrementCompletionCount(idx) {
        setCompletionCount(idx, getCompletionCount(idx) + 1);
        updateFolderCounterDisplay(idx);
      }
      function updateFolderCounterDisplay(idx) {
        const el = document.querySelector(`#mobileFolderList li[data-index="${idx}"] .completion-counter`);
        if (el) el.textContent = getCompletionCount(idx);
      }
      function ensureAnswerControlsHome() {
        if (!answerBank || !toggleAnswersBtn) return;
        if (answerControlsHome && answerControlsHome.isConnected) return;
        answerControlsHome = document.createElement('div');
        answerControlsHome.id = 'answer-controls-home';
        answerControlsHome.style.display = 'none';
        answerBank.parentNode.insertBefore(answerControlsHome, answerBank);
      }
      function resetAnswerControlsPosition() {
        if (!answerBank || !toggleAnswersBtn) return;
        ensureAnswerControlsHome();
        const parent = answerControlsHome ? answerControlsHome.parentNode : null;
        if (!parent) return;
        parent.insertBefore(answerBank, answerControlsHome.nextSibling);
        parent.insertBefore(toggleAnswersBtn, answerBank.nextSibling);
        answerBank.classList.remove('mobile-floating-answer-bank');
        toggleAnswersBtn.classList.remove('mobile-floating-toggle');
        if (currentAnswerAnchorCard && currentAnswerAnchorCard.classList) {
          currentAnswerAnchorCard.classList.remove('mobile-answer-active');
        }
        if (selectionMoveTimer) {
          clearTimeout(selectionMoveTimer);
          selectionMoveTimer = null;
        }
        currentAnswerAnchorCard = null;
      }
      function moveAnswerControlsBelowCard(card) {
        if (!document.body.classList.contains('mobile')) return;
        if (!answerBank || !toggleAnswersBtn || !card) return;
        if (!quizContent || !quizContent.contains(card)) return;
        if (!card.classList.contains('whw-section')) {
          if (quizContent.querySelector('.question-section-card.whw-section')) {
            return;
          }
        }
        if (currentAnswerAnchorCard === card) return;
        ensureAnswerControlsHome();
        if (currentAnswerAnchorCard && currentAnswerAnchorCard.classList) {
          currentAnswerAnchorCard.classList.remove('mobile-answer-active');
        }
        const parent = card.parentNode;
        if (!parent) return;
        const reference = card.nextSibling;
        parent.insertBefore(answerBank, reference);
        parent.insertBefore(toggleAnswersBtn, answerBank.nextSibling);
        answerBank.classList.add('mobile-floating-answer-bank');
        toggleAnswersBtn.classList.add('mobile-floating-toggle');
        card.classList.add('mobile-answer-active');
        currentAnswerAnchorCard = card;
      }
      function setupMobileAnswerBankHandlers() {
        if (!document.body.classList.contains('mobile')) return;
        if (!quizContent) return;
        const cards = Array.from(quizContent.querySelectorAll('.question-section-card'));
        cards.forEach(card => {
          if (card.dataset.mobileAnswerBound === 'true') return;
          const handleClick = () => moveAnswerControlsBelowCard(card);
          const handleTouch = e => {
            if (e.touches && e.touches.length > 1) return;
            moveAnswerControlsBelowCard(card);
          };
          card.addEventListener('click', handleClick);
          card.addEventListener('touchstart', handleTouch, { passive: true });
          card.dataset.mobileAnswerBound = 'true';
        });
      }
      function resetAnswerBank() {
        answersVisible = false;
        if (answerBank) answerBank.style.display = 'none';
        if (toggleAnswersBtn) toggleAnswersBtn.textContent = 'Show Answers';
        if (answerBank) answerBank.innerHTML = '';
        resetAnswerControlsPosition();
      }
      // Progress is kept only for this session (no localStorage)

      function saveProgress() {
        // Previously saved to localStorage, but persistence was removed
      }

      function saveRandomQuizState() {
        if (!multiFolderMode) return;
        const state = {
          order: quizOrder,
          completed: Array.from(multiProgress.completed)
        };
        localStorage.setItem('lastRandomQuiz', JSON.stringify(state));
        updateResumeButton();
      }

      function updateResumeButton() {
        if (!resumeRandomBtn) return;
        const hasState = !!localStorage.getItem('lastRandomQuiz');
        if (hasState && document.body.classList.contains('mobile') && !document.body.classList.contains('quiz-active')) {
          resumeRandomBtn.style.display = 'block';
        } else {
          resumeRandomBtn.style.display = 'none';
        }
      }

      function updateProgressIndicator() {
        const cont = document.getElementById('progressStatus');
        const text = document.getElementById('progressText');
        const bar  = document.getElementById('progressBar');
        const prog = multiFolderMode ? multiProgress : quizProgress[currentFolder];
        if (!prog || !isQuizMode || quizOrder.length <= 1) {
          cont.style.display = 'none';
          return;
        }
        cont.style.display = 'block';
        text.textContent = `Progress: ${prog.completed.size} / ${prog.total}`;
        const percent = prog.total ? (prog.completed.size / prog.total) * 100 : 0;
        bar.style.width = percent + '%';
      }

      function isMobileDevice() {
        return document.body.classList.contains('mobile') || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth <= 768;
      }

      function hideSafariBar() {
        if (!isMobileDevice()) return;
        setTimeout(() => window.scrollTo(0, 1), 100);
      }
      window.addEventListener('load', hideSafariBar);
      window.addEventListener('orientationchange', hideSafariBar);

      function enableSwipeToDelete(wrapper, content, deleteBtn, onDelete) {
        let startX = 0, startY = 0, currentX = 0, currentY = 0;
        let direction = null, started = false;
        wrapper._deleteOpen = false;
        deleteBtn.style.right = '-60px';
        wrapper.addEventListener('touchstart', e => {
          const t = e.touches[0];
          startX = t.clientX;
          startY = t.clientY;
          currentX = startX;
          currentY = startY;
          content.style.transition = '';
          direction = null;
          started = false;
        });
        wrapper.addEventListener('touchmove', e => {
          const t = e.touches[0];
          currentX = t.clientX;
          currentY = t.clientY;
          const diffX = currentX - startX;
          const diffY = currentY - startY;
          if (!direction) {
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
              direction = 'x';
              started = true;
            } else if (Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 10) {
              direction = 'y';
            }
          }
          if (direction === 'x' && started) {
            e.preventDefault();
            const diff = Math.min(diffX, 0); // only allow swipe left
            const translate = Math.max(diff, -60); // clamp to delete width
            content.style.transform = `translateX(${translate}px)`;
            deleteBtn.style.right = `${-60 - translate}px`;
          }
        }, { passive: false });
        wrapper.addEventListener('touchend', () => {
          if (direction === 'x') {
            const diff = currentX - startX;
            content.style.transition = 'transform 0.2s';
            if (started && diff < -40) {
              content.style.transform = 'translateX(-60px)';
              deleteBtn.style.right = '0';
              wrapper._deleteOpen = true;
            } else {
              content.style.transform = '';
              deleteBtn.style.right = '-60px';
              wrapper._deleteOpen = false;
            }
          }
          direction = null;
        });
        deleteBtn.addEventListener('click', e => {
          e.stopPropagation();
          onDelete();
        });
      }

      function addLongPressListener(element, callback, duration = 900) {
        let timerId = null;
        let triggered = false;

        const clearTimer = () => {
          if (timerId !== null) {
            clearTimeout(timerId);
            timerId = null;
          }
        };

        const start = event => {
          if (event.type === 'mousedown' && event.button !== 0) return;
          clearTimer();
          triggered = false;
          timerId = window.setTimeout(() => {
            triggered = true;
            element._longPressConsumed = true;
            callback();
          }, duration);
        };

        const cancel = () => {
          clearTimer();
          triggered = false;
        };

        const end = event => {
          clearTimer();
          if (triggered) {
            if (event && typeof event.preventDefault === 'function') event.preventDefault();
            if (event && typeof event.stopPropagation === 'function') event.stopPropagation();
          }
          triggered = false;
        };

        element.addEventListener('touchstart', start, { passive: true });
        element.addEventListener('touchmove', cancel);
        element.addEventListener('touchend', end);
        element.addEventListener('touchcancel', cancel);
        element.addEventListener('mousedown', start);
        element.addEventListener('mousemove', cancel);
        element.addEventListener('mouseup', end);
        element.addEventListener('mouseleave', cancel);
      }

      async function addQuestionMobile(folderIdx) {
        currentFolder = folderIdx;
        const type = prompt('Question type? (fill, diagram, acronym)', 'fill');
        if (!type) return;
        const t = type.toLowerCase();
        if (t.startsWith('d')) await addLabelBtn.onclick();
        else if (t.startsWith('a')) await addAcronymBtn.onclick();
        else await addFillBtn.onclick();
        mobileOpenFolders.add(folderIdx);
        buildMobileFolderList();
      }

      function setupMobileUI() {
        if (mobileUIInitialized) return;
        mobileUIInitialized = true;
        buildMobileFolderList();
        document.getElementById('mobileSearch').addEventListener('input', handleMobileSearch);
        mobileRandomBtn.addEventListener('click', () => toggleRandomSelectMode());
        mobileRandomGo.addEventListener('click', startSelectedRandomQuiz);
      }

      function getMobileRandomFolderCheckboxes(list = document.getElementById('mobileFolderList')) {
        if (!list) return [];
        return Array.from(list.querySelectorAll('.folder-select')).filter(cb => cb.dataset.all !== 'true');
      }

      function updateMobileSelectAllState(list = document.getElementById('mobileFolderList')) {
        if (!randomSelectMode || !list) return;
        const selectAllCb = list.querySelector('.folder-select-all');
        if (!selectAllCb) return;
        const checkboxes = getMobileRandomFolderCheckboxes(list);
        if (!checkboxes.length) {
          selectAllCb.checked = false;
          selectAllCb.indeterminate = false;
          return;
        }
        const selected = checkboxes.filter(cb => cb.checked).length;
        if (selected === 0) {
          selectAllCb.checked = false;
          selectAllCb.indeterminate = false;
        } else if (selected === checkboxes.length) {
          selectAllCb.checked = true;
          selectAllCb.indeterminate = false;
        } else {
          selectAllCb.checked = false;
          selectAllCb.indeterminate = true;
        }
      }

      function setAllMobileRandomCheckboxes(list, checked) {
        getMobileRandomFolderCheckboxes(list).forEach(cb => {
          cb.checked = checked;
        });
      }

      function appendMobileSelectAllOption(list) {
        if (!list) return;
        const li = document.createElement('li');
        li.className = 'select-all-folder';
        const header = document.createElement('div');
        header.className = 'folder-header';
        const content = document.createElement('div');
        content.className = 'swipe-content';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'folder-select folder-select-all';
        cb.dataset.all = 'true';
        const titleSpan = document.createElement('span');
        titleSpan.textContent = 'Quiz All';
        const countSpan = document.createElement('span');
        countSpan.className = 'completion-counter';
        countSpan.textContent = 'ALL';
        content.appendChild(cb);
        content.appendChild(titleSpan);
        content.appendChild(countSpan);
        header.appendChild(content);
        li.appendChild(header);

        const toggleAll = checked => {
          setAllMobileRandomCheckboxes(list, checked);
          updateMobileSelectAllState(list);
        };

        cb.addEventListener('click', e => {
          e.stopPropagation();
          cb.indeterminate = false;
          toggleAll(cb.checked);
        });

        content.addEventListener('click', () => {
          if (!randomSelectMode) return;
          const next = cb.indeterminate ? true : !cb.checked;
          cb.checked = next;
          cb.indeterminate = false;
          toggleAll(next);
        });

        list.appendChild(li);
      }

      function buildMobileFolderList() {
        const list = document.getElementById('mobileFolderList');
        list.innerHTML = '';
        // Maintain the original folder order defined in the source data.
        const ordered = data.folders
          .map((f, idx) => ({ folder: f, idx }))
          .sort((a, b) => {
            if (originalData && Array.isArray(originalData.folders)) {
              const order = originalData.folders;
              const ai = order.findIndex(of => of.name === a.folder.name);
              const bi = order.findIndex(of => of.name === b.folder.name);
              if (ai !== -1 && bi !== -1) return ai - bi;
              if (ai !== -1) return -1;
              if (bi !== -1) return 1;
            }
            return a.idx - b.idx;
          });
        ordered.forEach(({ folder: f, idx }) => {
          if (!f || !f.name) return;
          const li = document.createElement('li');
          li.dataset.index = idx;
          const header = document.createElement('div');
          header.className = 'folder-header';
          const content = document.createElement('div');
          content.className = 'swipe-content';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.className = 'folder-select';
          cb.dataset.index = idx;
          const titleSpan = document.createElement('span');
          titleSpan.textContent = f.name;
          content.appendChild(cb);
          content.appendChild(titleSpan);
          const countSpan = document.createElement('span');
          countSpan.className = 'completion-counter';
          countSpan.textContent = getCompletionCount(idx);
          content.appendChild(countSpan);
          header.appendChild(content);
          const delBtn = document.createElement('button');
          delBtn.className = 'mobile-delete';
          delBtn.textContent = '🗑️';
          header.appendChild(delBtn);
          addLongPressListener(content, () => {
            const currentName = f.name || '';
            const newName = prompt('Rename folder:', currentName);
            if (newName === null) return;
            const trimmed = newName.trim();
            if (!trimmed) {
              alert('Folder name cannot be empty');
              return;
            }
            if (trimmed === f.name) return;
            f.name = trimmed;
            saveData();
            renderFolders();
            if (currentFolder === idx) updateHeader();
            buildMobileFolderList();
          });
          enableSwipeToDelete(header, content, delBtn, () => {
            if (confirm(`Delete folder "${f.name}"? This cannot be undone.`)) {
              data.folders.splice(idx, 1);
              mobileOpenFolders.clear();
              if (data.folders.length > 0) {
                const newIdx = idx < data.folders.length ? idx : data.folders.length - 1;
                currentFolder = newIdx;
                const secs = data.folders[currentFolder].sections;
                currentSection = secs.length > 0 ? 0 : null;
              } else {
                currentFolder = null;
                currentSection = null;
              }
              saveData();
              renderFolders();
              lastSectionOrder = null;
              renderSections(lastSectionOrder);
              buildMobileFolderList();
              enterEdit();
              if (currentSection !== null) loadSection(); else updateHeader('');
            }
          });
          const secList = document.createElement('ul');
          secList.style.display = mobileOpenFolders.has(idx) ? 'block' : 'none';
          f.sections.forEach((s, si) => {
            const title = s.title || s.acronym || (s.rawText && s.rawText.split('\n')[0]) || '';
            const sli = document.createElement('li');
            const sContent = document.createElement('div');
            sContent.className = 'swipe-content';
            sContent.textContent = title;
            sli.appendChild(sContent);
            const sDel = document.createElement('button');
            sDel.className = 'mobile-delete';
            sDel.textContent = '🗑️';
            sli.appendChild(sDel);
            addLongPressListener(sContent, () => {
              const sec = data.folders[idx].sections[si];
              if (!sec) return;
              const firstLine = (sec.rawText || '').split('\n')[0].trim();
              const fallback = sec.type === 'label'
                ? (firstLine || 'Label Question')
                : (firstLine || '(untitled)');
              const currentTitle = sec.title && sec.title.trim()
                ? sec.title
                : (sec.type === 'acronym' ? (sec.acronym || fallback) : fallback);
              const newTitle = prompt('Rename question:', currentTitle);
              if (newTitle === null) return;
              sec.title = newTitle.trim();
              saveData();
              if (!isQuizMode) {
                enterEdit();
                if (idx === currentFolder && currentSection === si) {
                  updateHeader();
                  loadSection();
                }
              } else {
                renderSections(lastSectionOrder);
                if (idx === currentFolder && currentSection === si) {
                  updateHeader();
                }
              }
              buildMobileFolderList();
            });
            enableSwipeToDelete(sli, sContent, sDel, () => {
              if (confirm(`Delete question "${title}"? This cannot be undone.`)) {
                data.folders[idx].sections.splice(si, 1);
                const secs = data.folders[idx].sections;
                if (idx === currentFolder) {
                  if (secs.length > 0) {
                    currentSection = si < secs.length ? si : secs.length - 1;
                  } else {
                    currentSection = null;
                  }
                }
                saveData();
                renderSections(lastSectionOrder);
                mobileOpenFolders.add(idx);
                buildMobileFolderList();
                enterEdit();
                if (currentSection !== null) loadSection();
              }
            });
            sContent.onclick = e => {
              if (sContent._longPressConsumed) {
                sContent._longPressConsumed = false;
                return;
              }
              if (sli._deleteOpen) {
                sContent.style.transform = '';
                sDel.style.right = '-60px';
                sli._deleteOpen = false;
                return;
              }
              e.stopPropagation();
              if (!isQuizMode) {
                syncCurrentSection();
                if (typeof quill !== 'undefined') quill.blur();
              }
              currentFolder = idx;
              currentSection = si;
              multiFolderMode = false;
              enterQuizQuestion();
              startMobileQuizScreen();
            };
            secList.appendChild(sli);
          });
          const addLi = document.createElement('li');
          addLi.className = 'add-question';
          addLi.textContent = '+ Add Question';
          addLi.onclick = e => { e.stopPropagation(); addQuestionMobile(idx); };
          secList.appendChild(addLi);
          content.onclick = () => {
            if (content._longPressConsumed) {
              content._longPressConsumed = false;
              return;
            }
            if (header._deleteOpen) {
              content.style.transform = '';
              delBtn.style.right = '-60px';
              header._deleteOpen = false;
              return;
            }
            if (randomSelectMode) {
              cb.checked = !cb.checked;
              updateMobileSelectAllState(list);
            } else {
              const isOpen = secList.style.display === 'none';
              secList.style.display = isOpen ? 'block' : 'none';
              if (isOpen) mobileOpenFolders.add(idx); else mobileOpenFolders.delete(idx);
            }
          };
          cb.addEventListener('click', e => {
            if (!randomSelectMode) return;
            e.stopPropagation();
            window.requestAnimationFrame(() => updateMobileSelectAllState(list));
          });
          li.appendChild(header);
          li.appendChild(secList);
          list.appendChild(li);
        });
        if (randomSelectMode) {
          appendMobileSelectAllOption(list);
          updateMobileSelectAllState(list);
        }
      }

      function setRandomSelectMode(on) {
        randomSelectMode = on;
        buildMobileFolderList();
        const list = document.getElementById('mobileFolderList');
        list.classList.toggle('random-select', on);
        const checkboxes = list.querySelectorAll('.folder-select');
        checkboxes.forEach(cb => {
          cb.checked = false;
          cb.indeterminate = false;
        });
        mobileRandomGo.style.display = on ? 'block' : 'none';
        if (on) {
          list.style.display = 'block';
          document.getElementById('mobileSearchResults').style.display = 'none';
        }
      }

      function toggleRandomSelectMode() {
        setRandomSelectMode(!randomSelectMode);
      }

      function startSelectedRandomQuiz() {
        const list = document.getElementById('mobileFolderList');
        const selectAllCb = list ? list.querySelector('.folder-select-all') : null;
        const useAll = !!(selectAllCb && selectAllCb.checked && !selectAllCb.indeterminate);
        const selected = useAll
          ? data.folders.map((_, idx) => idx)
          : getMobileRandomFolderCheckboxes(list).filter(cb => cb.checked).map(cb => parseInt(cb.dataset.index, 10));
        if (selected.length) {
          enterRandomQuizAcrossFolders(selected);
        }
        setRandomSelectMode(false);
      }

      function handleMobileSearch(e) {
        const q = e.target.value.toLowerCase();
        const folderList = document.getElementById('mobileFolderList');
        const results = document.getElementById('mobileSearchResults');
        results.innerHTML = '';
        if (!q) {
          folderList.style.display = 'block';
          results.style.display = 'none';
          return;
        }
        folderList.style.display = 'none';
        results.style.display = 'block';
        data.folders.forEach((f, fi) => {
          f.sections.forEach((s, si) => {
            const title = s.title || s.acronym || (s.rawText && s.rawText.split('\n')[0]) || '';
            if (title.toLowerCase().includes(q)) {
              const li = document.createElement('li');
              li.textContent = `${f.name}: ${title}`;
              li.onclick = () => {
                if (!isQuizMode) {
                  syncCurrentSection();
                  if (typeof quill !== 'undefined') quill.blur();
                }
                currentFolder = fi;
                currentSection = si;
                multiFolderMode = false;
                enterQuizQuestion();
                startMobileQuizScreen();
              };
              results.appendChild(li);
            }
          });
        });
      }

      function enterRandomQuizAcrossFolders(folders) {
        stopSpeech({ clearStart: true });
        if (!folders.length) return;
        if (!isQuizMode) {
          syncCurrentSection();
          if (typeof quill !== 'undefined') quill.blur();
        }
        multiFolderMode = true;
        resetAnswerBank();
        isQuizMode = true;
        const combined = [];
        folders.forEach(f => {
          data.folders[f].sections.forEach((_, i) => combined.push({ folder: f, section: i }));
        });
        quizOrder = combined.sort(() => Math.random() - 0.5);
        quizPos = 0;
        multiProgress = { completed: new Set(), total: quizOrder.length };
        editorArea.style.display = 'none';
        quizArea.style.display = 'block';
        startMobileQuizScreen();
        showQuiz();
        updateProgressIndicator();
        saveRandomQuizState();
      }

      function startMobileQuizScreen() {
        document.body.classList.add('quiz-active');
        homeBtn.style.display = 'none';
        setRandomSelectMode(false);
      }

      function questionCompleted() {
        const inputs = Array.from(document.querySelectorAll('#quizContent input[type="text"]'));
        if (!inputs.length) return true;
        return inputs.every(inp => inp.classList.contains('correct'));
      }

      function markQuestionCompleted() {
        if (multiFolderMode) {
          if (!multiProgress.completed.has(quizPos)) {
            multiProgress.completed.add(quizPos);
          }
          if (multiProgress.completed.size === multiProgress.total) {
            const folders = new Set(quizOrder.map(q => q.folder));
            folders.forEach(f => incrementCompletionCount(f));
            localStorage.removeItem('lastRandomQuiz');
            updateResumeButton();
            alert('🎉 Quiz complete!');
            justCompleted = true;
          } else {
            saveRandomQuizState();
          }
        } else {
          let prog = quizProgress[currentFolder];
          if (!prog) {
            const total = data.folders[currentFolder].sections.length;
            prog = quizProgress[currentFolder] = { completed: new Set(), total };
          } else {
            prog.total = data.folders[currentFolder].sections.length;
          }
          const before = prog.completed.size;
          if (!prog.completed.has(currentSection)) {
            prog.completed.add(currentSection);
          }
          if (prog.completed.size === prog.total && before !== prog.total) {
            alert('🎉 Section complete!');
            incrementCompletionCount(currentFolder);
            prog.completed.clear();
            prog.order = null;
            prog.pos = 0;
            saveProgress();
            justCompleted = true;
          } else {
            saveProgress();
          }
        }
        if (document.body.classList.contains('mobile')) {
          homeBtn.style.display = 'none';
        }
        updateProgressIndicator();
      }

      function updateHeader(titleText) {
        if (titleText === undefined) {
          if (currentFolder !== null && currentSection !== null) {
            const sec = data.folders[currentFolder].sections[currentSection];
            if (sec.type === 'acronym') {
              titleText = sec.acronym;
            } else if (sec.type === 'label') {
              const raw = sec.rawText || '';
              const def = raw.split('\n')[0].trim() || 'Label Question';
              titleText = sec.title && sec.title.trim() ? sec.title : def;
            } else {
              const def = (sec.rawText && sec.rawText.split('\n')[0].trim()) || '(untitled)';
              titleText = sec.title && sec.title.trim() ? sec.title : def;
            }
          } else {
            titleText = headerTitle.textContent || 'QuizMaker';
          }
        }

        headerTitle.textContent = titleText;
        if (currentFolder !== null) {
          const f = data.folders[currentFolder];
          folderBadge.textContent = f.name;
          folderBadge.style.backgroundColor = f.color || '#34495e';
          folderBadge.style.display = 'inline-block';
        } else {
          folderBadge.style.display = 'none';
        }
      }
      // ----- Load persistent data, with static fallback -----
      // Fallback hosted copy for environments where local JSON can't be fetched
      const GITHUB_JSON_URL = 'https://Ethan11San.github.io/quizData.json';
      const RAW_JSON_URL = 'https://raw.githubusercontent.com/Ethan11San/Ethan11San.github.io/main/quizData.json';
      const GITHUB_IMAGE_URL = 'https://Ethan11San.github.io/imageData.json';
      const RAW_IMAGE_URL = 'https://raw.githubusercontent.com/Ethan11San/Ethan11San.github.io/main/imageData.json';
      let imageData = {};
      let data;
      let originalData;
      let staticMode = false;
      let unsyncedChanges = false;
      let copyLocalBtns = [], clearLocalBtns = [];
      function updateLocalButtons() {
        copyLocalBtns.forEach(btn => btn.disabled = !unsyncedChanges);
        clearLocalBtns.forEach(btn => btn.disabled = !unsyncedChanges);
      }
      const isLocalEnv = ['localhost', '127.0.0.1'].includes(location.hostname);

      // --- IndexedDB helpers for local image storage ---
      function openDB() {
        return new Promise((res, rej) => {
          const r = indexedDB.open('quiz-local', 1);
          r.onupgradeneeded = () => r.result.createObjectStore('images', { keyPath: 'hash' });
          r.onsuccess = () => res(r.result);
          r.onerror = () => rej(r.error);
        });
      }

      async function idbPut(hash, blob) {
        const db = await openDB();
        return new Promise((res, rej) => {
          const tx = db.transaction('images', 'readwrite');
          tx.objectStore('images').put({ hash, blob, ts: Date.now() });
          tx.oncomplete = res; tx.onerror = () => rej(tx.error);
        });
      }

      async function idbGet(hash) {
        const db = await openDB();
        return new Promise((res, rej) => {
          const tx = db.transaction('images', 'readonly');
          const req = tx.objectStore('images').get(hash);
          req.onsuccess = () => res(req.result?.blob || null);
          req.onerror = () => rej(req.error);
        });
      }

      function isStorageError(err) {
        if (!err) return false;
        const name = err.name || '';
        const msg = (err.message || '').toLowerCase();
        const code = typeof err.code === 'number' ? err.code : null;
        if (code === 22 || code === 1014) return true;
        if (['QuotaExceededError', 'InvalidStateError', 'UnknownError', 'SecurityError'].includes(name)) return true;
        return /quota|storage|disk|space|persist/.test(msg);
      }

      async function loadImageSource(file) {
        if (typeof createImageBitmap === 'function') {
          try {
            const bmp = await createImageBitmap(file);
            return {
              width: bmp.width,
              height: bmp.height,
              draw: (ctx, w, h) => ctx.drawImage(bmp, 0, 0, w, h),
              cleanup: () => { try { bmp.close(); } catch (_) {} }
            };
          } catch (err) {
            console.warn('createImageBitmap failed, falling back to <img>', err);
          }
        }
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve({
              width: img.naturalWidth || img.width,
              height: img.naturalHeight || img.height,
              draw: (ctx, w, h) => ctx.drawImage(img, 0, 0, w, h),
              cleanup: () => {}
            });
          };
          img.onerror = err => {
            URL.revokeObjectURL(url);
            reject(err);
          };
          img.src = url;
        });
      }

      async function blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = () => reject(fr.error);
          fr.readAsDataURL(blob);
        });
      }

      // Compress image, hash and store
      async function compressImage(file, {max = 1600, quality = 0.75} = {}) {
        const source = await loadImageSource(file);
        const s = Math.min(max / source.width, max / source.height, 1);
        const w = Math.max(1, Math.round(source.width * s));
        const h = Math.max(1, Math.round(source.height * s));
        const c = Object.assign(document.createElement('canvas'), { width: w, height: h });
        const ctx = c.getContext('2d', { alpha: false });
        source.draw(ctx, w, h);
        if (typeof source.cleanup === 'function') source.cleanup();
        const preferWebp = c.toDataURL('image/webp').startsWith('data:image/webp');
        const mime = preferWebp ? 'image/webp' : 'image/jpeg';
        const blob = await new Promise((res, rej) => {
          c.toBlob(b => b ? res(b) : rej(new Error('Canvas toBlob failed')), mime, quality);
        });
        const buf = await blob.arrayBuffer();
        const digest = await crypto.subtle.digest('SHA-256', buf);
        const hash = Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
        return { blob, hash, ext: preferWebp ? 'webp' : 'jpg' };
      }

      async function addLocalImage(file) {
        const attempts = [
          { max: 1600, quality: 0.75 },
          { max: 1400, quality: 0.72 },
          { max: 1200, quality: 0.70 },
          { max: 1000, quality: 0.68 },
          { max: 800, quality: 0.65 },
          { max: 640, quality: 0.60 },
          { max: 512, quality: 0.55 }
        ];
        let fallbackBlob = null;
        let fallbackExt = 'jpg';
        let lastErr = null;
        for (const opts of attempts) {
          const { blob, hash, ext } = await compressImage(file, opts);
          fallbackBlob = blob;
          fallbackExt = ext;
          try {
            await idbPut(hash, blob);
            return { imageRef: `sha256:${hash}`, ext };
          } catch (err) {
            if (!isStorageError(err)) throw err;
            lastErr = err;
          }
        }
        if (fallbackBlob) {
          console.warn('Falling back to inline image storage', lastErr);
          if (!inlineImageFallbackNotified) {
            alert('Local image storage is full or unavailable. This image will be stored directly with the question instead.');
            inlineImageFallbackNotified = true;
          }
          const dataUrl = await blobToDataURL(fallbackBlob);
          return { imageRef: dataUrl, ext: fallbackExt };
        }
        throw lastErr || new Error('Unable to process image');
      }

      async function imageURL(imageRef) {
        if (!imageRef?.startsWith('sha256:')) return null;
        try {
          const blob = await idbGet(imageRef.slice(7));
          return blob ? URL.createObjectURL(blob) : null;
        } catch (err) {
          console.warn('Unable to read stored image', err);
          return null;
        }
      }

      function applyImageRef(imgEl, ref) {
        if (!imgEl || !ref) return;
        if (ref.startsWith('sha256:')) {
          imageURL(ref).then(url => { if (url) imgEl.src = url; });
        } else {
          imgEl.src = ref;
        }
      }

      async function uploadImageToGitHub({ owner, repo, branch = 'main', token }, hash, blob, ext = 'webp') {
        const path = `images/${hash}.${ext}`;
        const content = await new Promise((res, rej) => {
          const fr = new FileReader();
          fr.onload = () => res(fr.result.split(',')[1]);
          fr.onerror = () => rej(fr.error);
          fr.readAsDataURL(blob);
        });
        const base = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;
        const headers = { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' };
        let sha = null;
        const head = await fetch(`${base}?ref=${encodeURIComponent(branch)}`, { headers });
        if (head.ok) sha = (await head.json()).sha;
        const body = { message: sha ? `chore: update image ${path}` : `chore: add image ${path}`, branch, content, ...(sha ? { sha } : {}) };
        const r = await fetch(base, { method: 'PUT', headers, body: JSON.stringify(body) });
        if (!r.ok) throw new Error(`GitHub upload failed ${r.status}`);
        return { path };
      }

      const repoInfo = { owner: 'Ethan11San', repo: 'Ethan11San.github.io' };

      async function syncImagesAndData(token) {
        const opts = { ...repoInfo, branch: 'main', token };
        // Upload any pending images
        for (const folder of data.folders || []) {
          for (const sec of folder.sections || []) {
            if (sec.imageRef && sec.imageRef.startsWith('sha256:')) {
              const hash = sec.imageRef.slice(7);
              const blob = await idbGet(hash);
              if (blob) {
                const ext = sec.imageExt || (blob.type === 'image/jpeg' ? 'jpg' : 'webp');
                const { path } = await uploadImageToGitHub(opts, hash, blob, ext);
                sec.image = path;
                delete sec.imageRef;
                delete sec.imageExt;
              }
            }
            if (sec.extraImages) {
              for (const ex of sec.extraImages) {
                if (ex.imageRef && ex.imageRef.startsWith('sha256:')) {
                  const hash = ex.imageRef.slice(7);
                  const blob = await idbGet(hash);
                  if (blob) {
                    const ext = ex.ext || (blob.type === 'image/jpeg' ? 'jpg' : 'webp');
                    const { path } = await uploadImageToGitHub(opts, hash, blob, ext);
                    ex.image = path;
                    delete ex.imageRef;
                    delete ex.ext;
                  }
                }
              }
            }
            if (sec.rawHtml && typeof sec.rawHtml === 'string') {
              const matches = [...sec.rawHtml.matchAll(/data-img="sha256:([0-9a-f]+)"/g)];
              for (const m of matches) {
                const hash = m[1];
                const blob = await idbGet(hash);
                if (blob) {
                  const ext = blob.type === 'image/jpeg' ? 'jpg' : 'webp';
                  const { path } = await uploadImageToGitHub(opts, hash, blob, ext);
                  sec.rawHtml = sec.rawHtml.replace(`data-img="sha256:${hash}"`, `data-img="${path}"`);
                }
              }
            }
          }
        }
        // Commit quizData.json
        const content = btoa(unescape(encodeURIComponent(JSON.stringify(data, null, 2))));
        const base = `https://api.github.com/repos/${opts.owner}/${opts.repo}/contents/quizData.json`;
        const headers = { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' };
        let sha = null;
        const head = await fetch(`${base}?ref=${encodeURIComponent(opts.branch)}`, { headers });
        if (head.ok) sha = (await head.json()).sha;
        const body = { message: 'chore: update quiz data', branch: opts.branch, content, ...(sha ? { sha } : {}) };
        const resp = await fetch(base, { method: 'PUT', headers, body: JSON.stringify(body) });
        if (!resp.ok) throw new Error('Quiz data upload failed ' + resp.status);
        originalData = JSON.parse(JSON.stringify(data));
        localStorage.removeItem('quizDataLocal');
        unsyncedChanges = false;
        updateLocalButtons();
      }

      function computeDiff(orig, mod) {
        if (orig === mod) return undefined;
        if (typeof orig !== 'object' || orig === null || typeof mod !== 'object' || mod === null) {
          return mod;
        }
        if (Array.isArray(orig) && Array.isArray(mod)) {
          // Use object with numeric keys to avoid sparse arrays turning into
          // `null` values when JSON stringified. This keeps the diff minimal
          // and prevents unintended `null` entries when reapplying changes.
          const result = {};
          const len = Math.max(orig.length, mod.length);
          for (let i = 0; i < len; i++) {
            const diff = computeDiff(orig[i], mod[i]);
            if (diff !== undefined) result[i] = diff;
          }
          if (orig.length !== mod.length) result.length = mod.length;
          return Object.keys(result).length ? result : undefined;
        }
        const out = {};
        const keys = new Set([...Object.keys(orig || {}), ...Object.keys(mod || {})]);
        keys.forEach(key => {
          const hasMod = mod && Object.prototype.hasOwnProperty.call(mod, key);
          if (!hasMod) {
            out[key] = null;
          } else {
            const diff = computeDiff(orig ? orig[key] : undefined, mod[key]);
            if (diff !== undefined) out[key] = diff;
          }
        });
        return Object.keys(out).length ? out : undefined;
      }

      function applyChanges(target, changes) {
          if (typeof changes !== 'object' || changes === null) return changes;
          if (Array.isArray(target) && typeof changes.length === 'number') {
            target.length = changes.length;
          }
          Object.keys(changes).forEach(key => {
            if (Array.isArray(target) && key === 'length') return;
            const val = changes[key];
            if (val === null) {
              if (Array.isArray(target)) {
                target.splice(+key, 1);
              } else {
                delete target[key];
              }
            } else if (typeof val === 'object' && val !== null) {
              target[key] = applyChanges(Array.isArray(val) ? (target[key] || []) : (target[key] || {}), val);
            } else {
              target[key] = val;
            }
          });
          return target;
      }

      function stripImageData(obj) {
        if (typeof obj !== 'object' || obj === null) return obj;
        if (Array.isArray(obj)) {
          const arr = [];
          obj.forEach((item, idx) => {
            const val = stripImageData(item);
            if (!(typeof val === 'object' && val !== null && Object.keys(val).length === 0)) {
              arr[idx] = val;
            }
          });
          return arr;
        }
        const out = {};
        // Only exclude raw image data fields so position/size info persists in localStorage
        const imgKeys = new Set([
          'image', // main/base64 image data
          'img'    // generic image field used in some structures
        ]);
        Object.keys(obj).forEach(key => {
          if (imgKeys.has(key)) return;
          const val = stripImageData(obj[key]);
          if (typeof val === 'object' && val !== null && Object.keys(val).length === 0) return;
          out[key] = val;
        });
        return out;
      }

      if (isLocalEnv) {
        try {
          // Attempt API fetch in local development
          const resp = await fetch('http://localhost:5001/api/quizData', { cache: 'no-store' });
          if (resp.ok) {
            data = await resp.json();
          } else {
            throw new Error('API response not OK: ' + resp.status);
          }
        } catch (apiErr) {
          console.warn('API unavailable, falling back to quizData.json', apiErr);
          staticMode = true;
        }
      } else {
        // When not running locally, skip API fetch
        staticMode = true;
      }

      if (!data) {
        try {
          const resp2 = await fetch('./quizData.json', { cache: 'no-store' });
          if (!resp2.ok) throw new Error('Static file response not OK');
          data = await resp2.json();
        } catch (staticErr) {
          console.warn('Local quizData.json unavailable, attempting GitHub', staticErr);
          try {
            const resp3 = await fetch(GITHUB_JSON_URL, { cache: 'no-store' });
            if (!resp3.ok) throw new Error('GitHub Pages response not OK');
            data = await resp3.json();
          } catch (githubErr) {
            console.warn('Error loading quiz data from GitHub Pages', githubErr);
            try {
              const resp4 = await fetch(RAW_JSON_URL, { cache: 'no-store' });
              if (!resp4.ok) throw new Error('GitHub raw response not OK');
              data = await resp4.json();
            } catch (rawErr) {
              console.error('Error loading quiz data from GitHub', rawErr);
              data = { folders: [] };
            }
          }
        }
      }

      const normalizeSection = section => {
        if (!section || typeof section !== 'object') return;
        if (!section.type) {
          section.type = 'fill';
        }
      };

      (data.folders || []).forEach(folder => {
        if (!folder.sections) return;
        folder.sections.forEach(normalizeSection);
      });

      originalData = JSON.parse(JSON.stringify(data));

      // Load legacy image data for backward compatibility
      (async () => {
        try {
          const imgResp = await fetch('./imageData.json', { cache: 'no-store' });
          if (imgResp.ok) {
            imageData = await imgResp.json();
          } else {
            throw new Error('imageData.json not found');
          }
        } catch (err) {
          try {
            const fallbackResp = await fetch(GITHUB_IMAGE_URL, { cache: 'no-store' });
            if (fallbackResp.ok) {
              imageData = await fallbackResp.json();
            } else {
              throw new Error('GitHub Pages image response not OK');
            }
          } catch (err2) {
            try {
              const rawResp = await fetch(RAW_IMAGE_URL, { cache: 'no-store' });
              if (rawResp.ok) {
                imageData = await rawResp.json();
              } else {
                console.warn('imageData.json not found or inaccessible');
              }
            } catch (err3) {
              console.warn('Could not load imageData.json', err3);
            }
          }
        }
      })();

      const storedLocal = localStorage.getItem('quizDataLocal');
      if (storedLocal) {
        try {
          const localDiff = JSON.parse(storedLocal);
          const patched = applyChanges(JSON.parse(JSON.stringify(data)), localDiff);
          const remaining = computeDiff(data, patched);
          if (remaining && Object.keys(remaining).length) {
            data = patched;
            unsyncedChanges = true;
            localStorage.setItem('quizDataLocal', JSON.stringify(remaining));
          } else {
            localStorage.removeItem('quizDataLocal');
          }
        } catch (e) {
          console.warn('Failed to apply local changes', e);
          localStorage.removeItem('quizDataLocal');
        }
      }

      function saveData() {
        let diff = computeDiff(originalData, data);
        if (diff) diff = stripImageData(diff);
        if (diff && Object.keys(diff).length) {
          unsyncedChanges = true;
          localStorage.setItem('quizDataLocal', JSON.stringify(diff));
        } else {
          unsyncedChanges = false;
          localStorage.removeItem('quizDataLocal');
        }
        updateLocalButtons();
      }

      let resumeQuizBtn;
      let mobileUIInitialized = false;
      let waitingForImagePaste = null; // {target:'main'|'extra', index?:number}
      let isAddingDefinition = false;
      const foldersUL = document.getElementById('folders'), sectionsUL = document.getElementById('sections'),
            sectionSearch = document.getElementById('sectionSearch'),
            newFolderName = document.getElementById('newFolderName'), addFolderBtn = document.getElementById('addFolderBtn'),
            addFillBtn = document.getElementById('addFillBtn'),
            addLabelBtn = document.getElementById('addLabelBtn'),
            addAcronymBtn = document.getElementById('addAcronymBtn'),
            labelImageInput = document.getElementById('labelImageInput'),
            labelEditor = document.getElementById('labelEditor'),
            editModeBtn = document.getElementById('editModeBtn'),
            quizModeBtn = document.getElementById('quizModeBtn'),
            quizAllBtn  = document.getElementById('quizAllBtn'),
            editorArea = document.getElementById('editorArea'),
            quizArea = document.getElementById('quizArea'),
            previewDiv = document.getElementById('preview'), addPictureBtn = document.getElementById('addPictureBtn'), altContainer = document.getElementById('altContainer'),
            quizContent = document.getElementById('quizContent'), answerBank = document.getElementById('answerBank'), toggleAnswersBtn = document.getElementById('toggleAnswersBtn'), backBtn = document.getElementById('backBtn'), nextBtn = document.getElementById('nextBtn'), hintBtn = document.getElementById('hintBtn'), editQuestionBtn = document.getElementById('editQuestionBtn'), homeBtn = document.getElementById('homeBtn'), mobileRandomBtn = document.getElementById('mobileRandomBtn'), mobileRandomGo = document.getElementById('mobileRandomGo'), mobileViewToggleBtn = document.getElementById('mobileViewToggleBtn'), mobileToggleContainer = document.getElementById('mobileToggleContainer'), ttsControls = document.getElementById('ttsControls'), ttsSpeakBtn = document.getElementById('ttsSpeakBtn'), ttsPauseBtn = document.getElementById('ttsPauseBtn'), ttsStopBtn = document.getElementById('ttsStopBtn'), ttsRefreshBtn = document.getElementById('ttsRefreshBtn'), ttsHint = document.getElementById('ttsHint'), ttsVoiceLabel = document.getElementById('ttsVoiceLabel'), ttsVoiceSelect = document.getElementById('ttsVoiceSelect'), ttsRateLabel = document.getElementById('ttsRateLabel'), ttsRateSlider = document.getElementById('ttsRateSlider'), ttsRateValue = document.getElementById('ttsRateValue');
      resumeRandomBtn = document.getElementById('resumeRandomBtn');
      copyLocalBtns = Array.from(document.querySelectorAll('.copy-local-btn'));
      clearLocalBtns = Array.from(document.querySelectorAll('.clear-local-btn'));
      resumeQuizBtn = document.getElementById('resumeQuizBtn');
      const toggleDeleteBtn = document.getElementById('toggleDeleteBtn');
      const clearSearchBtn = document.getElementById('clearSearchBtn');
      const editorDiv = document.getElementById('editor');
      let pendingRevealSpan = null;
      let lastRange = null;
      const folderBadge = document.getElementById('folderBadge');
      const headerTitle = document.getElementById('headerTitle');
      const headerElem = document.getElementById('header');
      const nativeMobileExperience = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      const folderSection = document.getElementById('folderSection');
      const folderToggle = document.getElementById('folderToggle');
      const folderCollapseBody = folderSection ? folderSection.querySelector('.collapsible-body') : null;
      const FOLDER_COLLAPSE_STORAGE_KEY = 'quizmaker-folders-collapsed';

      const isDesktopLayout = () => !document.body.classList.contains('mobile');

      const setFolderCollapsed = (collapsed, { persist = true, immediate = false } = {}) => {
        if (!folderSection || !folderToggle) return;
        if (!isDesktopLayout()) {
          collapsed = false;
        }
        folderSection.classList.toggle('collapsed', collapsed);
        folderSection.classList.toggle('expanded', !collapsed);
        folderToggle.setAttribute('aria-expanded', String(!collapsed));
        folderToggle.setAttribute('title', collapsed ? 'Expand folders' : 'Collapse folders');
        if (folderCollapseBody && immediate) {
          folderCollapseBody.classList.add('no-animate');
          requestAnimationFrame(() => folderCollapseBody.classList.remove('no-animate'));
        }
        if (persist && isDesktopLayout()) {
          try {
            localStorage.setItem(FOLDER_COLLAPSE_STORAGE_KEY, collapsed ? 'true' : 'false');
          } catch (err) {
            // ignore storage errors
          }
        }
      };

      const readFolderCollapsePreference = () => {
        try {
          return localStorage.getItem(FOLDER_COLLAPSE_STORAGE_KEY) === 'true';
        } catch (err) {
          return false;
        }
      };

      const syncFolderCollapseForEnvironment = (immediate = false) => {
        if (!folderSection || !folderToggle) return;
        if (isDesktopLayout()) {
          setFolderCollapsed(readFolderCollapsePreference(), { persist: false, immediate });
        } else {
          setFolderCollapsed(false, { persist: false, immediate });
        }
      };

      if (folderSection && folderToggle) {
        syncFolderCollapseForEnvironment(true);
        folderToggle.addEventListener('click', () => {
          if (!isDesktopLayout()) return;
          const nextState = !folderSection.classList.contains('collapsed');
          setFolderCollapsed(nextState);
        });
        const bodyClassObserver = new MutationObserver(() => syncFolderCollapseForEnvironment(true));
        bodyClassObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
      }

      const supportsSpeechSynthesis = 'speechSynthesis' in window && typeof SpeechSynthesisUtterance !== 'undefined';
      const TTS_VOICE_STORAGE_KEY = 'quizmaker-tts-voice';
      const TTS_RATE_STORAGE_KEY = 'quizmaker-tts-rate';
      let ttsUtterance = null;
      let ttsStartElement = null;
      let ttsSpeechState = null;
      let ttsHighlightLayer = null;
      let ttsHighlightElements = [];
      let availableTtsVoices = [];
      let ttsSelectedVoiceKey = null;
      let ttsRate = 1;

      const buildVoiceKey = (...parts) => parts
        .filter(part => typeof part === 'string' && part !== '')
        .join(':::');

      const getVoiceKeyVariants = voice => {
        if (!voice) return [''];
        const voiceURI = typeof voice.voiceURI === 'string' ? voice.voiceURI : '';
        const name = typeof voice.name === 'string' ? voice.name : '';
        const lang = typeof voice.lang === 'string' ? voice.lang : '';
        const variants = [];
        const compositeKey = buildVoiceKey(voiceURI, name, lang);
        if (compositeKey) variants.push(compositeKey);
        const voiceUriAndName = buildVoiceKey(voiceURI, name);
        if (voiceUriAndName) variants.push(voiceUriAndName);
        if (voiceURI) variants.push(voiceURI);
        const nameAndLang = buildVoiceKey(name, lang);
        if (nameAndLang) variants.push(nameAndLang);
        if (!variants.length) variants.push('');
        return [...new Set(variants)];
      };

      const getVoiceKey = voice => getVoiceKeyVariants(voice)[0] || '';

      const voiceMatchesKey = (voice, key) => {
        if (!voice || !key) return false;
        return getVoiceKeyVariants(voice).includes(key);
      };

      function nodeMarkedForSpeechSkip(node) {
        while (node && node !== quizContent) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.hasAttribute('data-tts-skip')) return true;
            const ariaHidden = node.getAttribute && node.getAttribute('aria-hidden');
            if (ariaHidden && ariaHidden !== 'false') return true;
          }
          node = node.parentNode;
        }
        return false;
      }

      function updateTtsHint() {
        if (!ttsHint) return;
        if (!supportsSpeechSynthesis) {
          ttsHint.textContent = 'Text-to-speech is not supported in this browser.';
          return;
        }
        const refreshTip = supportsSpeechSynthesis && ttsRefreshBtn
          ? ' Installed new system voices? Click “Refresh Voices” to reload the menu.'
          : '';
        if (ttsStartElement) {
          ttsHint.textContent = 'Listening will begin at the highlighted paragraph. Alt+Click it again to reset.' + refreshTip;
        } else {
          ttsHint.textContent = 'Tip: Select text (or Alt+Click a paragraph) before pressing Listen to start there.' + refreshTip;
        }
      }

      function clearTtsStartElement() {
        if (ttsStartElement) {
          ttsStartElement.classList.remove('tts-start-marker');
          ttsStartElement = null;
        }
        updateTtsHint();
      }

      function setTtsStartElement(el) {
        if (!supportsSpeechSynthesis) return;
        if (el === null) {
          clearTtsStartElement();
          return;
        }
        if (!quizContent || !quizContent.contains(el)) {
          clearTtsStartElement();
          return;
        }
        if (ttsStartElement === el) {
          clearTtsStartElement();
          return;
        }
        if (ttsStartElement) {
          ttsStartElement.classList.remove('tts-start-marker');
        }
        ttsStartElement = el;
        ttsStartElement.classList.add('tts-start-marker');
        updateTtsHint();
      }

      function updateTtsButtons() {
        if (!supportsSpeechSynthesis) return;
        if (!ttsSpeakBtn || !ttsPauseBtn || !ttsStopBtn) return;
        const speaking = window.speechSynthesis.speaking;
        const paused = window.speechSynthesis.paused;
        const hasUtterance = !!ttsUtterance && (speaking || paused);
        ttsPauseBtn.disabled = !hasUtterance;
        ttsPauseBtn.textContent = paused ? '▶️ Resume' : '⏸️ Pause';
        ttsStopBtn.disabled = !hasUtterance;
      }

      function stopSpeech({ clearStart = false } = {}) {
        if (!supportsSpeechSynthesis) return;
        if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
          window.speechSynthesis.cancel();
        }
        ttsUtterance = null;
        ttsSpeechState = null;
        clearSpeechHighlight();
        if (clearStart) {
          clearTtsStartElement();
        } else {
          updateTtsHint();
        }
        updateTtsButtons();
      }

      function elementIsHidden(el) {
        while (el && el !== quizContent) {
          if (el.classList && el.classList.contains('hidden-reveal')) return true;
          if (el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') !== 'false') return true;
          if (el.hidden) return true;
          el = el.parentElement;
        }
        return false;
      }

      function createSpeechBuilder() {
        const rawEntries = [];
        return {
          appendText(text, node, startOffset = 0) {
            if (!text) return;
            if (nodeMarkedForSpeechSkip(node)) return;
            for (let i = 0; i < text.length; i++) {
              const rawChar = text[i];
              const normalizedChar = /\s/.test(rawChar) ? ' ' : rawChar;
              rawEntries.push({
                char: normalizedChar,
                rawChar,
                node,
                offset: startOffset + i,
                type: 'text'
              });
            }
          },
          appendBlank(input) {
            if (nodeMarkedForSpeechSkip(input)) return;
            const filler = ' blank ';
            for (let i = 0; i < filler.length; i++) {
              const ch = filler[i];
              rawEntries.push({
                char: ch === ' ' ? ' ' : ch,
                rawChar: ch,
                node: input,
                offset: null,
                type: 'element'
              });
            }
          },
          appendSpace(node) {
            if (nodeMarkedForSpeechSkip(node)) return;
            rawEntries.push({
              char: ' ',
              rawChar: ' ',
              node,
              offset: null,
              type: 'space'
            });
          },
          finalize() {
            if (!rawEntries.length) {
              return { text: '', charMap: [] };
            }
            const collapsed = [];
            let prevWasSpace = false;
            rawEntries.forEach(entry => {
              const char = entry.char;
              if (char === ' ') {
                if (!prevWasSpace) {
                  collapsed.push({ ...entry, char: ' ' });
                  prevWasSpace = true;
                }
              } else {
                collapsed.push({ ...entry, char });
                prevWasSpace = false;
              }
            });
            const sanitized = [];
            const punctuationPattern = /[.,!?;:()\[\]{}]/;
            const dashPattern = /[-–—]/;
            const quotePattern = /["“”]/;
            const isDigitChar = value => typeof value === 'string' && /\d/.test(value);
            const addSpaceEntry = sourceEntry => {
              if (!sanitized.length || sanitized[sanitized.length - 1].char !== ' ') {
                sanitized.push({ ...sourceEntry, char: ' ', rawChar: ' ' });
              }
            };
            collapsed.forEach((entry, index) => {
              const char = entry.char;
              const prevChar = index > 0 ? collapsed[index - 1].char : '';
              const nextChar = index < collapsed.length - 1 ? collapsed[index + 1].char : '';
              if (quotePattern.test(char)) {
                return;
              }
              if (punctuationPattern.test(char)) {
                const surroundsDigits = char === '.' && isDigitChar(prevChar) && isDigitChar(nextChar);
                if (surroundsDigits) {
                  sanitized.push({ ...entry, char, rawChar: char });
                } else {
                  addSpaceEntry(entry);
                }
                return;
              }
              if (dashPattern.test(char)) {
                addSpaceEntry(entry);
                return;
              }
              if (char === ' ') {
                addSpaceEntry(entry);
                return;
              }
              sanitized.push({ ...entry, char, rawChar: char });
            });
            while (sanitized.length && sanitized[0].char === ' ') {
              sanitized.shift();
            }
            while (sanitized.length && sanitized[sanitized.length - 1].char === ' ') {
              sanitized.pop();
            }
            const text = sanitized.map(entry => entry.char).join('');
            return { text, charMap: sanitized };
          }
        };
      }

      function rangeIntersects(range, node) {
        if (!range || !node) return false;
        if (typeof range.intersectsNode === 'function') {
          try {
            return range.intersectsNode(node);
          } catch (err) {
            // fall back to manual calculation
          }
        }
        const testRange = document.createRange();
        try {
          if (node.nodeType === Node.TEXT_NODE) {
            testRange.selectNodeContents(node);
          } else {
            testRange.selectNode(node);
          }
        } catch (err) {
          if (typeof testRange.detach === 'function') testRange.detach();
          return false;
        }
        const endBeforeOrTouchingStart = range.compareBoundaryPoints(Range.END_TO_START, testRange) <= 0;
        const startAfterOrTouchingEnd = range.compareBoundaryPoints(Range.START_TO_END, testRange) >= 0;
        const intersects = !(endBeforeOrTouchingStart || startAfterOrTouchingEnd);
        if (typeof testRange.detach === 'function') testRange.detach();
        return intersects;
      }

      function collectSpeechFromNode(node, builder) {
        if (!node) return;
        if (node.nodeType === Node.TEXT_NODE) {
          if (nodeMarkedForSpeechSkip(node.parentElement)) return;
          if (elementIsHidden(node.parentElement)) return;
          builder.appendText(node.nodeValue, node, 0);
          return;
        }
        if (node.nodeType !== Node.ELEMENT_NODE) return;
        const el = node;
        if (nodeMarkedForSpeechSkip(el)) return;
        if (elementIsHidden(el)) return;
        if (el.matches('script, style')) return;
        if (el.matches('br')) {
          builder.appendSpace(el);
          return;
        }
        if (el.matches('input.blank-input')) {
          builder.appendBlank(el);
          return;
        }
        let child = el.firstChild;
        while (child) {
          collectSpeechFromNode(child, builder);
          child = child.nextSibling;
        }
      }

      function collectSpeechFromStartElement(startEl, builder) {
        if (!quizContent) return;
        if (startEl && quizContent.contains(startEl)) {
          collectSpeechFromNode(startEl, builder);
          let sibling = startEl.nextSibling;
          while (sibling) {
            collectSpeechFromNode(sibling, builder);
            sibling = sibling.nextSibling;
          }
        } else {
          let child = quizContent.firstChild;
          while (child) {
            collectSpeechFromNode(child, builder);
            child = child.nextSibling;
          }
        }
      }

      function collectSpeechFromRange(range, builder) {
        if (!range || !quizContent) return;
        const whatToShow = NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT;
        const walker = document.createTreeWalker(range.commonAncestorContainer, whatToShow, {
          acceptNode(node) {
            if (!quizContent.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.nodeType === Node.TEXT_NODE) {
              if (nodeMarkedForSpeechSkip(node.parentElement)) return NodeFilter.FILTER_REJECT;
              if (!rangeIntersects(range, node)) {
                return NodeFilter.FILTER_REJECT;
              }
              if (elementIsHidden(node.parentElement)) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
            if (node.nodeType === Node.ELEMENT_NODE) {
              if (nodeMarkedForSpeechSkip(node)) return NodeFilter.FILTER_REJECT;
              if (elementIsHidden(node)) return NodeFilter.FILTER_REJECT;
              if (!rangeIntersects(range, node)) {
                return NodeFilter.FILTER_SKIP;
              }
              if (node.matches('input.blank-input') || node.matches('br')) {
                return NodeFilter.FILTER_ACCEPT;
              }
              if (node.matches('script, style')) {
                return NodeFilter.FILTER_REJECT;
              }
              return NodeFilter.FILTER_SKIP;
            }
            return NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode()) {
          const current = walker.currentNode;
          if (current.nodeType === Node.TEXT_NODE) {
            const node = current;
            const startOffset = node === range.startContainer ? range.startOffset : 0;
            const endOffset = node === range.endContainer ? range.endOffset : node.nodeValue.length;
            if (endOffset <= startOffset) continue;
            builder.appendText(node.nodeValue.slice(startOffset, endOffset), node, startOffset);
          } else if (current.nodeType === Node.ELEMENT_NODE) {
            const el = current;
            if (el.matches('input.blank-input')) {
              builder.appendBlank(el);
            } else if (el.matches('br')) {
              builder.appendSpace(el);
            }
          }
        }
      }

      function buildQuizSpeechData({ startEl = null, range = null } = {}) {
        const builder = createSpeechBuilder();
        if (range) {
          collectSpeechFromRange(range, builder);
        } else {
          collectSpeechFromStartElement(startEl, builder);
        }
        return builder.finalize();
      }

      function getSelectedQuizRange() {
        if (!quizContent) return null;
        const selection = window.getSelection();
        if (!selection || !selection.rangeCount) return null;
        const range = selection.getRangeAt(0);
        if (!quizContent.contains(range.commonAncestorContainer)) return null;
        const selectedText = selection.toString().trim();
        if (!selectedText) return null;
        return range.cloneRange();
      }

      function ensureHighlightLayer() {
        if (ttsHighlightLayer && document.body.contains(ttsHighlightLayer)) {
          return ttsHighlightLayer;
        }
        if (!quizContent) return null;
        ttsHighlightLayer = document.getElementById('ttsHighlightLayer');
        if (!ttsHighlightLayer) {
          ttsHighlightLayer = document.createElement('div');
          ttsHighlightLayer.id = 'ttsHighlightLayer';
          ttsHighlightLayer.setAttribute('data-tts-skip', 'true');
          ttsHighlightLayer.setAttribute('aria-hidden', 'true');
          quizContent.appendChild(ttsHighlightLayer);
        }
        return ttsHighlightLayer;
      }

      function clearSpeechHighlight() {
        if (ttsHighlightLayer && ttsHighlightLayer.parentNode) {
          ttsHighlightLayer.innerHTML = '';
        }
        if (ttsHighlightElements.length) {
          ttsHighlightElements.forEach(el => el.classList.remove('quiz-tts-outline'));
          ttsHighlightElements = [];
        }
      }

      function highlightSpeechAt(charIndex, charLength = 0) {
        if (!ttsSpeechState || !ttsSpeechState.charMap || !ttsSpeechState.charMap.length) return;
        if (typeof charIndex !== 'number' || charIndex < 0) return;
        const map = ttsSpeechState.charMap;
        if (charIndex >= map.length) return;
        let start = charIndex;
        let end = charLength ? charIndex + charLength : charIndex;
        if (!charLength) {
          while (end < map.length && map[end].char !== ' ') {
            end++;
          }
        } else {
          end = Math.min(end, map.length);
        }
        while (start < map.length && map[start].char === ' ') start++;
        while (end < map.length && map[end].char === ' ') end++;
        if (end <= start) {
          end = start;
          while (end < map.length && map[end].char !== ' ') end++;
        }
        if (start >= map.length) return;
        const slice = map.slice(start, Math.min(end, map.length));
        if (!slice.length) return;
        const wordPattern = /[A-Za-z0-9]/;
        if (!slice.some(entry => wordPattern.test(entry.char))) {
          return;
        }
        clearSpeechHighlight();
        const textEntries = slice.filter(entry => entry.node && entry.node.nodeType === Node.TEXT_NODE);
        const elementEntries = slice.filter(entry => entry.node && entry.node.nodeType === Node.ELEMENT_NODE);
        if (textEntries.length) {
          const range = document.createRange();
          const first = textEntries[0];
          const last = textEntries[textEntries.length - 1];
          const endOffset = Math.min(last.node.nodeValue.length, last.offset + 1);
          range.setStart(first.node, first.offset);
          range.setEnd(last.node, endOffset);
          const layer = ensureHighlightLayer();
          if (layer) {
            layer.innerHTML = '';
            const rects = Array.from(range.getClientRects());
            const containerRect = quizContent.getBoundingClientRect();
            rects.forEach(rect => {
              const box = document.createElement('div');
              box.className = 'tts-highlight-box';
              box.style.top = `${rect.top - containerRect.top}px`;
              box.style.left = `${rect.left - containerRect.left}px`;
              box.style.width = `${rect.width}px`;
              box.style.height = `${rect.height}px`;
              layer.appendChild(box);
            });
          }
          if (typeof range.detach === 'function') range.detach();
        }
        elementEntries.forEach(entry => {
          const el = entry.node;
          if (el && el.classList) {
            el.classList.add('quiz-tts-outline');
            ttsHighlightElements.push(el);
          }
        });
      }

      function updateVoiceControlsVisibility(show) {
        const displayValue = show ? 'flex' : 'none';
        if (ttsVoiceLabel) {
          ttsVoiceLabel.style.display = displayValue;
        }
        if (ttsRateLabel) {
          ttsRateLabel.style.display = displayValue;
        }
      }

      function updateRateValueDisplay() {
        if (!ttsRateValue) return;
        const formatted = `${ttsRate.toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}×`;
        ttsRateValue.textContent = formatted;
      }

      function initializeTtsRate() {
        if (!ttsRateSlider) return;
        const sliderMin = parseFloat(ttsRateSlider.min || '0.7');
        const sliderMax = parseFloat(ttsRateSlider.max || '1.3');
        let stored = null;
        try {
          stored = localStorage.getItem(TTS_RATE_STORAGE_KEY);
        } catch (err) {
          stored = null;
        }
        let rateValue = stored !== null ? parseFloat(stored) : NaN;
        if (Number.isNaN(rateValue)) {
          rateValue = parseFloat(ttsRateSlider.value || '1') || 1;
        }
        rateValue = Math.min(Math.max(rateValue, sliderMin), sliderMax);
        ttsRate = rateValue;
        ttsRateSlider.value = String(rateValue);
        updateRateValueDisplay();
      }

      function populateVoiceOptions() {
        if (!supportsSpeechSynthesis || !ttsVoiceSelect) return;
        const voices = window.speechSynthesis.getVoices();
        if (!voices || !voices.length) {
          availableTtsVoices = [];
          ttsSelectedVoiceKey = null;
          ttsVoiceSelect.innerHTML = '';
          updateVoiceControlsVisibility(false);
          updateTtsHint();
          return;
        }
        const seenKeys = new Set();
        const uniqueVoices = [];
        voices.forEach(voice => {
          const key = getVoiceKey(voice);
          if (!seenKeys.has(key)) {
            seenKeys.add(key);
            uniqueVoices.push(voice);
          }
        });
        const englishVoices = uniqueVoices.filter(voice => /^en/i.test(voice.lang || ''));
        const filteredVoices = englishVoices.length ? englishVoices : uniqueVoices;
        const qualityPatterns = [
          /neural/i,
          /natural/i,
          /studio/i,
          /wavenet/i,
          /premium/i,
          /expressive/i
        ];
        const favoredNamePatterns = [
          /aria/i,
          /jenny/i,
          /guy/i,
          /davis/i,
          /amber/i,
          /ashley/i,
          /michelle/i,
          /brandon/i,
          /emma/i,
          /sara/i
        ];
        const scoreVoice = voice => {
          let score = 0;
          const name = voice.name || '';
          const lang = (voice.lang || '').toLowerCase();
          if (/^en([-_])?us\b/.test(lang)) {
            score -= 220;
          } else if (/^en\b/.test(lang)) {
            score -= 120;
          } else {
            score += 80;
          }
          if (voice.default) score -= 40;
          qualityPatterns.forEach((pattern, index) => {
            if (pattern.test(name)) {
              score -= (90 - index * 8);
            }
          });
          favoredNamePatterns.forEach((pattern, index) => {
            if (pattern.test(name)) {
              score -= (45 - index * 4);
            }
          });
          if (/online/i.test(name) && !qualityPatterns.some(pattern => pattern.test(name))) {
            score += 12;
          }
          if (/preview/i.test(name)) {
            score += 30;
          }
          return score;
        };
        const sortVoices = list => [...list].sort((a, b) => {
          const diff = scoreVoice(a) - scoreVoice(b);
          if (diff !== 0) return diff;
          return (a.name || '').localeCompare(b.name || '');
        });
        const isUsEnglishVoice = voice => {
          const lang = (voice.lang || '').toLowerCase();
          return /^en([-_])?us\b/.test(lang);
        };
        const isEnglishVoice = voice => /^en/i.test(voice.lang || '');
        availableTtsVoices = sortVoices(filteredVoices);
        if (!availableTtsVoices.length) {
          updateVoiceControlsVisibility(false);
          updateTtsHint();
          return;
        }
        let storedVoiceKey = null;
        try {
          storedVoiceKey = localStorage.getItem(TTS_VOICE_STORAGE_KEY);
        } catch (err) {
          storedVoiceKey = null;
        }
        const currentVoiceKey = ttsSelectedVoiceKey;
        const preferredKeys = [currentVoiceKey, storedVoiceKey].filter(Boolean);
        let preferredVoice = null;
        let preferredVoiceKey = null;
        for (const key of preferredKeys) {
          preferredVoice = availableTtsVoices.find(voice => voiceMatchesKey(voice, key)) || null;
          if (preferredVoice) {
            preferredVoiceKey = getVoiceKey(preferredVoice);
            break;
          }
        }
        if (!preferredVoice) {
          const usPreferred = availableTtsVoices.filter(isUsEnglishVoice);
          const englishPreferred = availableTtsVoices.filter(isEnglishVoice);
          preferredVoice = usPreferred.find(voice => /neural|natural|studio|wavenet|premium/i.test(voice.name))
            || usPreferred.find(voice => voice.default)
            || usPreferred[0]
            || englishPreferred.find(voice => /neural|natural|studio|wavenet|premium/i.test(voice.name))
            || englishPreferred.find(voice => voice.default)
            || englishPreferred[0]
            || availableTtsVoices.find(voice => voice.default)
            || availableTtsVoices[0]
            || null;
          preferredVoiceKey = preferredVoice ? getVoiceKey(preferredVoice) : null;
        }
        ttsVoiceSelect.innerHTML = '';
        const recommendedVoiceKeys = new Set(
          availableTtsVoices.slice(0, Math.min(5, availableTtsVoices.length)).map(getVoiceKey)
        );
        availableTtsVoices.forEach(voice => {
          const option = document.createElement('option');
          const voiceKey = getVoiceKey(voice);
          option.value = voiceKey;
          const badge = voice.default ? ' ⭐' : '';
          const recommended = recommendedVoiceKeys.has(voiceKey) ? ' 🎧' : '';
          option.textContent = `${voice.name} (${voice.lang})${badge}${recommended}`;
          ttsVoiceSelect.appendChild(option);
        });
        let finalVoiceKey = preferredVoiceKey;
        if (finalVoiceKey && !availableTtsVoices.some(voice => voiceMatchesKey(voice, finalVoiceKey))) {
          finalVoiceKey = null;
        }
        if (!finalVoiceKey && availableTtsVoices.length) {
          finalVoiceKey = getVoiceKey(availableTtsVoices[0]);
        }
        if (finalVoiceKey) {
          ttsVoiceSelect.value = finalVoiceKey;
          ttsSelectedVoiceKey = finalVoiceKey;
        } else {
          ttsVoiceSelect.selectedIndex = -1;
          ttsSelectedVoiceKey = null;
        }
        try {
          if (ttsSelectedVoiceKey) {
            localStorage.setItem(TTS_VOICE_STORAGE_KEY, ttsSelectedVoiceKey);
          } else {
            localStorage.removeItem(TTS_VOICE_STORAGE_KEY);
          }
        } catch (err) {
          // ignore storage errors
        }
        updateVoiceControlsVisibility(true);
      }

      function speakQuizText() {
        if (!supportsSpeechSynthesis) return;
        const selectionRange = getSelectedQuizRange();
        const speechData = selectionRange
          ? buildQuizSpeechData({ range: selectionRange })
          : buildQuizSpeechData({ startEl: ttsStartElement });
        if (selectionRange && typeof selectionRange.detach === 'function') {
          selectionRange.detach();
        }
        const text = speechData.text;
        if (!text) {
          alert('No readable text found. Try selecting the text you want to hear first.');
          return;
        }
        window.speechSynthesis.cancel();
        clearSpeechHighlight();
        ttsSpeechState = speechData;
        ttsUtterance = new SpeechSynthesisUtterance(text);
        const currentVoices = window.speechSynthesis.getVoices();
        const resolveVoiceByKey = key => {
          if (!key) return null;
          return currentVoices.find(v => voiceMatchesKey(v, key))
            || availableTtsVoices.find(v => voiceMatchesKey(v, key))
            || null;
        };
        let voice = resolveVoiceByKey(ttsSelectedVoiceKey);
        if (!voice) {
          const fallback = availableTtsVoices.find(v => v.default) || availableTtsVoices[0] || null;
          if (fallback) {
            const fallbackKey = getVoiceKey(fallback);
            voice = resolveVoiceByKey(fallbackKey) || fallback;
            if (voice) {
              ttsSelectedVoiceKey = fallbackKey;
              if (ttsVoiceSelect) {
                ttsVoiceSelect.value = fallbackKey;
              }
              try {
                localStorage.setItem(TTS_VOICE_STORAGE_KEY, fallbackKey);
              } catch (err) {
                // ignore storage errors
              }
            }
          }
        }
        if (voice) {
          ttsUtterance.voice = voice;
          ttsUtterance.lang = voice.lang || 'en-US';
        } else {
          ttsUtterance.lang = 'en-US';
        }
        ttsUtterance.rate = ttsRate || 1;
        ttsUtterance.onboundary = event => {
          if (!event) return;
          if (event.name && event.name !== 'word') return;
          highlightSpeechAt(typeof event.charIndex === 'number' ? event.charIndex : 0, event.charLength || 0);
        };
        ttsUtterance.onpause = () => {
          updateTtsButtons();
        };
        ttsUtterance.onresume = () => {
          updateTtsButtons();
        };
        ttsUtterance.onstart = () => {
          updateTtsButtons();
        };
        ttsUtterance.onend = () => {
          ttsUtterance = null;
          ttsSpeechState = null;
          clearSpeechHighlight();
          updateTtsButtons();
        };
        ttsUtterance.onerror = () => {
          ttsUtterance = null;
          ttsSpeechState = null;
          clearSpeechHighlight();
          updateTtsButtons();
        };
        window.speechSynthesis.speak(ttsUtterance);
        if (window.speechSynthesis.paused) {
          window.speechSynthesis.resume();
        }
        highlightSpeechAt(0, 0);
        updateTtsButtons();
      }

      if (ttsControls) {
        if (supportsSpeechSynthesis) {
          ttsControls.style.display = 'flex';
          updateVoiceControlsVisibility(false);
          initializeTtsRate();
          populateVoiceOptions();
          if (typeof window.speechSynthesis.getVoices === 'function' && !window.speechSynthesis.getVoices().length) {
            setTimeout(populateVoiceOptions, 750);
          }
          if (typeof window.speechSynthesis.addEventListener === 'function') {
            window.speechSynthesis.addEventListener('voiceschanged', populateVoiceOptions);
            window.speechSynthesis.addEventListener('pause', updateTtsButtons);
            window.speechSynthesis.addEventListener('resume', updateTtsButtons);
            window.speechSynthesis.addEventListener('end', updateTtsButtons);
          } else {
            window.speechSynthesis.onvoiceschanged = populateVoiceOptions;
            window.speechSynthesis.onpause = updateTtsButtons;
            window.speechSynthesis.onresume = updateTtsButtons;
            window.speechSynthesis.onend = updateTtsButtons;
          }
          if (ttsRefreshBtn) {
            ttsRefreshBtn.style.display = '';
            ttsRefreshBtn.disabled = false;
            ttsRefreshBtn.addEventListener('click', () => {
              if (!supportsSpeechSynthesis) return;
              ttsRefreshBtn.disabled = true;
              try {
                populateVoiceOptions();
              } finally {
                setTimeout(() => {
                  ttsRefreshBtn.disabled = false;
                }, 250);
              }
            });
          }
          updateTtsHint();
          updateTtsButtons();
        } else {
          ttsControls.style.display = 'block';
          if (ttsSpeakBtn) ttsSpeakBtn.style.display = 'none';
          if (ttsPauseBtn) ttsPauseBtn.style.display = 'none';
          if (ttsStopBtn) ttsStopBtn.style.display = 'none';
          if (ttsRefreshBtn) ttsRefreshBtn.style.display = 'none';
          updateVoiceControlsVisibility(false);
          updateTtsHint();
        }
      }

      if (supportsSpeechSynthesis) {
        if (ttsSpeakBtn) {
          ttsSpeakBtn.addEventListener('click', speakQuizText);
        }
        if (ttsPauseBtn) {
          ttsPauseBtn.addEventListener('click', () => {
            if (window.speechSynthesis.paused) {
              window.speechSynthesis.resume();
            } else if (window.speechSynthesis.speaking) {
              window.speechSynthesis.pause();
            }
            updateTtsButtons();
            setTimeout(updateTtsButtons, 120);
          });
        }
        if (ttsStopBtn) {
          ttsStopBtn.addEventListener('click', () => stopSpeech());
        }
        if (ttsVoiceSelect) {
          ttsVoiceSelect.addEventListener('change', () => {
            const selectedKey = ttsVoiceSelect.value || '';
            const chosen = availableTtsVoices.find(voice => voiceMatchesKey(voice, selectedKey)) || null;
            const canonicalKey = chosen ? getVoiceKey(chosen) : (selectedKey || null);
            if (canonicalKey && canonicalKey !== ttsVoiceSelect.value) {
              ttsVoiceSelect.value = canonicalKey;
            }
            ttsSelectedVoiceKey = canonicalKey || null;
            try {
              if (ttsSelectedVoiceKey) {
                localStorage.setItem(TTS_VOICE_STORAGE_KEY, ttsSelectedVoiceKey);
              } else {
                localStorage.removeItem(TTS_VOICE_STORAGE_KEY);
              }
            } catch (err) {
              // ignore storage errors
            }
          });
        }
        if (ttsRateSlider) {
          ttsRateSlider.addEventListener('input', () => {
            const sliderMin = parseFloat(ttsRateSlider.min || '0.7');
            const sliderMax = parseFloat(ttsRateSlider.max || '1.3');
            const value = parseFloat(ttsRateSlider.value);
            if (Number.isNaN(value)) return;
            ttsRate = Math.min(Math.max(value, sliderMin), sliderMax);
            updateRateValueDisplay();
            try {
              localStorage.setItem(TTS_RATE_STORAGE_KEY, String(ttsRate));
            } catch (err) {
              // ignore storage errors
            }
            if (ttsUtterance) {
              ttsUtterance.rate = ttsRate;
            }
          });
        }
        if (quizContent) {
          quizContent.addEventListener('click', event => {
            if (!event.altKey) return;
            const target = event.target;
            if (!target) return;
            let el = target.nodeType === Node.ELEMENT_NODE ? target : target.parentElement;
            while (el && el !== quizContent) {
              if (el.matches('p, li, h1, h2, h3, h4, h5, h6, .question-section-card, .question-section-body, .question-section-header, .quiz-question-title')) {
                break;
              }
              el = el.parentElement;
            }
            event.preventDefault();
            event.stopPropagation();
            if (!el || el === quizContent) {
              clearTtsStartElement();
              return;
            }
            setTtsStartElement(el);
          });
        }
      }

      function updateMobileToggleButton() {
        if (!mobileViewToggleBtn) return;
        const hasMobileClass = document.body.classList.contains('mobile');
        const simulated = document.body.classList.contains('mobile-simulated');
        const showExit = hasMobileClass && (!nativeMobileExperience || simulated);
        if (showExit) {
          mobileViewToggleBtn.textContent = '💻 Exit Mobile View';
          mobileViewToggleBtn.setAttribute('aria-pressed', 'true');
          mobileViewToggleBtn.title = 'Return to the desktop layout';
        } else {
          mobileViewToggleBtn.textContent = '📱 Mobile View';
          mobileViewToggleBtn.setAttribute('aria-pressed', 'false');
          mobileViewToggleBtn.title = 'Preview the mobile experience on desktop';
        }
      }

      if (mobileViewToggleBtn) {
        if (nativeMobileExperience) {
          if (mobileToggleContainer) mobileToggleContainer.style.display = 'none';
        } else {
          updateMobileToggleButton();
          mobileViewToggleBtn.addEventListener('click', () => {
            const hasMobileClass = document.body.classList.contains('mobile');
            const simulated = document.body.classList.contains('mobile-simulated');
            if (hasMobileClass && !simulated) {
              document.body.classList.remove('mobile');
            } else if (simulated) {
              document.body.classList.remove('mobile-simulated');
              document.body.classList.remove('mobile');
            } else {
              document.body.classList.add('mobile', 'mobile-simulated');
              setupMobileUI();
              window.scrollTo({ top: 0, behavior: 'smooth' });
            }
            updateMobileToggleButton();
          });
        }
      }

      let touchDrag = null;
      const TOUCH_DRAG_THRESHOLD = 8;

      ensureAnswerControlsHome();

      document.addEventListener('touchmove', e => {
        if (!touchDrag) return;
        if (e.touches.length !== 1) {
          if (touchDrag.ghost) touchDrag.ghost.remove();
          touchDrag = null;
          return;
        }
        const t = e.touches[0];
        if (!t) return;
        const dx = t.clientX - touchDrag.startX;
        const dy = t.clientY - touchDrag.startY;
        if (!touchDrag.didDrag) {
          if (Math.sqrt(dx * dx + dy * dy) < TOUCH_DRAG_THRESHOLD) {
            return;
          }
          touchDrag.didDrag = true;
          const ghost = document.createElement('div');
          ghost.className = 'drag-ghost';
          ghost.textContent = touchDrag.text;
          document.body.appendChild(ghost);
          const rect = ghost.getBoundingClientRect();
          touchDrag.offsetX = rect.width;
          touchDrag.offsetY = rect.height;
          ghost.style.left = (t.clientX - touchDrag.offsetX) + 'px';
          ghost.style.top = (t.clientY - touchDrag.offsetY) + 'px';
          touchDrag.ghost = ghost;
        } else if (!touchDrag.ghost) {
          // In the unlikely case a drag started but the ghost failed, cancel the gesture.
          touchDrag = null;
          return;
        }
        if (touchDrag && touchDrag.ghost) {
          touchDrag.ghost.style.left = (t.clientX - touchDrag.offsetX) + 'px';
          touchDrag.ghost.style.top = (t.clientY - touchDrag.offsetY) + 'px';
          e.preventDefault();
        }
      }, { passive: false });

      function endTouchDrag(e) {
        if (!touchDrag) return;
        const sourceEl = touchDrag.source || null;
        if (e.type === 'touchcancel') {
          if (touchDrag.ghost) {
            touchDrag.ghost.remove();
          }
          touchDrag = null;
          if (sourceEl) {
            sourceEl.dataset.skipNextClick = 'false';
          }
          return;
        }
        const shouldFocus = !document.body.classList.contains('mobile');
        const autoClear = true;
        if (touchDrag.didDrag && touchDrag.ghost) {
          const t = e.changedTouches[0];
          if (t) {
            const el = document.elementFromPoint(t.clientX, t.clientY);
            let input = null;
            if (el) {
              if (el.classList && el.classList.contains('blank-input')) {
                input = el;
              } else if (el.closest) {
                const blank = el.closest('.blank');
                if (blank) input = blank.querySelector('.blank-input');
              }
            }
            if (input) {
              applyAnswerToInput(input, touchDrag.text, { focus: shouldFocus, clearOnWrong: autoClear });
            } else if (sourceEl && el && sourceEl.contains(el)) {
              const target = findPreferredBlankTarget();
              if (target) {
                applyAnswerToInput(target, touchDrag.text, { focus: shouldFocus, clearOnWrong: autoClear });
              }
            }
          }
          e.preventDefault();
        } else {
          const target = findPreferredBlankTarget();
          if (target) {
            applyAnswerToInput(target, touchDrag.text, { focus: shouldFocus, clearOnWrong: autoClear });
          }
          e.preventDefault();
        }
        if (touchDrag.ghost) {
          touchDrag.ghost.remove();
        }
        touchDrag = null;
        if (sourceEl) {
          sourceEl.dataset.skipNextClick = 'true';
          setTimeout(() => {
            if (sourceEl.dataset.skipNextClick === 'true') {
              sourceEl.dataset.skipNextClick = 'false';
            }
          }, 0);
        }
      }

      document.addEventListener('touchend', endTouchDrag);
      document.addEventListener('touchcancel', endTouchDrag);

      function updateResumeQuizBtn() {
        if (!resumeQuizBtn) return;
        if (document.body.classList.contains('mobile') &&
            document.body.classList.contains('quiz-active') &&
            editorArea.style.display !== 'none') {
          resumeQuizBtn.style.display = 'inline-block';
        } else {
          resumeQuizBtn.style.display = 'none';
        }
      }

      updateResumeQuizBtn();
      updateResumeButton();

      updateLocalButtons();
      copyLocalBtns.forEach(btn => btn.onclick = async () => {
        let diff = computeDiff(originalData, data);
        if (diff) diff = stripImageData(diff);
        if (!diff || !Object.keys(diff).length) {
          alert('No local changes to sync.');
          return;
        }

        let token = localStorage.getItem('githubToken');
        if (token) {
          const reuse = confirm('Reuse saved GitHub token?\nPress OK to reuse, or Cancel to enter a new token.');
          if (!reuse) {
            token = prompt('GitHub token (leave blank to copy JSON to clipboard)');
            if (token) {
              localStorage.setItem('githubToken', token);
            }
          }
        } else {
          token = prompt('GitHub token (leave blank to copy JSON to clipboard)');
          if (token) {
            localStorage.setItem('githubToken', token);
          }
        }
        if (!token) {
          const serialized = JSON.stringify(diff);
          navigator.clipboard.writeText(serialized)
            .then(() => {
              alert('Local changes copied to clipboard.');
            })
            .catch(err => {
              console.error('Clipboard error:', err);
              alert('Failed to copy: ' + err.message);
            });
          return;
        }
        try {
          await syncImagesAndData(token);
          alert('Sync complete.');
        } catch (err) {
          console.error('Sync error:', err);
          alert('Sync failed: ' + err.message);
        }
      });

      clearLocalBtns.forEach(btn => btn.onclick = () => {
        if (!unsyncedChanges) return;
        if (confirm('Clear all local changes?')) {
          localStorage.removeItem('lastRandomQuiz');
          localStorage.removeItem('quizDataLocal');
          unsyncedChanges = false;
          updateLocalButtons();
          updateResumeButton();
          location.reload();
        }
      });

      resumeRandomBtn.onclick = () => {
        const stored = localStorage.getItem('lastRandomQuiz');
        if (!stored) return;
        try {
          const state = JSON.parse(stored);
          multiFolderMode = true;
          isQuizMode = true;
          quizOrder = state.order || [];
          multiProgress = { completed: new Set(state.completed || []), total: quizOrder.length };
          quizPos = quizOrder.findIndex((_, i) => !multiProgress.completed.has(i));
          if (quizPos === -1) {
            localStorage.removeItem('lastRandomQuiz');
            updateResumeButton();
            return;
          }
          editorArea.style.display = 'none';
          quizArea.style.display = 'block';
          startMobileQuizScreen();
          showQuiz();
          updateProgressIndicator();
          updateResumeButton();
        } catch (e) {
          localStorage.removeItem('lastRandomQuiz');
          updateResumeButton();
        }
      };

      resumeQuizBtn.onclick = () => {
        isQuizMode = true;
        editorArea.style.display = 'none';
        quizArea.style.display = 'block';
        showQuiz();
        updateProgressIndicator();
        updateResumeQuizBtn();
      };

      homeBtn.onclick = () => {
        stopSpeech({ clearStart: true });
        document.body.classList.remove('quiz-active');
        isQuizMode = false;
        quizArea.style.display = 'none';
        editQuestionBtn.style.display = 'none';
        currentFolder = null;
        currentSection = null;
        buildMobileFolderList();
        updateResumeQuizBtn();
        updateResumeButton();
      };

      headerElem.onclick = () => {
        if (document.body.classList.contains('mobile') && document.body.classList.contains('quiz-active')) {
          homeBtn.onclick();
        }
      };

      editQuestionBtn.onclick = () => {
        const sec = currentFolder !== null && currentSection !== null ? data.folders[currentFolder].sections[currentSection] : null;
        if (!sec) return;
        isQuizMode = false;
        enterEdit();
        loadSection();
        previewSection();
      };
      // Whitelist pixel sizes for Quill's size format
      const Size = Quill.import('formats/size');
      Size.whitelist = ['8px','10px','12px','14px','16px','18px','20px','24px','28px','32px'];
      Quill.register(Size, true);

      // Custom blot to preserve popup-word spans with data-img attribute
      const Inline = Quill.import('blots/inline');
      class PopupWordBlot extends Inline {
        static create(value) {
          const node = super.create();
          if (value) node.setAttribute('data-img', value);
          return node;
        }
        static formats(node) {
          return node.getAttribute('data-img');
        }
      }
      PopupWordBlot.blotName = 'popupWord';
      PopupWordBlot.tagName = 'span';
      PopupWordBlot.className = 'popup-word';
      Quill.register(PopupWordBlot);

      // Custom blot to preserve spans used for hidden word reveals
      class HiddenRevealBlot extends Inline {
        static create(value) {
          const node = super.create();
          if (value && value !== true) node.setAttribute('data-reveal-for', value);
          return node;
        }
        static formats(node) {
          return node.getAttribute('data-reveal-for');
        }
      }
      HiddenRevealBlot.blotName = 'hiddenReveal';
      HiddenRevealBlot.tagName = 'span';
      HiddenRevealBlot.className = 'hidden-reveal';
      Quill.register(HiddenRevealBlot);
      const quill = new Quill('#editor', {
        modules: {
          toolbar: {
            container: '#toolbar',
            handlers: {
              undo: function () { this.quill.history.undo(); },
              redo: function () { this.quill.history.redo(); }
            }
          },
          history: { delay: 1000, maxStack: 100, userOnly: true }
        },
        theme: 'snow'
      });
      quill.on('selection-change', range => {
        if (range && range.length > 0) lastRange = range;
      });
      // Auto‑expand the editor height to fit its content
      function adjustEditorHeight() {
        const root      = quill.root;             // editable area (ql-editor)
        const container = document.getElementById('editor'); // outer div

        // Reset to auto so we can measure natural height
        root.style.height      = 'auto';
        container.style.height = 'auto';

        // Set both elements to the new scrollHeight
        const extra = 12; // add breathing room below last line
        const newH = (root.scrollHeight + extra) + 'px';
        root.style.height      = newH;
        container.style.height = newH;
      }
      adjustEditorHeight();           // initial sizing
      quill.on('text-change', adjustEditorHeight);
      // Attach undo/redo handlers
      const toolbarModule = quill.getModule('toolbar');
      toolbarModule.addHandler('undo', () => quill.history.undo());
      toolbarModule.addHandler('redo', () => quill.history.redo());
      const addImageWordBtn = document.getElementById('addImageWordBtn');
      addImageWordBtn.addEventListener('click', async () => {
        if (!ensureSelection()) return;
        const range = quill.getSelection(true);
        if (!range || range.length === 0) {
          alert('Select text first');
          return;
        }
        const insert = async file => {
          try {
            const { imageRef } = await addLocalImage(file);
            if (!imageRef) return;
            quill.formatText(range.index, range.length, 'popupWord', imageRef, 'user');
            quill.setSelection(range.index + range.length, 0, 'silent');
            syncCurrentSection();
          } catch (err) {
            console.error('Failed to attach popup image', err);
            alert('Unable to add that image. Please try a different file.');
          }
        };
        const openFilePicker = () => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = 'image/*';
          input.onchange = async () => {
            const file = input.files[0];
            if (!file) return;
            await insert(file);
          };
          input.click();
        };
        const clipboardSupported = navigator.clipboard && typeof navigator.clipboard.read === 'function';
        const preferFilePicker = document.body.classList.contains('mobile') || !clipboardSupported;
        if (preferFilePicker) {
          openFilePicker();
          return;
        }
        async function getClipboardImage() {
          try {
            const items = await navigator.clipboard.read();
            for (const item of items) {
              const type = item.types.find(t => t.startsWith('image/'));
              if (type) {
                return await item.getType(type);
              }
            }
          } catch (err) {
            console.warn('Clipboard read failed', err);
          }
          return null;
        }
        const blob = await getClipboardImage();
        if (blob) {
          await insert(blob);
          return;
        }
        openFilePicker();
      });
      function syncCurrentSection(){
        if (currentFolder===null || currentSection===null) return;
        const sec = data.folders[currentFolder].sections[currentSection];
        sec.rawHtml = quill.root.innerHTML;
        sec.rawText = quill.getText();
        saveData();
      }
      quill.on('text-change', () => {
        if (isQuizMode) return;
        if (!ensureSelection()) return;

        syncCurrentSection();

        const sec = data.folders[currentFolder].sections[currentSection];
        sec.rawHtml = quill.root.innerHTML;
        sec.rawText = quill.getText();
        saveData();

        // Auto-update the Preview Words area
        previewSection();
      });

      // —— Initial UI render using migrated or loaded data ——
      if (data.folders.length > 0) {
        currentFolder = 0;
        currentSection = data.folders[0].sections.length > 0 ? 0 : null;
      } else {
        currentFolder = null;
        currentSection = null;
      }
      renderFolders();
      renderSections(lastSectionOrder);
      if (currentSection !== null && !isMobileDevice()) {
        if (isQuizMode) {
          enterQuizQuestion();
        } else {
          enterEdit();
          loadSection();
        }
      } else {
        updateHeader('QuizMaker');
      }
      if (isMobileDevice()) {
        setupMobileUI();
      }
      document.body.classList.remove('loading');

      // --- Auto-resize editor textarea with content up to its max height ---
      // function adjustEditorHeight() {
      //   editorTA.style.height = 'auto';
      //   editorTA.style.height = editorTA.scrollHeight + 'px';
      // }
      // if (editorTA) editorTA.addEventListener('input', adjustEditorHeight);
      addAcronymBtn.onclick = () => {
        if (currentFolder === null) return alert('Select a folder first');
        const acr = prompt('Enter acronym (e.g. AAVIATE):');
        if (!acr) return;
        const entries = acr.split('').map(letter => ({
          letter,
          answer: '',
          extra: ''
        }));
        const q = { type: 'acronym', acronym: acr, entries };
        data.folders[currentFolder].sections.push(q);
        currentSection = data.folders[currentFolder].sections.length - 1;
        saveData();
        renderFolders();
        renderSections(lastSectionOrder);
        enterEdit();
        loadSection();
      };


      function renderFolders(){
        function showFolderColorPicker(idx) {
          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = data.folders[idx].color || "#1abc9c";
          colorInput.style.position = "fixed";
          colorInput.style.left = "-1000px";
          document.body.appendChild(colorInput);
          colorInput.addEventListener("change", () => {
            data.folders[idx].color = colorInput.value;
            saveData();
            renderFolders();
            updateHeader(headerTitle.textContent);
            document.body.removeChild(colorInput);
          });
          colorInput.click();
        }

        function showFolderEditDialog(idx) {
          const overlay = document.createElement('div');
          overlay.style.position = 'fixed';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.background = 'rgba(0,0,0,0.3)';
          overlay.style.display = 'flex';
          overlay.style.alignItems = 'center';
          overlay.style.justifyContent = 'center';
          overlay.style.zIndex = '1000';

          const dialog = document.createElement('div');
          dialog.style.background = '#fff';
          dialog.style.padding = '16px';
          dialog.style.borderRadius = '4px';
          dialog.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';

          dialog.innerHTML =
            '<div style="margin-bottom:8px;">' +
              '<label>Name: <input id="folderEditName" type="text" value="' +
                data.folders[idx].name.replace(/"/g,'&quot;') + '"></label>' +
            '</div>' +
            '<div style="margin-bottom:8px;">' +
              '<label>Color: <input id="folderEditColor" type="color" value="' +
                (data.folders[idx].color || '#1abc9c') + '"></label>' +
            '</div>' +
            '<div style="text-align:right;">' +
              '<button id="folderEditOk">OK</button> ' +
              '<button id="folderEditCancel">Cancel</button>' +
            '</div>';

          overlay.appendChild(dialog);
          document.body.appendChild(overlay);

          function close() { document.body.removeChild(overlay); }

          dialog.querySelector('#folderEditCancel').onclick = close;
          dialog.querySelector('#folderEditOk').onclick = () => {
            const name = dialog.querySelector('#folderEditName').value.trim();
            if (name) {
              data.folders[idx].name = name;
              data.folders[idx].color = dialog.querySelector('#folderEditColor').value;
              saveData();
              renderFolders();
              updateHeader(headerTitle.textContent);
            }
            close();
          };
        }
        foldersUL.innerHTML='';
        data.folders.forEach((f,i)=>{
          let li=document.createElement('li');
          // Enable drag-and-drop reordering for folders
          li.draggable = true;
          li.addEventListener('dragstart', e => {
            e.dataTransfer.setData('folder-index', i);
          });
          li.addEventListener('dragover', e => e.preventDefault());
          li.addEventListener('drop', e => {
            e.preventDefault();
            const folderFrom = e.dataTransfer.getData('folder-index');
            const qIdx = e.dataTransfer.getData('question-index');
            if (folderFrom) {
              const from = Number(folderFrom);
              const moved = data.folders.splice(from, 1)[0];
              data.folders.splice(i, 0, moved);
              saveData();
              renderFolders();
              renderSections(lastSectionOrder);
            } else if (qIdx) {
              const fromFolder = Number(e.dataTransfer.getData('from-folder'));
              const secs = data.folders[fromFolder].sections;
              const moved = secs.splice(Number(qIdx), 1)[0];
              data.folders[i].sections.push(moved);
              if (currentFolder === fromFolder) {
                currentSection = Math.min(currentSection, secs.length - 1);
              }
              saveData();
              renderFolders();
              if (currentFolder === fromFolder || currentFolder === i) renderSections(lastSectionOrder);
            }
          });
          const nameSpan = document.createElement('span');
          nameSpan.textContent = f.name;
          li.appendChild(nameSpan);
          li.className=i===currentFolder?'selected':'';
          li.style.borderLeft = '8px solid ' + (f.color || '#1abc9c');
          li.onclick = () => {
            currentFolder = i;
            lastSectionOrder = null; // reset any prior search/order when switching folders
            // Default to first section in the newly selected folder
            if (data.folders[i].sections && data.folders[i].sections.length > 0) {
              currentSection = 0;
            } else {
              currentSection = null;
            }
            updateHeader();
            renderFolders();
            renderSections(lastSectionOrder);
            // If in quiz mode, handle empty folders
            if (isQuizMode) {
              if (currentSection !== null) {
                enterQuizQuestion();
              } else {
                // No questions in folder: show placeholder in quiz area
                editorArea.style.display = 'none';
                quizArea.style.display = 'block';
                quizContent.innerHTML = '<p style="color:#7f8c8d;font-style:italic;">No questions in this folder.</p>';
                updateHeader('');
              }
            } else {
              // Otherwise, default to edit mode for that section
              enterEdit();
              if (currentSection !== null) {
                loadSection();
              } else {
                updateHeader('');
              }
            }
          };
          li.ondblclick = () => {
            showFolderEditDialog(i);
          };
          li.addEventListener("contextmenu", evt => {
            evt.preventDefault();
            showFolderColorPicker(i);
          });
          // Delete folder button
          const delF = document.createElement('span');
          delF.className = 'delete-icon';
          delF.textContent = '✖';
          delF.style.cursor = 'pointer';
          delF.style.color = 'red';
          delF.style.display = deleteMode ? 'inline' : 'none';
          delF.onclick = evt => {
            evt.stopPropagation();
            if (confirm(`Delete folder "${f.name}"? This cannot be undone.`)) {
              // Remove the folder
              data.folders.splice(i, 1);
              // Adjust currentFolder
              if (data.folders.length > 0) {
                const newIdx = i < data.folders.length ? i : data.folders.length - 1;
                currentFolder = newIdx;
                const secs = data.folders[currentFolder].sections;
                currentSection = secs.length > 0 ? 0 : null;
              } else {
                currentFolder = null;
                currentSection = null;
              }
              saveData();
              renderFolders();
              lastSectionOrder = null; // reset ordering after folder deletion
              renderSections(lastSectionOrder);
              enterEdit();
              if (currentSection !== null) {
                loadSection();
              } else {
                updateHeader('');
              }
            }
          };
          li.appendChild(delF);
          foldersUL.appendChild(li);
        });
      }
      function renderSections(order){
        sectionsUL.innerHTML = '';
        if (currentFolder === null) return;
        const indices = order || data.folders[currentFolder].sections.map((_,i) => i);
        indices.forEach(index => {
          const s = data.folders[currentFolder].sections[index];
          const i = index;
          let li=document.createElement('li');
          // Add a subtle left-border color to indicate question type
          li.classList.remove('type-fill', 'type-diagram', 'type-acronym');
          // Default to fill for missing or other types
          if (s.type === 'label')       li.classList.add('type-diagram');
          else if (s.type === 'acronym') li.classList.add('type-acronym');
          else                            li.classList.add('type-fill');
          // Enable drag-and-drop reordering for questions
          li.draggable = true;
          li.addEventListener('dragstart', e => {
            e.dataTransfer.setData('question-index', i);
            e.dataTransfer.setData('from-folder', currentFolder);
          });
          li.addEventListener('dragover', e => e.preventDefault());
          li.addEventListener('drop', e => {
            e.preventDefault();
            const from = Number(e.dataTransfer.getData('question-index'));
            const secs = data.folders[currentFolder].sections;
            const moved = secs.splice(from, 1)[0];
            const to = from < i ? i - 1 : i;
            secs.splice(to, 0, moved);
            if (currentSection === from) {
              currentSection = to;
            } else if (from < currentSection && currentSection <= to) {
              currentSection--;
            } else if (to <= currentSection && currentSection < from) {
              currentSection++;
            }
            saveData();
            renderSections(lastSectionOrder);
            if (!isQuizMode && currentSection !== null) loadSection();
          });
          let title='';
          if(s.type==='acronym') title = s.acronym;
          else if(s.type==='label') {
            const raw = s.rawText || '';
            const defaultTitle = raw.split('\n')[0].trim() || 'Label Question';
            title = s.title && s.title.trim() ? s.title : defaultTitle;
          }
          else { // fill
            const defaultTitle = (s.rawText && s.rawText.split('\n')[0].trim()) || '(untitled)';
            title = s.title && s.title.trim() ? s.title : defaultTitle;
          }
          li.textContent = title;
          // Only toggle the 'selected' class, preserving type-* classes
          if (i === currentSection) li.classList.add('selected');
          else li.classList.remove('selected');
          li.onclick = () => {
            currentSection = i;
            updateHeader();
            renderSections(lastSectionOrder);
            if (isQuizMode) {
              enterQuizQuestion();   // show quiz for this section
            } else {
              enterEdit();           // show editor
              loadSection();
            }
          };
          li.ondblclick=()=>{
            const sec = data.folders[currentFolder].sections[i];
            const defaultTitle = (sec.rawText && sec.rawText.split('\n')[0].trim()) || '(untitled)';
            const currentTitle = sec.title && sec.title.trim() ? sec.title : defaultTitle;
            const newTitle = prompt('Enter new section title:', currentTitle);
            if (newTitle !== null) {
              sec.title = newTitle.trim();
              saveData();
              renderSections(lastSectionOrder);
              enterEdit();
              loadSection();
              // No need to reload editor/rawText
            }
          };
          // Delete section/question button
          const delS = document.createElement('span');
          delS.className = 'delete-icon';
          const delTitle = title;
          delS.textContent = '✖';
          delS.style.cursor = 'pointer';
          delS.style.color = 'red';
          delS.style.display = deleteMode ? 'inline' : 'none';
          delS.onclick = evt => {
            evt.stopPropagation();
            if (confirm(`Delete question "${delTitle}"? This cannot be undone.`)) {
              // Remove the section
              data.folders[currentFolder].sections.splice(i, 1);
              // Adjust currentSection
              const secs = data.folders[currentFolder].sections;
              if (secs.length > 0) {
                currentSection = i < secs.length ? i : secs.length - 1;
              } else {
                currentSection = null;
              }
              saveData();
              renderSections(lastSectionOrder);
              enterEdit();
              if (currentSection !== null) loadSection();
            }
          };
          li.appendChild(delS);
          sectionsUL.appendChild(li);
        });
      }

      // Filter and reorder sections based on search input
      function filterSections() {
        const terms = sectionSearch.value.trim().toLowerCase().split(/\s+/).filter(Boolean);
        lastSectionOrder = null;
        if (!terms.length) {
          renderSections(lastSectionOrder);
          return;
        }
        const secs = data.folders[currentFolder].sections;
        const group1 = [], group2 = [], group3 = [];
        secs.forEach((s, idx) => {
          // Determine title and body text
          const defaultTitle = s.title?.trim() ||
            ((s.rawText||'').split('\n')[0].trim()) ||
            s.acronym ||
            '(untitled)';
          const title = defaultTitle.toLowerCase();
          let body = '';
          if (s.type === 'fill') body = s.rawText || '';
          else if (s.type === 'label')
            body = (s.rawText||'') + ' ' +
              (s.definitions||[]).map(d=>d.rawText||'').join(' ');
          else if (s.type === 'acronym') body = s.acronym;
          body = body.toLowerCase();
          const inTitleAll = terms.every(t => title.includes(t));
          const inBodyAny = terms.some(t => body.includes(t));
          if (inTitleAll) group1.push(idx);
          else if (inBodyAny) group2.push(idx);
          else group3.push(idx);
        });
        lastSectionOrder = [...group1, ...group2];
        renderSections(lastSectionOrder);
      }
      sectionSearch.oninput = () => {
        filterSections();
        clearSearchBtn.style.display = sectionSearch.value ? 'inline' : 'none';
      };
      clearSearchBtn.onclick = () => {
        sectionSearch.value = '';
        filterSections();
        clearSearchBtn.style.display = 'none';
      };

      // Toggle delete icons in folder and question lists
      toggleDeleteBtn.onclick = () => {
        deleteMode = !deleteMode;
        renderFolders();
        renderSections(lastSectionOrder);
      };

      addFolderBtn.onclick = async () => {
        let name = newFolderName.value.trim();
        if (!name) return alert('Folder name cannot be empty');
        data.folders.push({ name, color: '#1abc9c', sections: [] });
        newFolderName.value = '';
        await saveData();
        renderFolders();
        updateHeader(headerTitle.textContent);
      };
      addFillBtn.onclick=async()=>{
        if(currentFolder===null)return alert('Select a folder first');
        const fillTitle = prompt('Enter question title:');
        if (fillTitle === null) return;
        let sec={ type:'fill', title: fillTitle.trim(), rawText:'', hidden:[], alts:{} };
        data.folders[currentFolder].sections.push(sec);
        currentSection=data.folders[currentFolder].sections.length-1;
        await saveData();
        renderSections(lastSectionOrder);
        enterEdit();
        loadSection();
      };

      addLabelBtn.onclick = async () => {
        if (currentFolder === null) return alert('Select a folder first');
        const labelTitle = prompt('Enter question title:');
        if (labelTitle === null) return;
        // Create placeholder label question immediately
        const q = { type:'label', title: labelTitle.trim(), rawText:'', hidden:[], alts:{}, image:'', labels:[], definitions:[], arrows:[] };
        data.folders[currentFolder].sections.push(q);
        currentSection = data.folders[currentFolder].sections.length - 1;
        await saveData();
        renderFolders();
        renderSections(lastSectionOrder);
        enterEdit();
        loadSection();
        // Now prompt user for image input
        if (confirm('Press OK to paste an image from clipboard, or Cancel to select a file from your computer.')) {
          waitingForImagePaste = { target: 'main' };
          alert('Now paste the image from your clipboard.');
        } else {
          labelImageInput.dataset.extraIndex = '';
          labelImageInput.click();
        }
      };
      labelImageInput.onchange = async e => {
        const file = e.target.files[0];
        if (!file) return;
        const { imageRef, ext } = await addLocalImage(file);
        const idx = labelImageInput.dataset.extraIndex;
        const sec = data.folders[currentFolder].sections[currentSection];
        if (idx === '') {
          sec.imageRef = imageRef;
          sec.imageExt = ext;
        } else {
          sec.extraImages = sec.extraImages || [];
          sec.extraImages[idx] = { imageRef, ext, labels: [], arrows: [] };
        }
        await saveData();
        renderFolders();
        renderSections(lastSectionOrder);
        enterEdit();
        loadSection();
        e.target.value = '';
        labelImageInput.dataset.extraIndex = '';
      };

      addPictureBtn.onclick = () => {
        if (currentFolder === null || currentSection === null) return alert('Select a question first');
        const sec = data.folders[currentFolder].sections[currentSection];
        const idx = (sec.extraImages ? sec.extraImages.length : 0);
        if (confirm('Press OK to paste an image from clipboard, or Cancel to select a file from your computer.')) {
          waitingForImagePaste = { target: 'extra', index: idx };
          alert('Now paste the image from your clipboard.');
        } else {
          labelImageInput.dataset.extraIndex = idx;
          labelImageInput.click();
        }
      };

      // Allow pasting an image to update the current label question
      document.addEventListener('paste', async e => {
        if (!waitingForImagePaste) return;
        if (currentFolder === null) return;
        const items = e.clipboardData && e.clipboardData.items;

        async function handleBlob(blob) {
          const { imageRef, ext } = await addLocalImage(blob);
          const sec = data.folders[currentFolder].sections[currentSection];
          if (waitingForImagePaste.target === 'main') {
            sec.imageRef = imageRef;
            sec.imageExt = ext;
          } else {
            sec.extraImages = sec.extraImages || [];
            sec.extraImages[waitingForImagePaste.index] = { imageRef, ext, labels: [], arrows: [] };
          }
          await saveData();
          renderFolders();
          renderSections(lastSectionOrder);
          enterEdit();
          loadSection();
          waitingForImagePaste = null;
          return true;
        }

        let found = false;
        if (items) {
          for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
              const blob = item.getAsFile();
              await handleBlob(blob);
              found = true;
              e.preventDefault();
              break;
            }
          }
        }

        if (!found) {
          try {
            const clipItems = await navigator.clipboard.read();
            for (const item of clipItems) {
              const type = item.types.find(t => t.startsWith('image/'));
              if (type) {
                const blob = await item.getType(type);
                await handleBlob(blob);
                found = true;
                e.preventDefault();
                break;
              }
            }
          } catch (err) {
            console.warn('Clipboard read failed', err);
          }
        }
      });

      function ensureSelection(){ if(currentFolder===null||currentSection===null){ alert('Select a folder and a section first'); return false;} return true; }
      // Quill will override this function below after Quill is initialized.
      function loadSection(){
        const sec = data.folders[currentFolder].sections[currentSection];
        const isMobile = document.body.classList.contains('mobile');
        ensureSectionImages(currentFolder, sec);
        // Update header to show current section title
        let titleText = '';
        if (sec.type === 'acronym') {
          titleText = sec.acronym;
        } else if (sec.type === 'label') {
          const raw = sec.rawText || '';
          const defaultTitle = raw.split('\n')[0].trim() || 'Label Question';
          titleText = sec.title && sec.title.trim() ? sec.title : defaultTitle;
        } else {
          const defaultTitle = (sec.rawText && sec.rawText.split('\n')[0].trim()) || '(untitled)';
          titleText = sec.title && sec.title.trim() ? sec.title : defaultTitle;
        }
        updateHeader(titleText);
        // Hide all main editors
        if (editorDiv) editorDiv.style.display = previewDiv.style.display = labelEditor.style.display = 'none';
        altContainer.style.display = 'none';
        altContainer.innerHTML = '';
        addPictureBtn.style.display = (sec.type === 'label' && !document.body.classList.contains('mobile')) ? 'inline-block' : 'none';

        if (sec.type === 'acronym') {
          labelEditor.style.display = 'block';
          labelEditor.innerHTML = '<h4 style="font-size:1.5rem; margin-bottom:0.75rem;">' + sec.acronym + '</h4><div id="acroEditor"></div>';
          // (rest unchanged)
          // ...acronym editor code...
          const baseCh = 12;
          const answerLengths = sec.entries.map(e => (e.answer||'').length + 2);
          const maxAnswerCh = Math.max(baseCh, ...answerLengths);
          const extraLengths = sec.entries.map(e => (e.extra||'').length + 2);
          const maxExtraCh = Math.max(baseCh, ...extraLengths);
          const acroEditor = document.getElementById('acroEditor');
          acroEditor.innerHTML = '';
          sec.entries.forEach((e, i) => {
            const row = document.createElement('div');
            row.style.marginBottom = '8px';
            row.innerHTML = `
              <strong style="display:inline-block; width:1.5em; text-align:center; margin-right:0.75em; font-size:1.2rem; line-height:1.2;">${e.letter}:</strong>
              <input type="text" placeholder="Answer" id="ans${i}" value="${e.answer}" style="font-size:1.2rem; line-height:1.2; padding:4px; width:${maxAnswerCh}ch;">
              <input type="text" placeholder="Extra info" id="ext${i}" value="${e.extra}" style="font-size:1.2rem; line-height:1.2; padding:4px; margin-left:0.75em; width:${maxExtraCh}ch;">
            `;
            acroEditor.appendChild(row);
            ['ans','ext'].forEach(pref => {
              document.getElementById(pref + i).oninput = evt => {
                if (pref === 'ans') sec.entries[i].answer = evt.target.value;
                else sec.entries[i].extra = evt.target.value;
                saveData();
              };
            });
          });
          return;
        }
        if (sec.type === 'label') {
          // (unchanged label editor code)
          // ...label editor code...
          labelEditor.style.display = 'block';
          const mainSrc = sec.image || '';
          labelEditor.innerHTML = `
            <div id="labelContainer" style="position:relative; display:inline-block; overflow:visible;">
              <img id="labelImg" class="main-image" src="${mainSrc}" style="display:block; user-select:none;">
              <div id="labelOverlay" style="position:absolute; top:0; left:0; width:100%; height:100%;"></div>
            </div>`;
          if (sec.imageRef) {
            const el = document.getElementById('labelImg');
            if (el) applyImageRef(el, sec.imageRef);
          }
          // (rest unchanged)
          // ...rest of label editor code...
          // -- Definitions UI Start --
          const addDefBtn = document.createElement('button');
          addDefBtn.id = 'addDefinitionBtn';
          addDefBtn.textContent = 'Add Definition';
          addDefBtn.style.display = 'block';
          addDefBtn.style.padding = '6px 12px';
          addDefBtn.style.border = 'none';
          addDefBtn.style.borderRadius = '4px';
          addDefBtn.style.background = '#2980b9';
          addDefBtn.style.color = '#fff';
          addDefBtn.style.cursor = 'pointer';
          addDefBtn.addEventListener('click', () => {
            isAddingDefinition = true;
            addDefBtn.textContent = 'Click a label to define';
          });
          labelEditor.appendChild(addDefBtn);
          const defContainer = document.createElement('div');
          defContainer.id = 'labelDefinitions';
          defContainer.className = 'definition-list';
          defContainer.style.padding = '12px';
          defContainer.style.border = '1px solid #bdc3c7';
          defContainer.style.background = '#fff';
          labelEditor.appendChild(defContainer);
          updateDefPosition();
          // Render existing definitions with full mini‑fill functionality
          sec.definitions = sec.definitions || [];
          sec.definitions.forEach((def, dIndex) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'definition-wrapper';
            wrapper.draggable = true;
            // Drag-and-drop handlers to reorder definitions
            wrapper.addEventListener('dragstart', e => {
              if (e.target.tagName.toLowerCase() === 'textarea') {
                e.preventDefault();
                return;
              }
              e.dataTransfer.setData('text/plain', dIndex);
            });
            wrapper.addEventListener('dragover', e => e.preventDefault());
            wrapper.addEventListener('drop', e => {
              e.preventDefault();
              const from = Number(e.dataTransfer.getData('text/plain'));
              const to = dIndex;
              const moved = sec.definitions.splice(from, 1)[0];
              sec.definitions.splice(to, 0, moved);
              saveData();
              loadSection();
            });
            // —— title row + delete button ——
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            const h4 = document.createElement('h4');
            h4.textContent = (dIndex + 1) + '. ' + def.labelText;
            h4.style.fontSize = '1.1rem';
            h4.style.flex = '1';
            row.appendChild(h4);

            const toggleLbl = document.createElement('label');
            toggleLbl.style.fontSize = '0.9rem';
            toggleLbl.style.marginRight = '8px';
            toggleLbl.textContent = 'Hide until solved ';
            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.checked = !!def.hideUntilSolved;
            toggle.onchange = () => {
              def.hideUntilSolved = toggle.checked;
              saveData();
            };
            toggleLbl.appendChild(toggle);
            row.appendChild(toggleLbl);
            const del = document.createElement('span');
            del.textContent = '✖';
            del.style.cursor = 'pointer';
            del.style.color  = 'red';
            del.onclick = evt => {
              evt.stopPropagation();
              if (confirm('Delete this definition?')) {
                sec.definitions.splice(dIndex, 1);
                saveData();
                loadSection();
              }
            };
            row.appendChild(del);
            wrapper.appendChild(row);
            const ta = document.createElement('textarea');
            ta.style.width = '100%';
            ta.style.minHeight = '60px';
            ta.style.height = 'auto';
            ta.style.overflow = 'hidden';
            ta.style.fontSize = '1.1rem';
            ta.value = def.rawText;
            ta.addEventListener('mousedown', () => { wrapper.draggable = false; });
            ta.addEventListener('mouseup',   () => { wrapper.draggable = true; });
            const prevDiv = document.createElement('div');
            prevDiv.style.marginTop = '8px';
            const altDiv  = document.createElement('div');
            altDiv.style.marginTop  = '12px';
            function adjustDefHeight() {
              ta.style.height = 'auto';
              ta.style.height = ta.scrollHeight + 'px';
            }
            ta.addEventListener('input', () => {
              adjustDefHeight();
              def.rawText = ta.value;
              saveData();
              buildDefinitionPreview(def, prevDiv, altDiv);
            });
            wrapper.appendChild(ta);
            adjustDefHeight();
            wrapper.appendChild(prevDiv);
            wrapper.appendChild(altDiv);
            buildDefinitionPreview(def, prevDiv, altDiv);
            defContainer.appendChild(wrapper);
          });
          // Ensure textareas fit existing text after load
          setTimeout(() => {
            defContainer.querySelectorAll('textarea').forEach(t => {
              t.style.height = 'auto';
              t.style.height = t.scrollHeight + 'px';
            });
          }, 0);
          // (rest unchanged, image/label/arrow logic)
          const img = document.getElementById('labelImg');
          const overlay = document.getElementById('labelOverlay');
          const container = document.getElementById('labelContainer');
          let baseWidth = 0, baseHeight = 0, editScale = 1;
          img.onload = () => {
            baseWidth  = sec.imgWidth || img.naturalWidth;
            baseHeight = sec.imgHeight || img.naturalHeight;
            editScale = Math.min(1, (window.innerWidth - 20) / baseWidth);
            const dispW = baseWidth * editScale;
            const dispH = baseHeight * editScale;
            container.style.width  = dispW + 'px';
            container.style.height = dispH + 'px';
            img.style.width = dispW + 'px';
            img.style.height = dispH + 'px';
            scaleLabels(container, baseWidth, baseHeight);
            updateDefPosition();
            positionExtraImages();
          };
          window.addEventListener('resize', () => {
            if (!baseWidth) return;
            editScale = Math.min(1, (window.innerWidth - 20) / baseWidth);
            const dispW = baseWidth * editScale;
            const dispH = baseHeight * editScale;
            container.style.width  = dispW + 'px';
            container.style.height = dispH + 'px';
            img.style.width = dispW + 'px';
            img.style.height = dispH + 'px';
            scaleLabels(container, baseWidth, baseHeight);
            updateDefPosition();
            positionExtraImages();
          });
          if (window.ResizeObserver) {
            new ResizeObserver(() => { updateDefPosition(); scaleLabels(container, baseWidth, baseHeight); positionExtraImages(); }).observe(container);
          }
          container.style.resize = 'none';
          if (sec.imgX != null && sec.imgY != null) {
            container.style.position = 'absolute';
            container.style.left = sec.imgX + 'px';
            container.style.top = sec.imgY + 'px';
          } else {
            container.style.position = 'relative';
          }
          renderExtraImages(sec);
          let lastContextTime = 0;
          if (!isMobile) container.addEventListener('contextmenu', e => {
            e.preventDefault();
            const now = Date.now();
            if (now - lastContextTime < 400) {
              const existing = container.querySelector('#resizeHandle');
              if (existing) {
                existing.remove();
              } else {
                const handle = document.createElement('div');
                handle.id = 'resizeHandle';
                handle.style.position = 'absolute';
                handle.style.width = '16px';
                handle.style.height = '16px';
                handle.style.bottom = '0';
                handle.style.right = '0';
                handle.style.background = '#3498db';
                handle.style.cursor = 'se-resize';
                handle.style.zIndex = '1000';
                container.appendChild(handle);
                handle.addEventListener('mousedown', ev => {
                  ev.preventDefault();
                  const startX = ev.clientX;
                  const startW = container.offsetWidth;
                  const aspect = img.naturalHeight / img.naturalWidth || 1;
                  function onMouseMove(moveEv) {
                    const newW = startW + (moveEv.clientX - startX);
                    const newH = newW * aspect;
                    container.style.width = newW + 'px';
                    container.style.height = newH + 'px';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    scaleLabels(container, baseWidth, baseHeight);
                    positionExtraImages();
                  }
                  function onMouseUp() {
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    sec.imgWidth = container.offsetWidth;
                    sec.imgHeight = container.offsetHeight;
                    saveData();
                    updateDefPosition();
                    scaleLabels(container, baseWidth, baseHeight);
                    positionExtraImages();
                  }
                  document.addEventListener('mousemove', onMouseMove);
                  document.addEventListener('mouseup', onMouseUp);
                });
                handle.addEventListener('touchstart', ev => {
                  ev.preventDefault();
                  const startX = ev.touches[0].clientX;
                  const startW = container.offsetWidth;
                  const aspect = img.naturalHeight / img.naturalWidth || 1;
                  function onMove(moveEv) {
                    const newW = startW + (moveEv.touches[0].clientX - startX);
                    const newH = newW * aspect;
                    container.style.width = newW + 'px';
                    container.style.height = newH + 'px';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    scaleLabels(container, baseWidth, baseHeight);
                    positionExtraImages();
                  }
                  function onEnd() {
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    sec.imgWidth = container.offsetWidth;
                    sec.imgHeight = container.offsetHeight;
                    saveData();
                    updateDefPosition();
                    scaleLabels(container, baseWidth, baseHeight);
                    positionExtraImages();
                  }
                  document.addEventListener('touchmove', onMove, { passive: false });
                  document.addEventListener('touchend', onEnd);
                }, { passive: false });
              }
            }
            lastContextTime = now;
          });
          if (!isMobile) container.addEventListener('mousedown', e => {
            if (e.button !== 0 || e.target !== container) return;
            e.preventDefault();
            let startX = e.clientX, startY = e.clientY;
            let origLeft = parseInt(container.style.left) || 0;
            let origTop = parseInt(container.style.top) || 0;
            function onMouseMove(ev) {
              container.style.left = origLeft + (ev.clientX - startX) + 'px';
              container.style.top = origTop + (ev.clientY - startY) + 'px';
            }
            function onMouseUp() {
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              sec.imgX = parseInt(container.style.left) || 0;
              sec.imgY = parseInt(container.style.top) || 0;
              saveData();
              updateDefPosition();
              positionExtraImages();
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          });
          if (!isMobile) container.addEventListener('touchstart', e => {
            if (e.target !== container) return;
            e.preventDefault();
            let startX = e.touches[0].clientX, startY = e.touches[0].clientY;
            let origLeft = parseInt(container.style.left) || 0;
            let origTop = parseInt(container.style.top) || 0;
            function onMove(ev) {
              const t = ev.touches[0];
              container.style.left = origLeft + (t.clientX - startX) + 'px';
              container.style.top = origTop + (t.clientY - startY) + 'px';
            }
            function onEnd() {
              document.removeEventListener('touchmove', onMove);
              document.removeEventListener('touchend', onEnd);
              sec.imgX = parseInt(container.style.left) || 0;
              sec.imgY = parseInt(container.style.top) || 0;
              saveData();
              updateDefPosition();
              positionExtraImages();
            }
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onEnd);
          }, { passive: false });
          img.onload = () => {
            if (sec.imgWidth && sec.imgHeight) {
              container.style.width = sec.imgWidth + 'px';
              container.style.height = sec.imgHeight + 'px';
              img.style.width = '100%';
              img.style.height = 'auto';
            } else {
              container.style.width = img.naturalWidth + 'px';
              container.style.height = img.naturalHeight + 'px';
            }
            updateDefPosition();
            renderExtraImages(sec);
          };
          if (!isMobile) overlay.ondblclick = evt => {
            if (evt.metaKey) return;
            const rect = img.getBoundingClientRect();
            const x = evt.clientX - rect.left;
            const y = evt.clientY - rect.top;
            const text = prompt('Enter label text:');
            if (text) {
              sec.labels.push({ x, y, text, fontSize: 16 });
              saveData();
              loadSection();
            }
          };
          sec.labels.forEach(lbl => {
            const mark = document.createElement('div');
            mark.textContent = lbl.text;
            mark.style.position = 'absolute';
            mark.style.display = 'inline-block';
            mark.style.padding = '2px 4px';
            mark.style.left = lbl.x + 'px';
            mark.style.top = lbl.y + 'px';
            mark.style.background = '#ffffff';
            mark.style.border        = '1px solid #7f8c8d';
            mark.style.overflow      = 'auto';
            mark.style.whiteSpace    = 'nowrap';
            mark.style.textOverflow  = 'ellipsis';
            mark.style.cursor = isMobile ? 'default' : 'move';
            mark.style.resize = isMobile ? 'none' : 'both';
            mark.style.userSelect = 'none';
            mark.style.webkitUserSelect = 'none';
            mark.style.msUserSelect = 'none';
            mark.style.touchAction = isMobile ? 'auto' : 'none';
            let defIdx = -1;
            if (sec.definitions && sec.definitions.length) {
              defIdx = sec.definitions.findIndex(d => d.labelText === lbl.text);
            }
            if (defIdx >= 0) {
              const num = document.createElement('span');
              num.textContent = defIdx + 1;
              num.style.position = 'absolute';
              num.style.left = '-18px';
              num.style.top = '0';
              num.style.width = '16px';
              num.style.height = '16px';
              num.style.borderRadius = '50%';
              num.style.background = '#1abc9c';
              num.style.color = '#fff';
              num.style.fontSize = '10px';
              num.style.display = 'flex';
              num.style.alignItems = 'center';
              num.style.justifyContent = 'center';
              num.style.pointerEvents = 'none';
              mark.appendChild(num);
            }
            mark.addEventListener('contextmenu', evt => {
              if (!evt.metaKey) return;
              evt.preventDefault();
              evt.stopPropagation();
              if (confirm('Delete this label?')) {
                const idx = sec.labels.indexOf(lbl);
                if (idx >= 0) {
                  sec.labels.splice(idx, 1);
                  saveData();
                  loadSection();
                }
              }
            });
            mark.addEventListener('click', evt => {
              if (!isAddingDefinition) return;
              evt.stopPropagation();
              sec.definitions = sec.definitions || [];
              sec.definitions.push({
                labelText: lbl.text,
                rawText: '',
                hidden: [],
                alts: {},
                hideUntilSolved: false
              });
              saveData();
              isAddingDefinition = false;
              addDefBtn.textContent = 'Add Definition';
              loadSection();
            });
            overlay.appendChild(mark);
            if (!lbl.w) {
              lbl.w = mark.offsetWidth;
              lbl.h = mark.offsetHeight;
              saveData();
            }
            mark.style.width = lbl.w + 'px';
            mark.style.height = lbl.h + 'px';
            mark.style.fontSize = lbl.fontSize + 'px';
            mark.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
            if (!isMobile) {
              mark.addEventListener('mouseup', () => {
                lbl.w = mark.offsetWidth;
                lbl.h = mark.offsetHeight;
                saveData();
              });
              mark.addEventListener('touchend', () => {
                lbl.w = mark.offsetWidth;
                lbl.h = mark.offsetHeight;
                saveData();
              });
            }
            mark.ondblclick = evt => {
              evt.stopPropagation();
              evt.preventDefault();
              const newText = prompt('Edit label text:', lbl.text);
              if (newText !== null) {
                lbl.text = newText;
                mark.textContent = lbl.text;
                lbl.w = mark.offsetWidth;
                lbl.h = mark.offsetHeight;
                mark.style.width = lbl.w + 'px';
                mark.style.height = lbl.h + 'px';
                saveData();
              }
            };
            mark.oncontextmenu = evt => {
              evt.preventDefault();
              evt.stopPropagation();
              const input = prompt('Font size in px:', lbl.fontSize);
              const newSize = parseInt(input, 10);
              if (!isNaN(newSize) && newSize > 0) {
                lbl.fontSize = newSize;
                mark.style.fontSize = lbl.fontSize + 'px';
                lbl.w = mark.offsetWidth;
                lbl.h = mark.offsetHeight;
                mark.style.width = lbl.w + 'px';
                mark.style.height = lbl.h + 'px';
                saveData();
              }
            };
            if (!isMobile) {
              mark.onmousedown = evt => {
                if (evt.button !== 0) return;
                evt.preventDefault();
                let startX = evt.clientX, startY = evt.clientY;
                const origX = lbl.x, origY = lbl.y;
                function onMouseMove(e) {
                  lbl.x = origX + (e.clientX - startX);
                  lbl.y = origY + (e.clientY - startY);
                  mark.style.left = lbl.x + 'px';
                  mark.style.top = lbl.y + 'px';
                }
                function onMouseUp(e) {
                  document.removeEventListener('mousemove', onMouseMove);
                  document.removeEventListener('mouseup', onMouseUp);
                  saveData();
                }
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
              };
              mark.ontouchstart = evt => {
                evt.preventDefault();
                const touch = evt.touches[0];
                let startX = touch.clientX, startY = touch.clientY;
                const origX = lbl.x, origY = lbl.y;
                function onMove(e) {
                  const t = e.touches[0];
                  lbl.x = origX + (t.clientX - startX);
                  lbl.y = origY + (t.clientY - startY);
                  mark.style.left = lbl.x + 'px';
                  mark.style.top = lbl.y + 'px';
                }
                function onEnd() {
                  document.removeEventListener('touchmove', onMove);
                  document.removeEventListener('touchend', onEnd);
                  saveData();
                }
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onEnd);
              };
            }
          });
          if (!isMobile) {
            let svgOverlay = overlay.querySelector('svg');
            if (!svgOverlay) {
              svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
              svgOverlay.setAttribute('style', 'position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;');
              overlay.appendChild(svgOverlay);
            } else {
              while (svgOverlay.firstChild) svgOverlay.removeChild(svgOverlay.firstChild);
            }
            if (sec.arrows) {
              sec.arrows.forEach((a, idx) => {
                const angle = Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
                const arrowLength = a.width * 3;
                const arrowWidth = a.width * 2;
                const lineEndX = a.x2 - arrowLength * Math.cos(angle);
                const lineEndY = a.y2 - arrowLength * Math.sin(angle);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', a.x1);
                line.setAttribute('y1', a.y1);
                line.setAttribute('x2', lineEndX);
                line.setAttribute('y2', lineEndY);
                line.setAttribute('stroke', a.color);
                line.setAttribute('stroke-width', a.width);
                line.setAttribute('pointer-events', 'all');
                svgOverlay.appendChild(line);
                const xBase1 = a.x2 - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
                const yBase1 = a.y2 - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);
                const xBase2 = a.x2 - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
                const yBase2 = a.y2 - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
                const points = `${a.x2},${a.y2} ${xBase1},${yBase1} ${xBase2},${yBase2}`;
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', points);
                polygon.setAttribute('fill', a.color);
                polygon.setAttribute('pointer-events', 'all');
                svgOverlay.appendChild(polygon);
                [line, polygon].forEach(el => {
                  el.addEventListener('contextmenu', evt => {
                    if (!evt.metaKey) return;
                    evt.preventDefault();
                    if (confirm('Delete this arrow?')) {
                      sec.arrows.splice(idx, 1);
                      saveData();
                      loadSection();
                      return;
                    }
                  });
                  el.addEventListener('dblclick', evt => {
                    try {
                      if (!evt.metaKey) return;
                      evt.preventDefault();
                      const existingPopup = document.getElementById('arrowEditPopup');
                      if (existingPopup) existingPopup.remove();
                      const popup = document.createElement('div');
                      popup.id = 'arrowEditPopup';
                      popup.style.position = 'absolute';
                      const overlayRect = overlay.getBoundingClientRect();
                      const fixedLeft = overlayRect.left + 50;
                      const fixedTop = overlayRect.top + 50;
                      popup.style.left = `${fixedLeft}px`;
                      popup.style.top = `${fixedTop}px`;
                      popup.style.transform = 'translate(-50%, -100%)';
                      popup.style.transformOrigin = 'bottom center';
                      popup.style.background = '#fff';
                      popup.style.border = '1px solid #7f8c8d';
                      popup.style.borderRadius = '4px';
                      popup.style.padding = '8px';
                      popup.style.zIndex = '10000';
                      popup.innerHTML = `
                        <label style="display:block;font-size:0.9rem;margin-bottom:4px;">
                          Color: <input type="color" id="arrowColorPicker" value="${a.color}">
                        </label>
                        <label style="display:block;font-size:0.9rem;margin-bottom:4px;">
                          Width: <input type="number" id="arrowWidthPicker" min="1" value="${a.width}" style="width:50px;">
                        </label>
                        <div style="text-align:right;">
                          <button id="arrowSaveBtn" style="margin-right:4px;">Save</button>
                          <button id="arrowCancelBtn">Cancel</button>
                        </div>
                      `;
                      popup.addEventListener('dblclick', evt2 => {
                        evt2.stopPropagation();
                      });
                      overlay.appendChild(popup);
                      document.getElementById('arrowSaveBtn').onclick = () => {
                        const colorVal = document.getElementById('arrowColorPicker').value;
                        const widthVal = parseFloat(document.getElementById('arrowWidthPicker').value);
                        if (colorVal && !isNaN(widthVal) && widthVal > 0) {
                          sec.arrows[idx].color = colorVal;
                          sec.arrows[idx].width = widthVal;
                          saveData();
                          loadSection();
                        }
                      };
                      document.getElementById('arrowCancelBtn').onclick = () => {
                        popup.remove();
                      };
                    } catch (err) {
                      console.error('Arrow popup handler error:', err);
                    }
                  });
                });
              });
            }
            let drawing = false;
            let startX = 0, startY = 0;
            let tempLine = null;
            overlay.addEventListener('mousedown', evt => {
              if (!evt.metaKey || evt.button !== 0) return;
              const rect = img.getBoundingClientRect();
              startX = evt.clientX - rect.left;
              startY = evt.clientY - rect.top;
              drawing = true;
              tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              tempLine.setAttribute('x1', startX);
              tempLine.setAttribute('y1', startY);
              tempLine.setAttribute('x2', startX);
              tempLine.setAttribute('y2', startY);
              tempLine.setAttribute('stroke', '#e74c3c');
              tempLine.setAttribute('stroke-width', '2');
              svgOverlay.appendChild(tempLine);
              evt.preventDefault();
            });
            overlay.addEventListener('mousemove', evt => {
              if (!drawing) return;
              const rect = img.getBoundingClientRect();
              const currX = evt.clientX - rect.left;
              const currY = evt.clientY - rect.top;
              tempLine.setAttribute('x2', currX);
              tempLine.setAttribute('y2', currY);
            });
            document.addEventListener('mouseup', evt => {
              if (!drawing) return;
              drawing = false;
              const rect = img.getBoundingClientRect();
              const endX = evt.clientX - rect.left;
              const endY = evt.clientY - rect.top;
              svgOverlay.removeChild(tempLine);
              tempLine = null;
              if (endX !== startX || endY !== startY) {
                if (!sec.arrows) sec.arrows = [];
                sec.arrows.push({ x1: startX, y1: startY, x2: endX, y2: endY, color: '#e74c3c', width: 2 });
                saveData();
                loadSection();
              }
            });
          }
          return;
        }
        // Reset Quill history *before* loading new content
        quill.history.clear();
        const html = sec.rawHtml || sec.rawText || '';
        // Load the HTML silently so it does not create an undo entry
        quill.clipboard.dangerouslyPasteHTML(html, 'silent');
        // Ensure new content starts with normal formatting
        quill.setSelection(0, 0, 'silent');
        ['bold', 'italic', 'underline'].forEach(f => quill.format(f, false, 'silent'));
        adjustEditorHeight();  // ensure editor resizes for existing content
        // Run a second resize on next tick so Quill gets a chance to lay out its HTML
        setTimeout(() => requestAnimationFrame(adjustEditorHeight), 0);
        previewSection();
        // Migrate old sections using rawText into rawHtml for new formatting features
        if (!sec.rawHtml && sec.rawText) {
          sec.rawHtml = quill.root.innerHTML;
          saveData();
        }
        if (editorDiv) editorDiv.style.display = 'block';
        previewDiv.style.display = 'block';
        // The Quill version of loadSection will override the editor loading.
      }
      // Normalize sec.hidden entries to objects { word, occ }
      function getHiddenEntries(sec, tokens) {
        const entries = Array.isArray(sec.hidden) ? sec.hidden : [];
        const wordCounts = {};
        tokens.forEach(t => {
          const w = t.trim();
          if (w) wordCounts[w] = (wordCounts[w] || 0) + 1;
        });

        const cleaned = [];
        entries.forEach(entry => {
          let obj = null;
          if (typeof entry === 'number') {
            if (entry >= 0 && entry < tokens.length) {
              const word = tokens[entry].trim();
              let occ = 0;
              for (let i = 0; i <= entry; i++) {
                if (tokens[i].trim() === word) occ++;
              }
              obj = { word, occ };
            }
          } else if (entry && typeof entry.word === 'string' && Number.isInteger(entry.occ)) {
            obj = { word: entry.word, occ: entry.occ };
            if (entry.reveal) obj.reveal = true;
            if (entry.trigger && typeof entry.trigger.word === 'string' && Number.isInteger(entry.trigger.occ)) {
              obj.trigger = { word: entry.trigger.word, occ: entry.trigger.occ };
            }
          }
          if (!obj) return;
          const count = wordCounts[obj.word] || 0;
          if (obj.occ <= count) {
            cleaned.push(obj);
          } else if (sec.alts) {
            delete sec.alts[`${obj.word}_${obj.occ}`];
          }
        });

        const resultMap = {};
        cleaned.forEach(o => {
          const key = `${o.word}_${o.occ}`;
          if (!resultMap[key]) resultMap[key] = o;
          else {
            if (!resultMap[key].reveal && o.reveal) resultMap[key].reveal = true;
            if (!resultMap[key].trigger && o.trigger) resultMap[key].trigger = o.trigger;
          }
        });
        const result = Object.values(resultMap);
        sec.hidden = result;
        return result;
      }

      // Extract tokens from a section's rawHtml/rawText the same way the preview
      // builder does, so blank occurrence counts stay consistent across modes
      function extractTokens(sec) {
        if (sec.rawHtml) {
          const tmp = document.createElement('div');
          tmp.innerHTML = sec.rawHtml;
          let toks = [];
          tmp.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
              toks.push(...node.textContent.split(/(\s+)/));
            } else if (node.nodeType === Node.ELEMENT_NODE) {
              if (node.tagName === 'P' || node.tagName === 'DIV') {
                node.childNodes.forEach(child => {
                  if (child.nodeType === Node.TEXT_NODE) {
                    toks.push(...child.textContent.split(/(\s+)/));
                  } else if (child.nodeType === Node.ELEMENT_NODE && child.tagName === 'BR') {
                    toks.push('\n');
                  } else if (child.nodeType === Node.ELEMENT_NODE) {
                    toks.push(...(child.innerText || '').split(/(\s+)/));
                  }
                });
                toks.push('\n');
              } else if (node.tagName === 'BR') {
                toks.push('\n');
              } else if (node.tagName === 'UL') {
                node.childNodes.forEach(li => {
                  if (li.nodeType !== Node.ELEMENT_NODE || li.tagName !== 'LI') return;
                  const liTokens = (li.innerText || '').split(/(\s+)/);
                  liTokens.forEach(t => {
                    const trimmed = t.trim();
                    if (!trimmed || trimmed === '•') return;
                    toks.push(t);
                  });
                });
              } else {
                toks.push(...(node.innerText || '').split(/(\s+)/));
              }
            }
          });
          return toks.filter(t => t.length > 0);
        }
        return (sec.rawText || '').split(/(\s+)/).filter(t => t.length > 0);
      }

      function ensureSectionImages(folderIdx, sec) {
        const folder = data.folders[folderIdx];
        if (!folder || !sec || !imageData) return;
        const entry = (imageData[folder.name] || {})[sec.title];
        if (!entry) return;

        if (!sec.image && entry.image) {
          sec.image = entry.image;
        }
        if (sec.image && !sec.imageRef && typeof sec.image === 'string' && sec.image.startsWith('data:')) {
          (async () => {
            try {
              const blob = await (await fetch(sec.image)).blob();
              const buf = await blob.arrayBuffer();
              const digest = await crypto.subtle.digest('SHA-256', buf);
              const hash = Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
              await idbPut(hash, blob);
              sec.imageRef = `sha256:${hash}`;
              const ext = blob.type.split('/')[1]?.split(';')[0] || 'png';
              sec.imageExt = ext;
            } catch (e) {
              console.warn('Failed to convert legacy main image', e);
            }
          })();
        }
        if (entry.extraImages) {
          sec.extraImages = sec.extraImages || [];
          entry.extraImages.forEach((imgData, idx) => {
            if (!sec.extraImages[idx]) sec.extraImages[idx] = { labels: [], arrows: [] };
            if (!sec.extraImages[idx].image) {
              sec.extraImages[idx].image = imgData;
            }
            const target = sec.extraImages[idx];
            if (target.image && !target.imageRef && typeof target.image === 'string' && target.image.startsWith('data:')) {
              (async () => {
                try {
                  const blob = await (await fetch(target.image)).blob();
                  const buf = await blob.arrayBuffer();
                  const digest = await crypto.subtle.digest('SHA-256', buf);
                  const hash = Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
                  await idbPut(hash, blob);
                  target.imageRef = `sha256:${hash}`;
                  const ext = blob.type.split('/')[1]?.split(';')[0] || 'png';
                  target.ext = ext;
                } catch (e) {
                  console.warn('Failed to convert legacy extra image', e);
                }
              })();
            }
          });
        }
      }

      function previewSection() {
        const editorScrollTop = editorArea ? editorArea.scrollTop : 0;
        const pageScrollTop = window.scrollY || document.documentElement.scrollTop || 0;
        const sec = data.folders[currentFolder].sections[currentSection];
        // Use rawHtml if present, otherwise convert rawText to HTML with paragraphs
        const text = sec.rawHtml
          ? (new DOMParser().parseFromString(sec.rawHtml, 'text/html')).body.innerHTML
          : (sec.rawText || '').split('\n').map(line => `<p>${line}</p>`).join('');
        // Now render the preview preserving <p> and <br> structure
        previewDiv.innerHTML = '';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        document.body.classList.remove('linking');

        let counts = {};
        sec.hidden = sec.hidden || [];
        sec.alts = sec.alts || {};
        // Helper to get hidden entries for a flat list of tokens
        function getHiddenEntriesForTokens(tokens) {
          return getHiddenEntries(sec, tokens);
        }

        function handleWordClick(w, occ) {
          const idx = hiddenEntries.findIndex(e => e.word === w && e.occ === occ);
          if (idx === -1) {
            hiddenEntries.push({ word: w, occ });
          } else if (!hiddenEntries[idx].reveal) {
            hiddenEntries[idx].reveal = true;
          } else {
            hiddenEntries.splice(idx, 1);
          }
          sec.hidden = hiddenEntries;
          saveData();
          previewSection();
        }

        // Collect all tokens for hidden word occurrence counting
        let allTokens = [];
        tempDiv.childNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('hidden-reveal')) {
            return;
          }
          if (node.nodeType === Node.TEXT_NODE) {
            // Split text by whitespace for tokens
            allTokens.push(...node.textContent.split(/(\s+)/));
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.tagName === 'P' || node.tagName === 'DIV') {
              node.childNodes.forEach(child => {
                if (child.nodeType === Node.ELEMENT_NODE && child.classList.contains('hidden-reveal')) {
                  return;
                }
                if (child.nodeType === Node.TEXT_NODE) {
                  allTokens.push(...child.textContent.split(/(\s+)/));
                } else if (child.nodeType === Node.ELEMENT_NODE && child.tagName === 'BR') {
                  allTokens.push('\n');
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                  allTokens.push(...(child.innerText||'').split(/(\s+)/));
                }
              });
              allTokens.push('\n');
            } else if (node.tagName === 'BR') {
              allTokens.push('\n');
            } else if (node.tagName === 'UL') {
              // Add tokens from each list item, skipping the leading bullet glyph
              node.childNodes.forEach(liNode => {
                if (liNode.nodeType !== Node.ELEMENT_NODE || liNode.tagName !== 'LI') return;
                const toks = (liNode.innerText || '').split(/(\s+)/);
                toks.forEach(t => {
                  const trimmed = t.trim();
                  if (!trimmed || trimmed === '•') return;
                  allTokens.push(t);
                });
              });
            } else {
              allTokens.push(...(node.innerText||'').split(/(\s+)/));
            }
          }
        });
        // Remove empty tokens
        allTokens = allTokens.filter(t => t.length > 0);
        const hiddenEntries = getHiddenEntries(sec, allTokens);
        sec.hidden = hiddenEntries;
        saveData();
        // We'll use a running count per word for the preview rendering
        let globalCounts = {};

        function assignReveal(srcWord, srcOcc, tgtWord, tgtOcc) {
          const idx = hiddenEntries.findIndex(e => e.word === srcWord && e.occ === srcOcc);
          if (idx === -1) return;
          hiddenEntries[idx].reveal = true;
          hiddenEntries[idx].trigger = { word: tgtWord, occ: tgtOcc };
          sec.hidden = hiddenEntries;
          saveData();
          previewSection();
        }

        function buildWordSpan(tok, w, occ, entry) {
          const isHidden = !!entry;
          const isReveal = entry && entry.reveal;
          const span = document.createElement('span');
          span.className = 'word' + (isHidden ? ' hidden' : '') + (isReveal ? ' reveal' : '');
          span.textContent = isHidden ? '_'.repeat(tok.length) : tok;
          span.dataset.word = w;
          span.dataset.occ = occ;
          span.onclick = () => handleWordClick(w, occ);
          if (isReveal) {
            span.draggable = true;
            span.addEventListener('dragstart', e => {
              e.dataTransfer.setData('text/plain', JSON.stringify({ word: w, occ }));
            });
          } else if (isHidden) {
            span.addEventListener('dragover', e => e.preventDefault());
            span.addEventListener('drop', e => {
              e.preventDefault();
              try {
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                assignReveal(data.word, data.occ, w, occ);
              } catch {}
            });
          }
          return span;
        }

        tempDiv.childNodes.forEach(node => {
          if (node.nodeType === Node.TEXT_NODE) {
            // Render text node tokens
            const tokens = node.textContent.split(/(\s+)/);
            tokens.forEach(tok => {
              if (!tok.trim()) {
                previewDiv.appendChild(document.createTextNode(tok));
              } else {
                const w = tok.trim();
                globalCounts[w] = (globalCounts[w] || 0) + 1;
                const occ = globalCounts[w];
                const entry = hiddenEntries.find(e => e.word === w && e.occ === occ);
                const span = buildWordSpan(tok, w, occ, entry);
                previewDiv.appendChild(span);
              }
            });
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.classList && node.classList.contains('popup-word')) {
              const wrapper = document.createElement('span');
              wrapper.className = 'popup-word';
              if (node.dataset.img) wrapper.dataset.img = node.dataset.img;
              const tokens = (node.innerText || '').split(/(\s+)/);
              tokens.forEach(tok => {
                if (!tok.trim()) {
                  wrapper.appendChild(document.createTextNode(tok));
                } else {
                  const w = tok.trim();
                  globalCounts[w] = (globalCounts[w] || 0) + 1;
                  const occ = globalCounts[w];
                  const entry = hiddenEntries.find(e => e.word === w && e.occ === occ);
                  const wSpan = buildWordSpan(tok, w, occ, entry);
                  wrapper.appendChild(wSpan);
                }
              });
              previewDiv.appendChild(wrapper);
            } else if (node.tagName === 'UL') {
              // Flatten each list item into its own preview line with a bullet
              node.childNodes.forEach(liNode => {
                if (liNode.nodeType !== Node.ELEMENT_NODE || liNode.tagName !== 'LI') return;

                const line = document.createElement('p');
                line.className = 'preview-line';

                // Actual bullet character
                const bulletSpan = document.createElement('span');
                bulletSpan.textContent = '• ';
                line.appendChild(bulletSpan);

                const liTokens = (liNode.innerText || '').split(/(\s+)/);
                liTokens.forEach(tok => {
                  if (!tok.trim()) {
                    line.appendChild(document.createTextNode(tok));
                  } else {
                    const w = tok.trim();
                    globalCounts[w] = (globalCounts[w] || 0) + 1;
                    const occ = globalCounts[w];
                    const entry = hiddenEntries.find(e => e.word === w && e.occ === occ);
                    const span = buildWordSpan(tok, w, occ, entry);
                    line.appendChild(span);
                  }
                });

                previewDiv.appendChild(line);
              });
            } else if (node.tagName === 'P' || node.tagName === 'DIV') {
              const para = document.createElement('p');
              para.className = 'preview-line';
              node.childNodes.forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                  // Render tokens in text node
                  const tokens = child.textContent.split(/(\s+)/);
                  tokens.forEach(tok => {
                    if (!tok.trim()) {
                      para.appendChild(document.createTextNode(tok));
                    } else {
                      const w = tok.trim();
                      globalCounts[w] = (globalCounts[w] || 0) + 1;
                      const occ = globalCounts[w];
                      const entry = hiddenEntries.find(e => e.word === w && e.occ === occ);
                      const span = buildWordSpan(tok, w, occ, entry);
                      para.appendChild(span);
                    }
                  });
                } else if (child.nodeType === Node.ELEMENT_NODE && child.classList && child.classList.contains('popup-word')) {
                  const wrapper = document.createElement('span');
                  wrapper.className = 'popup-word';
                  if (child.dataset.img) wrapper.dataset.img = child.dataset.img;
                  const tokens = (child.innerText || '').split(/(\s+)/);
                  tokens.forEach(tok => {
                    if (!tok.trim()) {
                      wrapper.appendChild(document.createTextNode(tok));
                    } else {
                      const w = tok.trim();
                      globalCounts[w] = (globalCounts[w] || 0) + 1;
                      const occ = globalCounts[w];
                      const entry = hiddenEntries.find(e => e.word === w && e.occ === occ);
                      const wSpan = buildWordSpan(tok, w, occ, entry);
                      wrapper.appendChild(wSpan);
                    }
                  });
                  para.appendChild(wrapper);
                } else if (child.nodeType === Node.ELEMENT_NODE && child.tagName === 'BR') {
                  para.appendChild(document.createElement('br'));
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                  // For inline elements: render as text
                  const tokens = (child.innerText||'').split(/(\s+)/);
                  tokens.forEach(tok => {
                    if (!tok.trim()) {
                      para.appendChild(document.createTextNode(tok));
                    } else {
                      const w = tok.trim();
                      globalCounts[w] = (globalCounts[w] || 0) + 1;
                      const occ = globalCounts[w];
                      const entry = hiddenEntries.find(e => e.word === w && e.occ === occ);
                      const span = buildWordSpan(tok, w, occ, entry);
                      para.appendChild(span);
                    }
                  });
                }
              });
              previewDiv.appendChild(para);
              // Do not add <br> after each block, as spacing is handled by .preview-line
            } else if (node.tagName === 'BR') {
              previewDiv.appendChild(document.createElement('br'));
            }
          }
        });

        enhanceQuestionSections(previewDiv);

        // Build alternate-answer inputs for hidden words
        altContainer.innerHTML = '<h4>Alternate answers for blanks (comma-separated):</h4>';
        altContainer.style.display = 'block';
        const sortedAlts = hiddenEntries.slice().sort((a,b)=>{
          const wComp = a.word.localeCompare(b.word);
          if (wComp !== 0) return wComp;
          return a.occ - b.occ;
        });
        let altCounts = {};
        sortedAlts.forEach(({ word, occ }) => {
          altCounts[word] = (altCounts[word] || 0) + 1;
          if (altCounts[word] === occ) {
            const key = `${word}_${occ}`;
            const label = document.createElement('label');
            label.textContent = `${word} #${occ}: `;
            const ai = document.createElement('input');
            ai.className = 'alt-input';
            ai.placeholder = 'alt1, alt2, …';
            ai.value = (sec.alts[key] || []).join(', ');
            ai.oninput = () => {
              sec.alts[key] = ai.value.split(',').map(s => s.trim()).filter(Boolean);
              saveData();
            };
            altContainer.appendChild(label);
            altContainer.appendChild(ai);
            altContainer.appendChild(document.createElement('br'));
          }
        });
        if (editorArea) editorArea.scrollTop = editorScrollTop;
        window.scrollTo(0, pageScrollTop);
      }

      // —— Helper: build preview & alternate‑answer UI for a single definition ——
      function buildDefinitionPreview(defObj, previewDiv, altDiv) {
        const editorScrollTop = editorArea ? editorArea.scrollTop : 0;
        const pageScrollTop = window.scrollY || document.documentElement.scrollTop || 0;
        const tokens = (defObj.rawText || '').split(/(\s+)/);
        defObj.hidden = defObj.hidden || [];
        defObj.alts   = defObj.alts   || {};

        const hiddenEntries = getHiddenEntries(defObj, tokens);
        previewDiv.innerHTML = '';
        altDiv.innerHTML     = '<h4>Alternate answers (comma-separated):</h4>';
        document.body.classList.remove('linking');

        // clickable words
        let counts = {};
        tokens.forEach(tok => {
          if (!tok.trim()) {
            // Preserve newlines
            if (tok.includes('\n')) {
              const lines = tok.split('\n');
              lines.forEach((ln, idx) => {
                if (ln) previewDiv.appendChild(document.createTextNode(ln));
                if (idx < lines.length - 1) previewDiv.appendChild(document.createElement('br'));
              });
            } else {
              previewDiv.appendChild(document.createTextNode(tok));
            }
            return;
          }
          const w = tok.trim();
          counts[w] = (counts[w] || 0) + 1;
          const occ = counts[w];
          const entry = hiddenEntries.find(e => e.word === w && e.occ === occ);
          const isHidden = !!entry;
          const isReveal = entry && entry.reveal;
          const span = document.createElement('span');
          span.className = 'word' + (isHidden ? ' hidden' : '') + (isReveal ? ' reveal' : '');
          span.textContent = isHidden ? '_'.repeat(tok.length) : tok;
          span.onclick = () => {
            const idx = hiddenEntries.findIndex(e => e.word === w && e.occ === occ);
            if (idx === -1) hiddenEntries.push({ word: w, occ });
            else if (!hiddenEntries[idx].reveal) hiddenEntries[idx].reveal = true;
            else hiddenEntries.splice(idx, 1);
            defObj.hidden = hiddenEntries;
            saveData();
            buildDefinitionPreview(defObj, previewDiv, altDiv);
          };
          previewDiv.appendChild(span);
        });

        // alternate‑answer inputs
        counts = {};
        tokens.forEach(tok => {
          if (!tok.trim()) return;
          const w = tok.trim();
          counts[w] = (counts[w] || 0) + 1;
          const occ = counts[w];
          const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);
          if (!isHidden) return;

          const key = `${w}_${occ}`;
          const label = document.createElement('label');
          label.textContent = `${w} #${occ}: `;
          const ai = document.createElement('input');
          ai.className  = 'alt-input';
          ai.placeholder = 'alt1, alt2 …';
          ai.value      = (defObj.alts[key] || []).join(', ');
          ai.oninput = () => {
            defObj.alts[key] = ai.value.split(',').map(s => s.trim()).filter(Boolean);
            saveData();
          };
          altDiv.appendChild(label);
          altDiv.appendChild(ai);
          altDiv.appendChild(document.createElement('br'));
        });
        if (editorArea) editorArea.scrollTop = editorScrollTop;
        window.scrollTo(0, pageScrollTop);
      }
      editModeBtn.onclick = () => {
        isQuizMode = false;
        enterEdit();
        // Reload the current section in edit mode if one is selected
        if (currentSection !== null) {
          loadSection();
          previewSection();
        }
      };

      function enterEdit(){
        stopSpeech({ clearStart: true });
        editorArea.style.display = 'block';
        quizArea.style.display = 'none';
        altContainer.style.display = 'none';
        altContainer.innerHTML = '';
        renderSections(lastSectionOrder);
        updateProgressIndicator();
        updateResumeQuizBtn();
      }
      function enterQuiz(){
        stopSpeech({ clearStart: true });
          if(!isQuizMode) syncCurrentSection();
        multiFolderMode = false;
        resetAnswerBank();
        if (currentFolder === null) {
          alert('Select a folder first');
          return;
        }
        editorArea.style.display = 'none';
        quizArea.style.display = 'block';
        startQuiz();
        updateProgressIndicator();
      }

      // Starts a random-order quiz across all sections in the current folder
      function enterRandomQuiz() {
        stopSpeech({ clearStart: true });
          if(!isQuizMode) syncCurrentSection();
        multiFolderMode = false;
        resetAnswerBank();
        isQuizMode = true;
        if (currentFolder === null) {
          alert('Select a folder first');
          return;
        }
        editorArea.style.display = 'none';
        quizArea.style.display = 'block';
        const total = data.folders[currentFolder].sections.length;
        let prog = quizProgress[currentFolder];
        if (!prog) {
          prog = quizProgress[currentFolder] = { completed: new Set(), total, order: null, pos: 0 };
        } else {
          prog.total = total;
        }

        if (prog.order && prog.order.length && prog.pos < prog.order.length) {
          quizOrder = prog.order;
          quizPos   = prog.pos;
        } else {
          const done = prog.completed;
          const order = data.folders[currentFolder].sections
            .map((_, i) => i)
            .filter(i => !done.has(i))
            .sort(() => Math.random() - 0.5);
          if (order.length === 0) {
            alert('All questions in this section already complete!');
            updateProgressIndicator();
            return;
          }
          prog.order = order;
          prog.pos   = 0;
          quizOrder   = order;
          quizPos     = 0;
        }
        saveProgress();

        updateProgressIndicator();
        showQuiz();
      }

      function enterQuizQuestion(){
        stopSpeech({ clearStart: true });
        multiFolderMode = false;
        resetAnswerBank();
        if(!ensureSelection()) return;
        editorArea.style.display='none';
        quizArea.style.display='block';
        quizOrder = [currentSection];
        quizPos = 0;
        updateProgressIndicator();
        showQuiz();
      }
      quizModeBtn.onclick = () => {
        if(!isQuizMode){
          syncCurrentSection();
          if (typeof quill !== 'undefined') quill.blur();
        }
        isQuizMode = true;
        // Show quiz for the currently selected section
        if (currentSection !== null) {
          enterQuizQuestion();
        } else {
          enterQuiz();
        }
      };
      quizAllBtn.onclick = () => {
        if(!isQuizMode){
          syncCurrentSection();
          if (typeof quill !== 'undefined') quill.blur();
        }
        enterRandomQuiz();
      };

      toggleAnswersBtn.onclick = () => {
        answersVisible = !answersVisible;
        const sec = (currentFolder !== null && currentSection !== null && data.folders[currentFolder])
          ? data.folders[currentFolder].sections[currentSection]
          : null;
        refreshAnswersToggle(sec);
      };

      function enhanceQuestionSections(container, options = {}) {
        if (!container) return;
        const { skipTitle = false } = options;
        container.classList.remove('has-section-cards');

        const detectSectionKeyword = text => {
          if (!text) return '';
          const normalized = text
            .toLowerCase()
            .replace(/^[^a-z]+/, '')
            .trim();
          const match = normalized.match(/^(what|how|why)(?=$|[^a-z])/);
          return match ? match[1] : '';
        };
        const promoteLegacyHeading = el => {
          if (!el || el === container) return;
          if (!(el.tagName === 'P' || el.tagName === 'DIV')) return;
          if (el.closest('.question-section-card')) return;
          if (!el.parentNode) return;
          const rawText = (el.textContent || '').trim();
          if (!rawText) return;
          const keyword = detectSectionKeyword(rawText);
          if (!keyword) return;
          const heading = document.createElement('h3');
          let sourceHTML = el.innerHTML;
          if (
            el.tagName === 'DIV' &&
            el.children.length === 1 &&
            el.children[0].tagName === 'P'
          ) {
            sourceHTML = el.children[0].innerHTML;
          }
          heading.innerHTML = sourceHTML;
          if (el.id) heading.id = el.id;
          if (el.className) heading.className = el.className;
          Array.from(el.attributes).forEach(attr => {
            if (attr.name.startsWith('data-')) {
              heading.setAttribute(attr.name, attr.value);
            }
          });
          heading.dataset.sectionKeyword = keyword;
          el.parentNode.replaceChild(heading, el);
        };
        Array.from(container.querySelectorAll('p, div')).forEach(promoteLegacyHeading);

        const headings = Array.from(container.querySelectorAll('h3'));
        if (!headings.length) return;

        let processed = 0;
        const createdCards = [];
        headings.forEach(heading => {
          if (skipTitle && heading.classList.contains('quiz-question-title')) return;
          if (heading.closest('.question-section-card')) return;
          const originalParent = heading.parentNode;
          if (!originalParent) return;

          processed += 1;
          const card = document.createElement('div');
          card.className = 'question-section-card';
          card.style.setProperty('--section-index', processed);

          const header = document.createElement('div');
          header.className = 'question-section-header';

          const badge = document.createElement('span');
          badge.className = 'question-section-badge';
          badge.setAttribute('data-tts-skip', 'true');
          const badgeText = processed < 10 ? `0${processed}` : String(processed);
          badge.textContent = badgeText;
          badge.setAttribute('aria-label', `Section ${processed}`);

          const body = document.createElement('div');
          body.className = 'question-section-body';

          card.appendChild(header);
          card.appendChild(body);
          header.appendChild(badge);
          heading.classList.add('question-section-heading');
          originalParent.insertBefore(card, heading);
          header.appendChild(heading);

          const keyword = heading.dataset.sectionKeyword || detectSectionKeyword(heading.textContent || '');
          if (keyword) {
            heading.dataset.sectionKeyword = keyword;
            const headingText = (heading.textContent || '').trim().toLowerCase();
            if (headingText === keyword) {
              heading.setAttribute('data-tts-skip', 'true');
            }
          }
          if (['what', 'how', 'why'].includes(keyword)) {
            card.classList.add('whw-section', `whw-${keyword}`);
            heading.classList.add('whw-heading');
          }

          let sibling = card.nextSibling;
          while (sibling) {
            if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === 'H3') {
              if (skipTitle && sibling.classList.contains('quiz-question-title')) {
                sibling = sibling.nextSibling;
                continue;
              }
              break;
            }
            const next = sibling.nextSibling;
            body.appendChild(sibling);
            sibling = next;
          }

          const trimEdges = target => {
            while (target.firstChild && target.firstChild.nodeType === Node.TEXT_NODE && !target.firstChild.textContent.trim()) {
              target.removeChild(target.firstChild);
            }
            while (target.lastChild && target.lastChild.nodeType === Node.TEXT_NODE && !target.lastChild.textContent.trim()) {
              target.removeChild(target.lastChild);
            }
          };
          trimEdges(body);

          const hasContent = Array.from(body.childNodes).some(node => {
            if (node.nodeType === Node.TEXT_NODE) return node.textContent.trim().length > 0;
            if (node.nodeType === Node.ELEMENT_NODE) {
              if (node.tagName === 'BR') return false;
              if (node.classList && (node.classList.contains('blank') || node.classList.contains('hidden-reveal'))) return true;
              return node.textContent.trim().length > 0;
            }
            return false;
          });
          if (!hasContent) body.classList.add('empty');

          const cleanWhitespace = node => {
            Array.from(node.childNodes).forEach(child => {
              if (child.nodeType === Node.TEXT_NODE && !child.textContent.trim()) {
                node.removeChild(child);
              }
            });
          };

          let currentParent = card.parentNode;
          while (currentParent && currentParent !== container && currentParent.parentNode) {
            cleanWhitespace(currentParent);
            if (currentParent.childNodes.length === 1 && currentParent.firstChild === card) {
              const host = currentParent.parentNode;
              host.insertBefore(card, currentParent);
              currentParent.remove();
              currentParent = card.parentNode;
            } else {
              break;
            }
          }

          createdCards.push(card);
        });

        if (!createdCards.length) return;

        container.classList.add('has-section-cards');
        requestAnimationFrame(() => {
          createdCards.forEach((card, idx) => {
            const order = idx + 1;
            card.style.setProperty('--section-index', order);
            const badge = card.querySelector('.question-section-badge');
            if (badge) {
              const label = order < 10 ? `0${order}` : String(order);
              badge.textContent = label;
              badge.setAttribute('aria-label', `Section ${order}`);
            }
          });
        });
      }

      function wrapQuizBlanks(container, hiddenEntries) {
        const sec = data.folders[currentFolder].sections[currentSection];

        // Validate hidden entries against token counts
        const tokens = extractTokens(sec).map(t => t.trim()).filter(Boolean);
        const valid = (hiddenEntries || []).filter(({ word, occ }) => {
          const matches = tokens.filter(t => t === word);
          const ok = occ <= matches.length;
          if (!ok && sec.alts) delete sec.alts[`${word}_${occ}`];
          return ok;
        });
        sec.hidden = valid;

        const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
        const textNodes = [];
        while (walker.nextNode()) {
          const n = walker.currentNode;
          if (!n.parentElement.closest('.quiz-title-word') && !n.parentElement.closest('.hidden-reveal')) textNodes.push(n);
        }

        const tokenNodes = [];
        textNodes.forEach(node => {
          const parts = node.textContent.split(/(\s+)/);
          let ref = node;
          ref.textContent = parts[0];
          tokenNodes.push({ node: ref, text: parts[0] });
          for (let i = 1; i < parts.length; i++) {
            const newNode = document.createTextNode(parts[i]);
            ref.parentNode.insertBefore(newNode, ref.nextSibling);
            ref = newNode;
            tokenNodes.push({ node: ref, text: parts[i] });
          }
        });

        const counts = {};
        const replacements = [];
        tokenNodes.forEach(({ node, text }) => {
          const w = text.trim();
          if (!w) return;
          counts[w] = (counts[w] || 0) + 1;
          const occ = counts[w];
          const entry = valid.find(e => e.word === w && e.occ === occ);
          if (entry) {
            replacements.push({ node, word: w, occ, reveal: entry.reveal, trigger: entry.trigger });
          }
        });

        replacements.forEach(({ node, word, occ, reveal, trigger }) => {
          if (reveal && trigger) {
            const span = document.createElement('span');
            span.className = 'hidden-reveal reveal-target';
            span.textContent = word;
            span.dataset.triggerWord = trigger.word;
            span.dataset.triggerOcc = trigger.occ;
            node.parentNode.replaceChild(span, node);
          } else if (reveal) {
            const span = document.createElement('span');
            span.className = 'hidden-reveal reveal-only';
            span.textContent = word;
            node.parentNode.replaceChild(span, node);
          } else {
            const span = document.createElement('span');
            span.className = 'blank';
            span.dataset.word = word;
            span.dataset.occ = occ;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'blank-input';
            const answers = [word, ...(sec.alts[`${word}_${occ}`] || [])];
            input.setAttribute('data-answer', JSON.stringify(answers));
            input.addEventListener('focus', () => {
              lastHintTarget = input;
              activeBlankInput = input;
              if (document.body.classList.contains('mobile')) {
                const card = input.closest('.question-section-card');
                if (card) moveAnswerControlsBelowCard(card);
              }
            });
            span.addEventListener('dragover', e => e.preventDefault());
            span.addEventListener('drop', e => {
              e.preventDefault();
              const txt = e.dataTransfer.getData('text/plain');
              if (txt) {
                const shouldFocus = !document.body.classList.contains('mobile');
                applyAnswerToInput(input, txt, { focus: shouldFocus, clearOnWrong: true });
              }
            });
            input.addEventListener('dragover', e => e.preventDefault());
            input.addEventListener('drop', e => {
              e.preventDefault();
              const txt = e.dataTransfer.getData('text/plain');
              if (txt) {
                const shouldFocus = !document.body.classList.contains('mobile');
                applyAnswerToInput(input, txt, { focus: shouldFocus, clearOnWrong: true });
              }
            });

            span.appendChild(input);
            node.parentNode.replaceChild(span, node);
      }
    });
  }

      function sanitizeBlankList(blanks) {
        return Array.from(blanks || []).filter(inp =>
          inp && inp.isConnected && inp.classList && inp.classList.contains('blank-input')
        );
      }

      function gatherRelatedBlanks(input) {
        if (!input || !input.isConnected) return [];
        const para = input.closest('p');
        if (para && Array.isArray(para._inputs)) {
          return sanitizeBlankList(para._inputs);
        }
        let node = input.closest('.blank');
        node = node ? node.parentElement : input.parentElement;
        while (node && node !== quizContent) {
          const blanks = sanitizeBlankList(node.querySelectorAll('input.blank-input'));
          if (blanks.length > 1) return blanks;
          node = node.parentElement;
        }
        return sanitizeBlankList([input]);
      }

      function selectFirstAvailableBlank(blanks) {
        const clean = sanitizeBlankList(blanks);
        if (!clean.length) return null;
        const empty = clean.find(inp => !(inp.value || '').trim());
        if (empty) return empty;
        const incorrect = clean.find(inp => !inp.classList.contains('correct'));
        if (incorrect) return incorrect;
        return null;
      }

      function blankNeedsAnswer(input) {
        if (!input || !input.isConnected) return false;
        const val = (input.value || '').trim();
        return !val || !input.classList.contains('correct');
      }

      function findPreferredBlankTarget() {
        const active = document.activeElement;
        if (active && active.classList && active.classList.contains('blank-input') && blankNeedsAnswer(active)) {
          return active;
        }
        if (activeBlankInput) {
          if (activeBlankInput.isConnected) {
            if (blankNeedsAnswer(activeBlankInput)) {
              return activeBlankInput;
            }
            const grouped = gatherRelatedBlanks(activeBlankInput).filter(inp => inp !== activeBlankInput);
            const candidate = selectFirstAvailableBlank(grouped);
            if (candidate) return candidate;
          } else {
            activeBlankInput = null;
          }
        }
        return selectFirstAvailableBlank(document.querySelectorAll('#quizContent input.blank-input'));
      }

      function cancelWrongAnswerTimer(input) {
        if (!input) return;
        const existing = wrongAnswerTimers.get(input);
        if (existing) {
          clearTimeout(existing);
          wrongAnswerTimers.delete(input);
        }
        if (input.dataset) {
          delete input.dataset.autoClearValue;
        }
      }

      function flashFilledInput(input) {
        if (!input) return;
        input.classList.remove('bank-flash');
        // Force reflow so the animation restarts even for the same element
        void input.offsetWidth;
        input.classList.add('bank-flash');
        input.addEventListener('animationend', () => {
          input.classList.remove('bank-flash');
        }, { once: true });
      }

      function applyAnswerToInput(input, value, { focus = true, clearOnWrong = false } = {}) {
        if (!input || !input.isConnected) return;
        lastHintTarget = input;
        activeBlankInput = input;
        cancelWrongAnswerTimer(input);

        if (focus) {
          try {
            input.focus({ preventScroll: true });
          } catch (err) {
            input.focus();
          }
        }

        input.value = value;
        input.dispatchEvent(new Event('input'));

        if (!focus && document.activeElement === input) {
          input.blur();
        }

        flashFilledInput(input);

        if (clearOnWrong) {
          const trimmed = (input.value || '').trim();
          if (trimmed && input.classList.contains('incorrect')) {
            if (input.dataset) {
              input.dataset.autoClearValue = trimmed;
            }
            const timer = setTimeout(() => {
              if (!input.isConnected) return;
              const current = (input.value || '').trim();
              const shouldClear = input.classList.contains('incorrect') && (!input.dataset || input.dataset.autoClearValue === current);
              if (shouldClear) {
                input.value = '';
                input.dispatchEvent(new Event('input'));
              }
              wrongAnswerTimers.delete(input);
              if (input.dataset) {
                delete input.dataset.autoClearValue;
              }
            }, 1000);
            wrongAnswerTimers.set(input, timer);
          }
        }
      }

      function buildAnswerBank(sec) {
        if (!answerBank) return;
        const answers = [];
        quizContent.querySelectorAll('.blank-input').forEach(input => {
          try {
            const arr = JSON.parse(input.getAttribute('data-answer') || '[]');
            if (arr.length) answers.push(arr[0]);
          } catch {}
        });
        answers.sort(() => Math.random() - 0.5);
        answerBank.innerHTML = '';
        const isMobile = document.body.classList.contains('mobile');
        answers.forEach(ans => {
          const span = document.createElement('span');
          span.className = 'answer-label';
          span.textContent = ans;
          span.dataset.skipNextClick = 'false';
          span.draggable = !isMobile;
          span.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', ans);
          });
          span.addEventListener('click', () => {
            if (span.dataset.skipNextClick === 'true') {
              span.dataset.skipNextClick = 'false';
              return;
            }
            const target = findPreferredBlankTarget();
            if (!target) return;
            const shouldFocus = !document.body.classList.contains('mobile');
            applyAnswerToInput(target, ans, { focus: shouldFocus, clearOnWrong: true });
          });
          span.addEventListener('touchstart', e => {
            if (e.touches.length !== 1) return;
            const t = e.touches[0];
            if (touchDrag && touchDrag.ghost) {
              touchDrag.ghost.remove();
            }
            touchDrag = {
              text: ans,
              source: span,
              startX: t.clientX,
              startY: t.clientY,
              ghost: null,
              offsetX: 0,
              offsetY: 0,
              didDrag: false
            };
          });
          answerBank.appendChild(span);
        });
      }

      function refreshAnswersToggle(sec) {
        if (!toggleAnswersBtn || !answerBank || !quizContent) return;
        const blankCount = quizContent.querySelectorAll('input.blank-input').length;
        if (!blankCount) {
          toggleAnswersBtn.style.display = 'none';
          answerBank.style.display = 'none';
          answerBank.innerHTML = '';
          toggleAnswersBtn.textContent = 'Show Answers';
          return;
        }
        toggleAnswersBtn.style.display = 'inline-block';
        if (answersVisible) {
          buildAnswerBank(sec);
          answerBank.style.display = 'block';
          toggleAnswersBtn.textContent = 'Hide Answers';
        } else {
          answerBank.style.display = 'none';
          answerBank.innerHTML = '';
          toggleAnswersBtn.textContent = 'Show Answers';
        }
      }

        function showQuiz() {
          justCompleted = false;
          activeBlankInput = null;
          stopSpeech();
          clearTtsStartElement();
          // Advance to the correct section and folder
          let entry = quizOrder[quizPos];
          if (typeof entry === 'object') {
            currentFolder = entry.folder;
            currentSection = entry.section;
          } else {
            currentSection = entry;
          }
          if (!multiFolderMode) {
            const prog = quizProgress[currentFolder];
            if (prog && quizOrder.length > 1) {
              prog.pos = quizPos;
              saveProgress();
            }
          }
        // Now load that section’s data
        let sec = data.folders[currentFolder].sections[currentSection];
        ensureSectionImages(currentFolder, sec);
        if (!sec.rawHtml && sec.rawText) {
          sec.rawHtml = sec.rawText.split('\n').map(line => `<p>${line}</p>`).join('');
          saveData();
        }
        if (document.body.classList.contains('mobile')) {
          editQuestionBtn.style.display = 'inline-block';
        } else {
          editQuestionBtn.style.display = 'none';
        }
        updateProgressIndicator();
        // Insert consistent title at top of quizContent
        const titleText = sec.title?.trim() || sec.acronym || (sec.rawText?.split('\n')[0].trim()) || '(untitled)';
        const titleElem = document.createElement('h3');
        titleElem.className = 'quiz-question-title';
        titleElem.innerHTML = titleText
          .split(/\s+/)
          .map(w => `<span class="quiz-title-word">${w}</span>`)
          .join(' ');
        quizContent.innerHTML = '';
        quizContent.style.borderColor = '';
        quizContent.appendChild(titleElem);
        
        // Highlight current section in left panel
        renderSections(lastSectionOrder);

        updateHeader(titleText);
        answerBank.innerHTML = '';
        answerBank.style.display = 'none';
        toggleAnswersBtn.style.display = 'none';
        resetAnswerControlsPosition();

        if (sec.type === 'fill') {
          // quizContent already cleared and title appended above
          // Now append the fill content
          quizContent.innerHTML = '';
          quizContent.appendChild(titleElem);
          quizContent.innerHTML += sec.rawHtml || sec.rawText || '';
          const tokensArr = extractTokens(sec);
          const hiddenEntries = getHiddenEntries(sec, tokensArr);
          wrapQuizBlanks(quizContent, hiddenEntries);
          enhanceQuestionSections(quizContent, { skipTitle: true });
          setupMobileAnswerBankHandlers();
          // --- Improved blank sizing using text width measurement ---
          // Create a hidden span for measuring text width
          const measure = document.createElement('span');
          Object.assign(measure.style, {
            position: 'absolute',
            visibility: 'hidden',
            whiteSpace: 'pre',
            left: '-9999px',
            top: '-9999px',
          });
          document.body.appendChild(measure);
          quizContent.querySelectorAll('.blank').forEach(wrapper => {
            const input = wrapper.querySelector('input');
            const word = wrapper.dataset.word || '';
            // Ensure measure span uses the same font metrics
            const computeFont = () => {
              measure.style.font = window.getComputedStyle(input).font;
            };
            computeFont();
            // Function to resize input based on value
            const resize = val => {
              measure.textContent = val;
              const extra = 6; // slight padding so the box isn't too tight
              input.style.width = (measure.getBoundingClientRect().width + extra) + 'px';
            };
            // Initial sizing
            resize(word);
            // Resize on each keystroke
            input.addEventListener('input', () => {
              computeFont();
              resize(input.value || wrapper.dataset.word);
            });
          });
          // Attach grading and navigation to all blanks
          quizContent.querySelectorAll('.blank input').forEach(input => {
            input.addEventListener('input', () => {
              const wrapper      = input.parentElement;
              const enteredRaw   = input.value.trim();
              const correctWord  = wrapper.dataset.word;
              const occ          = wrapper.dataset.occ;
              const section      = data.folders[currentFolder].sections[currentSection];
              const altKey       = `${correctWord}_${occ}`;
              const alts         = section.alts[altKey] || [];

              const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/g, '');
              const enteredNorm = normalize(enteredRaw);
              const correctNorm = normalize(correctWord);
              const isCorrect   = enteredNorm === correctNorm ||
                                  alts.some(a => normalize(a) === enteredNorm);
              const revealTargets = quizContent.querySelectorAll(`.hidden-reveal.reveal-target[data-trigger-word="${correctWord}"][data-trigger-occ="${occ}"]`);

              if (enteredRaw.length === 0) {
                input.classList.remove('correct', 'incorrect');
                revealTargets.forEach(s => s.style.display = 'none');
                cancelWrongAnswerTimer(input);
              } else if (isCorrect) {
                input.classList.add('correct');
                input.classList.remove('incorrect');
                revealTargets.forEach(s => s.style.display = 'inline');
                cancelWrongAnswerTimer(input);
              } else {
                input.classList.add('incorrect');
                input.classList.remove('correct');
                revealTargets.forEach(s => s.style.display = 'none');
                if (input.dataset && input.dataset.autoClearValue && input.dataset.autoClearValue !== enteredRaw) {
                  cancelWrongAnswerTimer(input);
                }
              }

              const allInputs = Array.from(quizContent.querySelectorAll('.blank input'));
              if (allInputs.length && allInputs.every(i => i.classList.contains('correct'))) {
                quizContent.style.borderColor = '#27ae60';
                markQuestionCompleted();
                quizContent.querySelectorAll('.hidden-reveal.reveal-only').forEach(s => s.style.display = 'inline');
              } else {
                quizContent.style.borderColor = '';
                quizContent.querySelectorAll('.hidden-reveal.reveal-only').forEach(s => s.style.display = 'none');
              }
            });

            input.addEventListener('keydown', e => {
              const inputs = Array.from(quizContent.querySelectorAll('.blank input'));
              const idx = inputs.indexOf(input);
              if (e.key === ' ') {
                e.preventDefault();
                if (input.classList.contains('correct') && idx < inputs.length - 1) {
                  inputs[idx + 1].focus();
                }
              }
              if (e.key === 'Backspace' && input.selectionStart === 0 && input.selectionEnd === 0 && input.value === '' && idx > 0) {
                e.preventDefault();
                const prev = inputs[idx - 1];
                prev.focus();
                const len = prev.value.length;
                prev.setSelectionRange(len, len);
              }
            });
          });
          refreshAnswersToggle(sec);
          return;
        }
        if (sec.type === 'acronym') {
          quizContent.innerHTML = '';
          quizContent.appendChild(titleElem);
          quizContent.innerHTML += '<h4 style="font-size:1.5rem; margin-bottom:0.75rem;">' + sec.acronym + '</h4>';
          // Compute uniform widths for acronym inputs based on base and longest answer/extra
          const baseCh = 12;
          const answerLengths = sec.entries.map(e => (e.answer||'').length + 2);
          const maxAnswerCh = Math.max(baseCh, ...answerLengths);
          const extraLengths = sec.entries.map(e => (e.extra||'').length + 2);
          const maxExtraCh = Math.max(baseCh, ...extraLengths);
          sec.entries.forEach((e, i) => {
            const div = document.createElement('div');
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.margin = '4px 0';
            // Build inputs array
            let html = `<strong style="display:inline-block; width:1.5em; text-align:center; margin-right:0.75em; font-size:1.2rem; line-height:1.2;">${e.letter}:</strong>
              <input type="text" placeholder="Answer" id="qans${i}" style="padding:4px; font-size:1.2rem; line-height:1.2;">`;
            if (e.extra && e.extra.trim()) {
              html += `<input type="text" placeholder="Extra info" id="qext${i}" style="margin-left:8px; padding:4px; font-size:1.2rem; line-height:1.2;">`;
            }
            div.innerHTML = html;
            quizContent.appendChild(div);
            const inp = document.getElementById('qans' + i);
            inp.style.width = maxAnswerCh + 'ch';
            inp.oninput = () => {
              const ok = inp.value.trim().toLowerCase() === e.answer.trim().toLowerCase();
              inp.classList.toggle('correct', ok);
              inp.classList.toggle('incorrect', !ok);
            };
            let extInp = null;
            if (e.extra && e.extra.trim()) {
              extInp = document.getElementById('qext' + i);
              extInp.style.width = maxExtraCh + 'ch';
              extInp.oninput = () => {
                const okX = extInp.value.trim().toLowerCase() === e.extra.trim().toLowerCase();
                extInp.classList.toggle('correct', okX);
                extInp.classList.toggle('incorrect', !okX);
              };
            }
          });
          return;
        }
        if (sec.type === 'label') {
          quizContent.innerHTML = '';
          quizContent.appendChild(titleElem);
          const wrapper = document.createElement('div');
          wrapper.style.position = 'relative';
          wrapper.style.maxWidth = '100%';
          wrapper.style.display = 'inline-block';
          const img = document.createElement('img');
          img.className = 'main-image';
          const base = sec.image || '';
          img.src = base;
          if (sec.imageRef) {
            applyImageRef(img, sec.imageRef);
          }
          wrapper.appendChild(img);
          let baseWidth = 0, baseHeight = 0;
          img.onload = () => {
            baseWidth = sec.imgWidth || img.naturalWidth;
            baseHeight = sec.imgHeight || img.naturalHeight;
            if (!isMobileDevice()) {
              wrapper.style.width = baseWidth + 'px';
              img.style.width = '100%';
              img.style.height = 'auto';
            } else {
              wrapper.style.width = '100%';
              img.style.width = '100%';
              img.style.height = 'auto';
            }
            svgOverlay.setAttribute('viewBox', `0 0 ${baseWidth} ${baseHeight}`);
            positionExtras(wrapper);
            scaleLabels(wrapper, baseWidth, baseHeight);
            if (sec.extraImages) {
              const wraps = Array.from(wrapper.querySelectorAll('div.extra-wrapper'));
              wraps.forEach((w, idx) => {
                const ex = sec.extraImages[idx];
                const exImg = w.querySelector('img');
                const bw = ex.imgWidth || exImg.naturalWidth;
                const bh = ex.imgHeight || exImg.naturalHeight;
                scaleLabels(w, bw, bh);
              });
            }
          };
          window.addEventListener('resize', () => {
            if (!baseWidth || !baseHeight) return;
            if (!isMobileDevice()) {
              wrapper.style.width = baseWidth + 'px';
              img.style.width = '100%';
              img.style.height = 'auto';
            } else {
              wrapper.style.width = '100%';
              img.style.width = '100%';
              img.style.height = 'auto';
            }
            scaleLabels(wrapper, baseWidth, baseHeight);
            if (sec.extraImages) {
              const wraps = Array.from(wrapper.querySelectorAll('div.extra-wrapper'));
              wraps.forEach((w, idx) => {
                const ex = sec.extraImages[idx];
                const exImg = w.querySelector('img');
                const bw = ex.imgWidth || exImg.naturalWidth;
                const bh = ex.imgHeight || exImg.naturalHeight;
                scaleLabels(w, bw, bh);
              });
            }
            positionExtras(wrapper);
          });

          // Create SVG overlay for arrows
          const svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svgOverlay.style.position = 'absolute';
          svgOverlay.style.top = '0';
          svgOverlay.style.left = '0';
          svgOverlay.style.width = '100%';
          svgOverlay.style.height = '100%';
          svgOverlay.style.pointerEvents = 'none';
          wrapper.appendChild(svgOverlay);

          // Draw saved arrows
          if (sec.arrows) {
            sec.arrows.forEach(a => {
              const angle = Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
              const arrowLength = a.width * 3;
              const arrowWidth = a.width * 2;
              // Compute line endpoint at base of arrowhead
              const lineEndX = a.x2 - arrowLength * Math.cos(angle);
              const lineEndY = a.y2 - arrowLength * Math.sin(angle);
              // Create line element
              const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              line.setAttribute('x1', a.x1);
              line.setAttribute('y1', a.y1);
              line.setAttribute('x2', lineEndX);
              line.setAttribute('y2', lineEndY);
              line.setAttribute('stroke', a.color);
              line.setAttribute('stroke-width', a.width);
              svgOverlay.appendChild(line);
              // Compute arrowhead points
              const xBase1 = a.x2 - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
              const yBase1 = a.y2 - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);
              const xBase2 = a.x2 - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
              const yBase2 = a.y2 - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
              const points = `${a.x2},${a.y2} ${xBase1},${yBase1} ${xBase2},${yBase2}`;
              const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
              polygon.setAttribute('points', points);
              polygon.setAttribute('fill', a.color);
              svgOverlay.appendChild(polygon);
            });
          }

          // Map labelText → { el: titleElement, idx }
          const titleMap = {};
          const labelInputs = {};
          let labelOrder = [];
          // Render inline inputs
          sec.labels.forEach(lbl => {
            const inp = document.createElement('input');
            inp.classList.add('blank-input');
            inp.setAttribute('data-answer', JSON.stringify([lbl.text]));
            inp.dataset.label = "1";          // mark as picture‑label blank
            inp.type = 'text';
            inp.style.position = 'absolute';
            inp.style.left = lbl.x + 'px';
            inp.style.top = lbl.y + 'px';
            // border, bg, font, etc.
            inp.style.border = '1px solid #7f8c8d';
            inp.style.background = '#ffffff';
            inp.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
            inp.style.fontSize = lbl.fontSize + 'px';
            inp.style.color = '#000';
            inp.style.padding = '0';
            inp.style.boxSizing = 'border-box';
            inp.style.minWidth = '0';
            inp.style.borderRadius = '2px';
            // record focus so Hint button targets the last‑selected box
            inp.addEventListener('focus', () => {
              lastHintTarget = inp;
              activeBlankInput = inp;
            });
            // size width/height to match the saved label size, or fallback to measured width
            const measSpan = document.createElement('span');
            measSpan.style.visibility = 'hidden';
            measSpan.style.position   = 'absolute';
            measSpan.style.whiteSpace = 'pre';
            measSpan.style.fontFamily = inp.style.fontFamily;
            measSpan.style.fontSize   = inp.style.fontSize;
            measSpan.textContent = lbl.text.toUpperCase();
            document.body.appendChild(measSpan);
            const calcW = lbl.w ? lbl.w : (measSpan.offsetWidth + 4);
            document.body.removeChild(measSpan);
            const calcH = lbl.h || inp.offsetHeight;
            inp.style.width  = calcW + 'px';
            inp.style.height = calcH + 'px';
            // ensure typed text sits nicely within the box
            inp.style.lineHeight = calcH + 'px';
            inp.dataset.origLineHeight = calcH;
            inp.dataset.origX = lbl.x;
            inp.dataset.origY = lbl.y;
            inp.dataset.origFont = lbl.fontSize;
            inp.dataset.origW = calcW;
            inp.dataset.origH = calcH;
            if (document.body.classList.contains('mobile')) {
              inp.readOnly = true;
              inp.addEventListener('click', () => {
                lastHintTarget = inp;
                activeBlankInput = inp;
                const resp = prompt('Enter answer:', inp.value);
                if (resp !== null) {
                  inp.value = resp;
                  inp.dispatchEvent(new Event('input'));
                }
              });
            }
            labelInputs[lbl.text] = inp;
            inp.oninput = () => {
              const val = inp.value.trim().toLowerCase();
              const ok = val === lbl.text.trim().toLowerCase();

              if (ok) {
                // Replace the input with the revealed label text
                const txt = document.createElement('span');
                txt.textContent = lbl.text;
                txt.style.position = 'absolute';
                txt.style.left = lbl.x + 'px';
                txt.style.top  = lbl.y + 'px';
                txt.style.fontSize   = lbl.fontSize + 'px';
                txt.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                txt.style.background = '#ffffff';
                txt.style.border     = '1px solid #27ae60';
                txt.style.padding    = '0 2px';
                txt.style.borderRadius = '2px';
                const w = parseFloat(inp.dataset.origW);
                const h = parseFloat(inp.dataset.origH);
                txt.style.width  = w + 'px';
                txt.style.height = h + 'px';
                txt.style.whiteSpace = 'nowrap';
                txt.style.overflow   = 'hidden';
                txt.style.lineHeight = h + 'px';
                txt.dataset.origLineHeight = h;
                txt.style.color = '#000';
                txt.style.pointerEvents = 'none';
                txt.dataset.origX = lbl.x;
                txt.dataset.origY = lbl.y;
                txt.dataset.origFont = lbl.fontSize;
                txt.dataset.origW = w;
                txt.dataset.origH = h;
                txt.style.display = 'inline-block';
                txt.addEventListener('contextmenu', deleteLabel);
                wrapper.appendChild(txt);
                inp.remove();               // get rid of the input box
                scaleLabels(wrapper, baseWidth, baseHeight);
                // Auto‑focus the first blank of this label's definition or next label
                let entry = titleMap[lbl.text];
                if (entry && entry.para && entry.para._inputs && entry.para._inputs.length) {
                  const nextB = entry.para._inputs.find(b => !b.classList.contains('correct'));
                  if (nextB) {
                    setTimeout(() => nextB.focus(),0);
                  } else {
                    const idx = entry.idx + 1;
                    const nextLbl = labelOrder[idx];
                    if (nextLbl) setTimeout(() => nextLbl.focus(),0);
                  }
                } else {
                  const idx = entry ? entry.idx + 1 : 0;
                  const nextLbl = labelOrder[idx];
                  if (nextLbl) setTimeout(() => nextLbl.focus(),0);
                }

                // Reveal corresponding definition title now that this label is correct
                entry = titleMap[lbl.text];
                if (entry && !entry.revealed) {
                  if (entry.numberEl) {
                    entry.numberEl.textContent = (entry.idx + 1) + '. ';
                  }
                  entry.el.textContent = lbl.text + ': ';
                  entry.revealed = true;
                  if (entry.hide) entry.para.style.display = '';
                }
              } else {
                // keep feedback colours while user is typing
                inp.classList.remove('correct');
                inp.classList.add('incorrect');
                inp.style.borderColor = '#c0392b';
              }

              // Re‑evaluate overall correctness outline
              const remainingInputs = Array.from(wrapper.querySelectorAll('input'));
              if (remainingInputs.length === 0) {
                img.style.outline = '2px solid #27ae60';
              } else {
                img.style.outline = '';
              }
            };
            const deleteLabel = evt => {
              if (!evt.metaKey) return;
              evt.preventDefault();
              evt.stopPropagation();
              if (confirm('Delete this label?')) {
                const idx = sec.labels.indexOf(lbl);
                if (idx >= 0) {
                  sec.labels.splice(idx, 1);
                  saveData();
                  showQuiz();
                }
              }
            };
            inp.addEventListener('contextmenu', deleteLabel);
            wrapper.appendChild(inp);
            // Number badge that matches the definition list
            let defIdx = -1;
            if (sec.definitions && sec.definitions.length) {
              defIdx = sec.definitions.findIndex(d => d.labelText === lbl.text);
            }
            if (defIdx >= 0) {
              const badge = document.createElement('div');
              badge.textContent = defIdx + 1;
              badge.style.position = 'absolute';
              badge.style.left = (lbl.x - 18) + 'px';
              badge.style.top = lbl.y + 'px';
              badge.style.width = '16px';
              badge.style.height = '16px';
              badge.style.borderRadius = '50%';
              badge.style.background = '#1abc9c';
              badge.style.color = '#fff';
              badge.style.fontSize = '10px';
              badge.style.display = 'flex';
              badge.style.alignItems = 'center';
              badge.style.justifyContent = 'center';
              badge.style.pointerEvents = 'none';
              badge.setAttribute('aria-hidden', 'true');
              badge.setAttribute('data-tts-skip', 'true');
              badge.dataset.origX = lbl.x - 18;
              badge.dataset.origY = lbl.y;
              badge.dataset.origW = 16;
              badge.dataset.origH = 16;
              badge.dataset.origFont = 10;
              wrapper.appendChild(badge);
            }
          });

          quizContent.appendChild(wrapper);
          // ---- Render mini‑fill definitions under the image ----
          if (sec.definitions && sec.definitions.length) {
            const defsHdr = document.createElement('h4');
            defsHdr.textContent = 'Definitions';
            defsHdr.style.marginTop = '20px';
            quizContent.appendChild(defsHdr);

            sec.definitions.forEach((def, dIndex) => {
              // Prefix each definition with its number – label name stays hidden until solved
              const para = document.createElement('p');
              para.style.marginBottom = '12px';
              if (def.hideUntilSolved) para.style.display = 'none';
              const numberSpan = document.createElement('span');
              numberSpan.className = 'definition-number';
              numberSpan.textContent = (dIndex + 1) + '. ';
              numberSpan.setAttribute('aria-hidden', 'true');
              numberSpan.setAttribute('data-tts-skip', 'true');
              para.appendChild(numberSpan);
              const title = document.createElement('strong');
              title.textContent = '';
              para.appendChild(title);
              // Register this definition's title for reveal
              titleMap[def.labelText] = {
                el: title,
                idx: dIndex,
                para,
                hide: def.hideUntilSolved,
                revealed: false,
                numberEl: numberSpan
              };
              const tokens = (def.rawText || '').split(/(\s+)/);
              const hiddenEntries = getHiddenEntries(def, tokens);
              // revealMap no longer used
              let counts = {};
              tokens.forEach(tok => {
                if (!tok.trim()) {
                  para.appendChild(document.createTextNode(tok));
                  return;
                }
                const w = tok.trim();
                counts[w] = (counts[w] || 0) + 1;
                const occ = counts[w];
                const key = `${w}_${occ}`;
                const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);

                if (!isHidden) {
                  para.appendChild(document.createTextNode(tok));
                  return;
                }

                const answers = [w, ...(def.alts[key] || [])];

                const span = document.createElement('span');
                span.className = 'blank';
                const inp = document.createElement('input');
                inp.className = 'blank-input';
                inp.setAttribute('data-answer', JSON.stringify(answers));
                // Track focus for definition blanks too
                inp.addEventListener('focus', () => {
                  lastHintTarget = inp;
                  activeBlankInput = inp;
                });
                // keep track of blanks for this definition
                if (!para._inputs) para._inputs = [];
                para._inputs.push(inp);
                // Match font family & size to regular fill‑in blanks
                const qcStyle = window.getComputedStyle(quizContent);
                inp.style.fontFamily = qcStyle.fontFamily;
                inp.style.fontSize   = qcStyle.fontSize;
                inp.style.padding    = '0 2px';
                // Space → next blank (if correct); Tab → previous; Backspace at start → previous
                inp.addEventListener('keydown', e => {
                  const inputs = Array.from(quizContent.querySelectorAll('input.blank-input'));
                  const idx = inputs.indexOf(inp);
                  if (e.key === ' ') {
                    e.preventDefault();
                    if (inp.classList.contains('correct') && idx < inputs.length - 1) {
                      inputs[idx + 1].focus();
                    }
                  }
                  if (e.key === 'Tab') {
                    e.preventDefault();
                    if (idx > 0) inputs[idx - 1].focus();
                  }
                  if (e.key === 'Backspace' && inp.selectionStart === 0 && inp.selectionEnd === 0 && inp.value === '' && idx > 0) {
                    e.preventDefault();
                    const prev = inputs[idx - 1];
                    prev.focus();
                    const len = prev.value.length;
                    prev.setSelectionRange(len, len);
                  }
                });

                // width sizing identical to regular fill‑ins
                const meas = document.createElement('span');
                meas.style.visibility = 'hidden';
                meas.style.position   = 'absolute';
                meas.style.whiteSpace = 'pre';
                meas.textContent = w.toUpperCase();
                document.body.appendChild(meas);
                inp.style.width = meas.offsetWidth + 4 + 'px';
                document.body.removeChild(meas);

                inp.oninput = () => {
                  const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/g,'');
                  const val = normalize(inp.value);
                  const ok = answers.some(a => normalize(a) === val);
                  inp.classList.toggle('correct', ok);
                  inp.classList.toggle('incorrect', !ok);

                  if (inp.value.trim().length === 0) {
                    // nothing
                  } else if (ok) {
                    const nextB = para._inputs.find(b => !b.classList.contains('correct'));
                    if (nextB) {
                      setTimeout(() => nextB.focus(),0);
                    } else {
                      const nextLbl = labelOrder[dIndex+1];
                      if (nextLbl) setTimeout(() => nextLbl.focus(),0);
                    }
                  } else {
                    // nothing
                  }

                  const allInputs = Array.from(quizContent.querySelectorAll('input.blank-input'));
                  if (allInputs.length && allInputs.every(i => i.classList.contains('correct'))) {
                    quizContent.style.borderColor = '#27ae60';
                    markQuestionCompleted();
                  } else {
                    quizContent.style.borderColor = '';
                  }
                };

                span.appendChild(inp);
                para.appendChild(span);
              });
              quizContent.appendChild(para);
            });
          }
          labelOrder = sec.definitions.map(d => labelInputs[d.labelText]).filter(Boolean);
          if (sec.extraImages) {
            renderQuizExtras(sec, wrapper);
          }
          refreshAnswersToggle(sec);
          return;
        }
        // existing fill-in logic follows
        quizContent.style.borderColor = '';
        // Use the same tokenization approach as the preview
        const tokensArr = extractTokens(sec);
        const hiddenEntries = getHiddenEntries(sec, tokensArr);
        let counts = {};
        tokensArr.forEach((tok, i) => {
          if (!tok.trim()) {
            quizContent.appendChild(document.createTextNode(tok));
            return;
          }
          const w = tok.trim();
          counts[w] = (counts[w] || 0) + 1;
          const occ = counts[w];
          const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);
          if (isHidden) {
            const key = `${w}_${occ}`;
            let answers = [w, ...(sec.alts[key]||[])];
            let wrapper = document.createElement('span');
            wrapper.className = 'blank';
            // Always size based on uppercase text width with extra room
            const blankText = w.toUpperCase();
            wrapper.setAttribute('data-scrambled', '_'.repeat(blankText.length || 1));
            let inp = document.createElement('input');
            inp.className = 'blank-input';
            inp.addEventListener('focus', () => {
              lastHintTarget = inp;
              activeBlankInput = inp;
            });
            // store correct answers for hint feature
            inp.setAttribute('data-answer', JSON.stringify(answers));
            // Match quiz section font
            const qcStyle = window.getComputedStyle(quizContent);
            inp.style.fontFamily = qcStyle.fontFamily;
            inp.style.fontSize = qcStyle.fontSize;
            inp.style.padding = '0 2px';
            inp.style.boxSizing = 'content-box';
            // Measure text width using hidden span
            const measurer = document.createElement('span');
            measurer.style.visibility = 'hidden';
            measurer.style.position = 'absolute';
            measurer.style.whiteSpace = 'pre';
            measurer.style.font = `${qcStyle.fontSize} ${qcStyle.fontFamily}`;
            measurer.textContent = blankText;
            document.body.appendChild(measurer);
            inp.style.width = (measurer.offsetWidth + 4) + 'px';
            document.body.removeChild(measurer);
            // Space → next (if correct); Tab → previous; Backspace at start → previous
            inp.addEventListener('keydown', e => {
              const inputs = Array.from(document.querySelectorAll('#quizContent input.blank-input'));
              const idx = inputs.indexOf(inp);
              if (e.key === ' ') {
                e.preventDefault();
                if (inp.classList.contains('correct') && idx < inputs.length - 1) {
                  inputs[idx + 1].focus();
                }
              }
              if (e.key === 'Tab') {
                e.preventDefault();
                if (idx > 0) {
                  inputs[idx - 1].focus();
                }
              }
              if (e.key === 'Backspace' && inp.selectionStart === 0 && inp.selectionEnd === 0 && inp.value === '' && idx > 0) {
                e.preventDefault();
                const prev = inputs[idx - 1];
                prev.focus();
                const len = prev.value.length;
                prev.setSelectionRange(len, len);
              }
            });
            // Simplified input handler: just correctness, outline if all correct
            inp.oninput = () => {
              const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/g,'');
              const val = normalize(inp.value);
              const ok = answers.some(a => normalize(a) === val);
              inp.classList.toggle('correct', ok);
              inp.classList.toggle('incorrect', !ok);
              const allInputs = Array.from(document.querySelectorAll('#quizContent input.blank-input'));
              if (allInputs.length && allInputs.every(i => i.classList.contains('correct'))) {
                quizContent.style.borderColor = '#27ae60';
                markQuestionCompleted();
              } else {
                quizContent.style.borderColor = '';
              }
            };
            wrapper.appendChild(inp);
            quizContent.appendChild(wrapper);
          } else {
            quizContent.appendChild(document.createTextNode(tok));
          }
        });
        refreshAnswersToggle(sec);
      }
        nextBtn.onclick = () => {
          if (justCompleted) return;
          const secs = multiFolderMode ? null : data.folders[currentFolder].sections;
          const total = multiFolderMode ? null : secs.length;
          if (questionCompleted() && !justCompleted) {
            markQuestionCompleted();
            if (justCompleted) return;
          }
          if (isQuizMode && quizOrder.length > 1 && quizPos < quizOrder.length - 1) {
            quizPos++;
            if (!multiFolderMode) {
              const prog = quizProgress[currentFolder];
              if (prog) prog.pos = quizPos;
            }
            showQuiz();
            updateProgressIndicator();
            return;
          }
        if (!multiFolderMode && currentSection < total - 1) {
          currentSection++;
          renderSections();
          enterQuizQuestion();
        } else if (!multiFolderMode) {
          alert('🎉 All done!');
          enterEdit();
        }
        updateProgressIndicator();
        updateHeader();
      };
      backBtn.onclick = () => {
        const secs = multiFolderMode ? null : data.folders[currentFolder].sections;
          if (isQuizMode && quizOrder.length > 1 && quizPos > 0) {
            quizPos--;
            if (!multiFolderMode) {
              const prog = quizProgress[currentFolder];
              if (prog) prog.pos = quizPos;
            }
            showQuiz();
            updateProgressIndicator();
            return;
          }
          if (!multiFolderMode && currentSection > 0) {
            currentSection--;
            renderSections();
            if (isQuizMode) {
              enterQuizQuestion();
            } else {
              loadSection();
              previewSection();
            }
          }
        updateProgressIndicator();
        updateHeader();
      };
      // --- Hint button logic ---
      hintBtn.onclick = () => {
        // Determine target: last focused blank, then active focus, then first incomplete
        let target = null;
        if (lastHintTarget && lastHintTarget.dataset.answer) {
          target = lastHintTarget;
        } else {
          const active = document.activeElement;
          if (active && active.classList.contains('blank-input') && active.dataset.answer) {
            target = active;
          } else {
            const inputs = Array.from(document.querySelectorAll('#quizContent input.blank-input'));
            target = inputs.find(i => !i.classList.contains('correct')) || null;
          }
        }
        if (target && target.dataset.answer) {
          const answers = JSON.parse(target.getAttribute('data-answer'));
          const correct = answers[0] || '';
          target.value = correct;

          if (!target.dataset.label) {
            // Regular blank – use normal correctness logic
            target.dispatchEvent(new Event('input'));
          } else {
            // Picture‑label blank: show temporarily, don’t trigger permanent reveal
            target.classList.add('correct');
            // size to fit if user previously shrank
            target.style.width = correct.length + 1 + 'ch';
          }

          target.focus();
          setTimeout(() => {
            // Clear only if user hasn’t typed something else
            if (target.value.trim().toLowerCase() === correct.toLowerCase()) {
              target.value = '';
              target.classList.remove('correct');
            }
          }, 1000);
        }
      };

      // --- Popup word click handler ---
      const isTouchEnvironment = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
      let lastTouchPopup = 0;

      function removeImagePopup() {
        const existing = document.getElementById('imageWordPopup');
        if (!existing) return;
        if (typeof existing._cleanup === 'function') {
          try {
            existing._cleanup();
          } catch (err) {
            console.warn('Image popup cleanup failed', err);
          }
        }
        existing.remove();
      }

      function showPopupFor(target) {
        removeImagePopup();
        const popup = document.createElement('div');
        const cleanupFns = [];
        const registerCleanup = fn => cleanupFns.push(fn);
        popup._cleanup = () => {
          while (cleanupFns.length) {
            const fn = cleanupFns.pop();
            try { fn(); } catch (err) { console.warn('Popup cleanup handler failed', err); }
          }
        };
        popup.id = 'imageWordPopup';
        popup.style.position = 'fixed';
        popup.style.background = '#fff';
        popup.style.border = '1px solid #7f8c8d';
        popup.style.borderRadius = '4px';
        popup.style.padding = '8px';
        popup.style.zIndex = '10000';
        popup.style.maxWidth = '90vw';
        popup.style.boxShadow = '0 6px 18px rgba(0,0,0,0.2)';
        popup.style.cursor = 'grab';
        popup.style.userSelect = 'none';

        const stopPropagation = e => e.stopPropagation();
        popup.addEventListener('click', stopPropagation);
        registerCleanup(() => popup.removeEventListener('click', stopPropagation));

        const isMobilePopup = document.body.classList.contains('mobile') || (isTouchEnvironment && window.innerWidth <= 900);
        let userMovedPopup = false;
        const margin = 12;

        const clampWithin = (value, min, max) => {
          if (!isFinite(value)) return min;
          if (max < min) return min;
          return Math.min(Math.max(value, min), max);
        };

        const clampToViewport = () => {
          if (!popup.isConnected) return;
          const width = popup.offsetWidth || 0;
          const height = popup.offsetHeight || 0;
          let left = parseFloat(popup.style.left) || 0;
          let top = parseFloat(popup.style.top) || 0;
          const maxLeft = window.innerWidth - width - margin;
          const maxTop = window.innerHeight - height - margin;
          left = clampWithin(left, margin, maxLeft);
          top = clampWithin(top, margin, maxTop);
          popup.style.left = `${left}px`;
          popup.style.top = `${top}px`;
        };

        const reposition = ({ forceCenter = false } = {}) => {
          if (!popup.isConnected) return;
          const width = popup.offsetWidth || 0;
          const height = popup.offsetHeight || 0;
          if (userMovedPopup && !forceCenter) {
            clampToViewport();
            return;
          }
          if (isMobilePopup || forceCenter) {
            let left = (window.innerWidth - width) / 2;
            let top = (window.innerHeight - height) / 2;
            popup.style.left = `${left}px`;
            popup.style.top = `${top}px`;
          } else {
            const rect = target.getBoundingClientRect();
            let left = rect.left + rect.width / 2 - width / 2;
            let top = rect.top - height - margin;
            if (top < margin) {
              top = rect.bottom + margin;
            }
            popup.style.left = `${left}px`;
            popup.style.top = `${top}px`;
          }
          clampToViewport();
        };

        const img = document.createElement('img');
        img.alt = target.textContent || 'Image';
        const ref = target.dataset.img;
        if (ref) {
          if (ref.startsWith('sha256:')) {
            imageURL(ref).then(url => {
              if (url) {
                img.src = url;
              } else {
                console.warn('Local image missing from IndexedDB', ref);
                img.style.display = 'none';
                const note = document.createElement('div');
                note.textContent = 'Image unavailable on this device';
                note.style.marginTop = '6px';
                note.style.fontSize = '0.85rem';
                note.style.color = '#c0392b';
                popup.appendChild(note);
              }
            });
          } else {
            applyImageRef(img, ref);
          }
        }
        img.style.maxWidth = '200px';
        img.style.maxHeight = '200px';
        img.dataset.zoomed = '0';

        const applyZoomState = zoomed => {
          if (zoomed) {
            img.style.maxWidth = '80vw';
            img.style.maxHeight = '80vh';
            img.dataset.zoomed = '1';
          } else {
            img.style.maxWidth = '200px';
            img.style.maxHeight = '200px';
            img.dataset.zoomed = '0';
          }
          requestAnimationFrame(() => reposition({ forceCenter: zoomed }));
        };

        const toggleZoom = () => {
          const zoomed = img.dataset.zoomed === '1';
          applyZoomState(!zoomed);
        };

        if (isTouchEnvironment) {
          img.addEventListener('click', evt2 => {
            evt2.stopPropagation();
            toggleZoom();
          });
          img.style.touchAction = 'none';
          if (typeof Panzoom === 'function') {
            try {
              Panzoom(img, { maxScale: 5, minScale: 1 });
            } catch (err) {
              console.warn('Panzoom init failed', err);
            }
          }
        } else {
          img.addEventListener('dblclick', evt2 => {
            evt2.stopPropagation();
            toggleZoom();
          });
        }
        popup.appendChild(img);
        if (!ref) {
          img.style.display = 'none';
          const note = document.createElement('div');
          note.textContent = 'No image attached to this word yet';
          note.style.marginTop = '6px';
          note.style.fontSize = '0.85rem';
          note.style.color = '#7f8c8d';
          popup.appendChild(note);
        }

        const startDrag = e => {
          if (e.type === 'mousedown' && e.button !== 0) return;
          if (e.touches && e.touches.length !== 1) return;
          if (e.target && e.target.tagName === 'IMG') return;
          const point = e.touches ? e.touches[0] : e;
          if (!point) return;
          e.preventDefault();
          const rect = popup.getBoundingClientRect();
          dragOffsetX = point.clientX - rect.left;
          dragOffsetY = point.clientY - rect.top;
          popup.style.cursor = 'grabbing';
          dragging = true;
          document.addEventListener('mousemove', onDragMove);
          document.addEventListener('mouseup', endDrag);
          document.addEventListener('touchmove', onDragMove, { passive: false });
          document.addEventListener('touchend', endDrag);
        };

        let dragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        const onDragMove = e => {
          if (!dragging) return;
          const point = e.touches ? e.touches[0] : e;
          if (!point) return;
          e.preventDefault();
          const left = point.clientX - dragOffsetX;
          const top = point.clientY - dragOffsetY;
          popup.style.left = `${left}px`;
          popup.style.top = `${top}px`;
          clampToViewport();
        };

        const endDrag = () => {
          if (!dragging) return;
          dragging = false;
          popup.style.cursor = 'grab';
          userMovedPopup = true;
          document.removeEventListener('mousemove', onDragMove);
          document.removeEventListener('mouseup', endDrag);
          document.removeEventListener('touchmove', onDragMove);
          document.removeEventListener('touchend', endDrag);
          clampToViewport();
        };

        popup.addEventListener('mousedown', startDrag);
        popup.addEventListener('touchstart', startDrag, { passive: false });
        registerCleanup(() => {
          popup.removeEventListener('mousedown', startDrag);
          popup.removeEventListener('touchstart', startDrag);
          endDrag();
        });

        document.body.appendChild(popup);

        const handleResize = () => reposition();
        window.addEventListener('resize', handleResize);
        registerCleanup(() => window.removeEventListener('resize', handleResize));

        const onImageLoad = () => reposition();
        img.addEventListener('load', onImageLoad);
        registerCleanup(() => img.removeEventListener('load', onImageLoad));

        const remove = evt => {
          if (evt && evt.target.closest && evt.target.closest('#imageWordPopup')) return;
          removeImagePopup();
          document.removeEventListener('click', remove, true);
          document.removeEventListener('touchstart', remove, true);
        };
        registerCleanup(() => {
          document.removeEventListener('click', remove, true);
          document.removeEventListener('touchstart', remove, true);
        });

        setTimeout(() => {
          document.addEventListener('click', remove, true);
          document.addEventListener('touchstart', remove, true);
        }, 0);

        requestAnimationFrame(() => reposition({ forceCenter: isMobilePopup }));
      }

      function handlePopupTrigger(evt) {
        if (evt.type === 'touchend') {
          lastTouchPopup = Date.now();
        } else if (evt.type === 'click' && lastTouchPopup && Date.now() - lastTouchPopup < 400) {
          return;
        }
        const target = evt.target.closest && evt.target.closest('.popup-word');
        if (!target) return;
        evt.stopPropagation();
        showPopupFor(target);
      }

      document.addEventListener('click', handlePopupTrigger);
      document.addEventListener('touchend', handlePopupTrigger);

      document.addEventListener('selectionchange', () => {
        if (!document.body.classList.contains('mobile')) return;
        if (!isQuizMode) return;
        if (!quizArea || quizArea.style.display === 'none') return;
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        const anchorNode = sel.anchorNode;
        if (!anchorNode) return;
        if (answerBank && answerBank.contains(anchorNode)) return;
        if (toggleAnswersBtn && toggleAnswersBtn.contains && toggleAnswersBtn.contains(anchorNode)) return;
        let element = anchorNode.nodeType === Node.ELEMENT_NODE ? anchorNode : anchorNode.parentElement;
        if (!element) return;
        if (answerBank && answerBank.contains(element)) return;
        if (toggleAnswersBtn && toggleAnswersBtn.contains && toggleAnswersBtn.contains(element)) return;
        if (!quizContent || !quizContent.contains(element)) return;
        const card = element.closest('.question-section-card');
        if (!card) return;
        if (selectionMoveTimer) clearTimeout(selectionMoveTimer);
        selectionMoveTimer = setTimeout(() => {
          moveAnswerControlsBelowCard(card);
        }, 40);
      });

      // --- Keyboard shortcuts for quiz navigation and hints ---
      document.addEventListener('keydown', e => {
        if (!isQuizMode) return;                // only active in quiz modes
        if (e.metaKey && e.key === 'Enter') {   // Command + Enter => next question
          e.preventDefault();
          nextBtn.click();
        }
        if (e.metaKey && (e.key === 'h' || e.key === 'H')) {  // Command + H => hint
          e.preventDefault();
          hintBtn.click();
        }
      });

    } catch (err) {
      console.error(err);
      alert('Unhandled error: ' + err.message);
    }
  })();
  </script>
</body>
</html>
