<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>QuizMaker</title>
  <link rel="icon" href="data:,">
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
  <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
  <style>
    /* Ensure formatted spans do not disrupt line spacing */
    #editor span {
      display: inline;
      line-height: normal;
      vertical-align: baseline;
    }
    /* Slim, subtle scrollbar for the questions list */
    #sectionsContainer {
      scrollbar-width: thin;
      scrollbar-color: rgba(0,0,0,0.3) transparent;
    }
    #sectionsContainer::-webkit-scrollbar {
      width: 6px;
    }
    #sectionsContainer::-webkit-scrollbar-track {
      background: transparent;
    }
    #sectionsContainer::-webkit-scrollbar-thumb {
      background-color: rgba(0,0,0,0.3);
      border-radius: 3px;
    }
    #sectionsContainer::-webkit-scrollbar-thumb:hover {
      background-color: rgba(0,0,0,0.5);
    }
    /* —— Reset & Base —— */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      display: flex; height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #ecf0f1; color: #333;
    }

    /* —— Sidebar —— */
    #sidebar {
      width: 240px;
      background: #2c3e50;
      color: #ecf0f1;
      padding: 20px;
    }
    /* QuestionControls button accents */
    #addFillBtn { border-left: 4px solid #1abc9c; }
    #addLabelBtn { border-left: 4px solid #e67e22; }
    #addAcronymBtn { border-left: 4px solid #8e44ad; }
    #toggleDeleteBtn { border-left: 4px solid #c0392b; }

    /* QuestionControls buttons base styling */
    #questionControls button {
      border-top: none;
      border-right: none;
      border-bottom: none;
      border-radius: 4px;
      background: #fff;
      color: #2c3e50;
      cursor: pointer;
      transition: background .2s;
    }
    #questionControls button:hover {
      background: #ecf0f1;
    }

    /* Mode switch button accents */
    #editModeBtn { border-left: 4px solid #1abc9c; }
    #quizModeBtn { border-left: 4px solid #8e44ad; }
    #quizAllBtn { border-left: 4px solid #e67e22; }
    #sidebar h3 {
      margin-bottom: 10px;
      font-size: 1.1rem;
      letter-spacing: .5px;
    }
    .nav { list-style: none; margin-bottom: 20px; }
    .nav li {
      padding: 8px 12px;
      border-radius: 4px;
      margin-bottom: 4px;
      cursor: pointer;
      transition: background .2s;
    }
    /* Question type accents */
    .nav li.type-fill {
      border-left: 4px solid #1abc9c;
      padding-left: 8px;
    }
    .nav li.type-diagram {
      border-left: 4px solid #e67e22;
      padding-left: 8px;
    }
    .nav li.type-acronym {
      border-left: 4px solid #8e44ad;
      padding-left: 8px;
    }
    .nav li:hover { background: #34495e; }

    /* Dynamic selected background based on question type */
    .nav li.selected {
      font-weight: bold;
    }
    .nav li.type-fill.selected {
      background: #1abc9c;
      color: #2c3e50;
    }
    .nav li.type-diagram.selected {
      background: #e67e22;
      color: #2c3e50;
    }
    .nav li.type-acronym.selected {
      background: #8e44ad;
      color: #fff;
    }
    #newFolderName {
      width: calc(100% - 100px);
      padding: 6px;
      margin-bottom: 8px;
      border: none;
      border-radius: 4px;
    }
    #addFolderBtn, #addSectionBtn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: #e67e22;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #addFolderBtn:hover, #addSectionBtn:hover { background: #d35400; }

    /* —— Main Area & Header —— */
    #main { flex: 1; display: flex; flex-direction: column; }
    #header {
      background: #1abc9c;
      color: #fff;
      padding: 16px 24px;
      font-size: 1.3rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #controls {
      display: flex;
      gap: 10px;
      padding: 12px 24px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    #controls button {
      flex: 1;
      padding: 8px;
      border: none;
      border-radius: 4px;
      background: #3498db;
      color: #fff;
      font-weight: 500;
      cursor: pointer;
      transition: background .2s;
    }
    #controls button:hover { background: #2980b9; }

    /* —— Editor & Preview —— */
    #formatToolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #fff;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      padding: 4px;
      margin-bottom: 12px;
    }
    #formatToolbar button {
      font-weight:bold;
      padding:4px 8px;
      cursor:pointer;
    }
    #formatToolbar select, #formatToolbar input[type="color"] {
      cursor:pointer;
    }
    .delete-icon {
      display: none;
      margin-left: 4px;
      color: red;
      cursor: pointer;
    }
    #editorArea, #quizArea { flex: 1; padding: 24px; overflow-y: auto; }
    #editor {
      width: 100%;
      height: auto;
      max-height: none;
      min-height: 180px;
      overflow-y: hidden;
      padding: 12px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      font-family: Menlo, monospace;
      background: #fff;
      white-space: pre-wrap;
    }
    #preview {
      margin-top: 20px;
      padding: 16px;
      background: #fff;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      min-height: 120px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    /* Custom preview line class to control vertical spacing */
    .preview-line {
      margin: 0 0 6px 0;
      display: block;
      line-height: 1.4;
    }
    .word {
      display: inline;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 2px;
      padding: 4px 6px;
      border-radius: 4px;
      transition: background .2s;
      cursor: pointer;
    }
    .word:hover { background: #dfe6e9; }
    .word.hidden { color: transparent; text-shadow: 0 0 5px #000; }
    #previewBtn, #saveSectionBtn {
      margin-top: 12px;
      margin-right: 8px;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #1abc9c;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #previewBtn:hover, #saveSectionBtn:hover { background: #1e8449; }

    /* —— Alternate Answers UI —— */
    #altContainer {
      margin-top: 20px; padding: 16px;
      background: #fdfdfd;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
    }
    #altContainer h4 { margin-bottom: 10px; font-size: 1rem; color: #2c3e50; }
    .alt-input {
      width: 120px;             /* fixed small width */
      padding: 2px 4px;
      margin-bottom: 4px;
      margin-right: 8px;
      font-size: 0.8rem;
      border: 1px solid #7f8c8d;
      border-radius: 4px;
    }

    /* Override the generic #labelEditor input rule so alternate‑answer boxes stay compact */
    #labelEditor .alt-input {
      width: 120px;
      padding: 2px 4px;
      margin-bottom: 4px;
      margin-right: 8px;
      font-size: 0.8rem;
    }

    #labelDefinitions h4 { font-size: 1.1rem; margin-bottom: 4px; }

    /* —— Quiz Mode & Blanks —— */
    #quizContent {
      white-space: pre-wrap;
      word-break: break-word;
      padding: 24px;
      background: #fff;
      border: 2px solid #bdc3c7;
      border-radius: 4px;
      font-size: 1.1rem;
      line-height: 1.5;
    }

    /* —— Enlarged Text & Inputs for Edit and Quiz Modes —— */
    #editor {
      font-size: 1.2rem;
    }
    #labelEditor input, #acroEditor input {
      font-size: 1.2rem;
      padding: 6px;
    }
    #quizArea, #quizContent {
      font-size: 1.2rem;
    }
    /* —— Fill-In Quiz Font & Size —— */
    #quizContent .blank input {
      font-size: inherit;
      font-family: inherit;
      padding: 0 2px;
    }
    #quizContent .blank {
      font-family: Arial, sans-serif;
    }
    /* —— Acronym Quiz Font & Width —— */
    #quizContent input[type="text"] {
      font-family: Arial, sans-serif;
      min-width: 0ch;
    }

    /* Definition wrapper styling and drag-and-drop container */
    .definition-list {
      display: flex;
      flex-direction: column;
    }
    .definition-wrapper {
      border: 1px solid #bdc3c7;
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 4px;
      background: #fff;
      cursor: move;
    }
    /* Grading full border for correct inputs */
    input.correct {
      border: 2px solid #27ae60 !important;
    }
    input.incorrect {
      border: 2px solid #c0392b !important;
    }
    .blank { position: relative; display: inline-block; margin: 0 2px; }
    .blank::before {
      content: '';
    }
    .blank input {
      position: relative; background: transparent;
      border: none; border-bottom: 1px solid #7f8c8d;
      font-family: Menlo, monospace; font-size: 1.1rem;
      padding: 0; margin: 0; box-sizing: content-box;
      min-width: 1ch;
    }
    .blank input:focus { outline: none; border-bottom-color: #3498db; }
    .blank input.correct { border-bottom-color: #27ae60; }
    .blank input.incorrect { border-bottom-color: #c0392b; }
    #nextBtn, #backBtn {
      margin-top: 20px; padding: 10px 20px;
      border: none; border-radius: 4px;
      background: #8e44ad; color: #fff;
      cursor: pointer; transition: background .2s;
    }
    #nextBtn:hover, #backBtn:hover { background: #71368a; }
    #hintBtn {
      margin-top: 20px;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      background: #8e44ad;
      color: #fff;
      cursor: pointer;
      transition: background .2s;
    }
    #hintBtn:hover {
      background: #71368a;
    }

    #progressStatus {
      text-align: center;
      font-size: 1rem;
    }

    /* Enforce pixel sizes for Quill size picker */
    .ql-size-8px  { font-size: 8px !important; }
    .ql-size-10px { font-size: 10px !important; }
    .ql-size-12px { font-size: 12px !important; }
    .ql-size-14px { font-size: 14px !important; }
    .ql-size-16px { font-size: 16px !important; }
    .ql-size-18px { font-size: 18px !important; }
    .ql-size-20px { font-size: 20px !important; }
    .ql-size-24px { font-size: 24px !important; }
    .ql-size-28px { font-size: 28px !important; }
    .ql-size-32px { font-size: 32px !important; }


    /* Ensure bullets render properly across views */
    #preview     ul.ql-list.ql-bullet,
    #quizContent ul.ql-list.ql-bullet,
    .ql-editor  ul.ql-list.ql-bullet {
      padding-left: 2em;
      margin: 0.5em 0;
    }

    /* Show diamonds instead of discs when editing */
    .ql-editor ul.ql-list.ql-bullet {
      list-style: none;
    }
    .ql-editor ul.ql-list.ql-bullet li { position: relative; }
    .ql-editor ul.ql-list.ql-bullet li::before {
      content: "\25C6"; /* diamond */
      position: absolute;
      left: -1em;
    }

    /* Preview/quiz should keep default bullets */
    #preview     ul.ql-list.ql-bullet,
    #quizContent ul.ql-list.ql-bullet {
      list-style: disc;
    }
    /* Remove the editor diamonds in non-edit views */
    #preview     ul.ql-list.ql-bullet li::before,
    #quizContent ul.ql-list.ql-bullet li::before {
      content: none;
    }

    /* Fallback: indent any unordered list in quiz content */
    #quizContent ul {
      list-style-type: disc;
      list-style-position: outside;
      margin-left: 1.5em; /* indent bullet + text */
      padding-left: 0;    /* prevent double indent */
    }
  </style>
</head>
<body>


  <div id="sidebar" style="display:flex; flex-direction:column; height:100vh;">
    <h3>Folders</h3>
    <ul id="folders" class="nav"></ul>
    <input id="newFolderName" placeholder="New folder name">
    <button id="addFolderBtn">Add Folder</button>
    <hr style="border:1px solid #34495e;opacity:.2;margin:20px 0;">
    <h3>Questions</h3>
    <div style="position: relative; margin-bottom: 8px;">
      <input type="text" id="sectionSearch"
             placeholder="Search questions..."
             style="width: calc(100% - 30px);
                    padding: 6px;
                    border: none;
                    border-radius: 4px;">
      <span id="clearSearchBtn"
            style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%);
                   cursor: pointer; font-size: 14px; display: none; color: #ecf0f1;">✖</span>
    </div>
    <!-- Scrollable questions list -->
    <div id="sectionsContainer" style="flex:1; overflow-y:auto; padding-right:12px;">
      <ul id="sections" class="nav"></ul>
    </div>
    <div id="questionControls" style="position: sticky; bottom: 0; background: #2c3e50; padding: 8px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
      <button id="addFillBtn" style="padding: 4px 12px; white-space: normal; overflow-wrap: break-word; text-align: center; line-height: 1.2em;">+ Fill-In</button>
      <button id="addLabelBtn" style="padding: 4px 12px; white-space: normal; overflow-wrap: break-word; text-align: center; line-height: 1.2em;">+ Diagram</button>
      <button id="addAcronymBtn" style="padding: 4px 12px; white-space: normal; overflow-wrap: break-word; text-align: center; line-height: 1.2em;">+ Acronym</button>
      <button id="toggleDeleteBtn" style="padding: 4px 12px; white-space: normal; overflow-wrap: break-word; text-align: center; line-height: 1.2em;">🗑️ Delete</button>
      <input type="file" id="labelImageInput" accept="image/*" style="display:none;">
    </div>
  </div>

  <div id="main">
    <div id="header">QuizMaker</div>
    <div id="controls">
      <button id="editModeBtn">✏️ Edit Mode</button>
      <button id="quizModeBtn">📝 Quiz Question</button>
      <button id="quizAllBtn">🎲 Random Quiz</button>
    </div>

    <div id="progressStatus" style="display:none; margin:8px 24px;">
      <div id="progressText" style="font-weight:bold;"></div>
      <div id="progressBarContainer" style="height:8px; background:#ccc; border-radius:4px; margin-top:4px;">
        <div id="progressBar" style="height:100%; width:0; background:#1abc9c; border-radius:4px;"></div>
      </div>
    </div>

    <div id="editorArea">
      <div id="toolbar">
        <select class="ql-size">
          <option value="" selected>Normal</option>
          <option value="8px">8px</option>
          <option value="10px">10px</option>
          <option value="12px">12px</option>
          <option value="14px">14px</option>
          <option value="16px">16px</option>
          <option value="18px">18px</option>
          <option value="20px">20px</option>
          <option value="24px">24px</option>
          <option value="28px">28px</option>
          <option value="32px">32px</option>
        </select>
        <button class="ql-bold"></button>
        <button class="ql-italic"></button>
        <button class="ql-underline"></button>
        <button class="ql-undo">↺</button>
        <button class="ql-redo">↻</button>
        <button class="ql-list" value="bullet"></button>
        <select class="ql-color"></select>
      </div>
      <div id="editor" style="height: 200px; background: #fff;"></div>
      <div style="margin-top:12px;">
        <button id="previewBtn">Preview Words</button>
        <button id="saveSectionBtn">Save Section</button>
      </div>
      <div id="preview"></div>
      <div id="labelEditor" style="display:none; position: relative;"></div>
      <div id="altContainer" style="display:none;">
        <h4>Alternate answers for blanks (comma-separated):</h4>
      </div>
    </div>

    <div id="quizArea" style="display:none;">
      <div id="quizContent"></div>
      <button id="backBtn">⬅️ Back</button>
      <button id="nextBtn">Next Section ➡️</button>
      <button id="hintBtn">Hint</button>
    </div>
  </div>

  <script>
    (async () => {
      try {
      // IndexedDB and persistent storage logic removed.
      // Function to position definitions container and add button absolutely below the image container
      function updateDefPosition() {
        const cont = document.getElementById('labelContainer');
        const addBtn = document.getElementById('addDefinitionBtn');
        const defCont = document.getElementById('labelDefinitions');
        if (cont && addBtn && defCont) {
          const parent = document.getElementById('labelEditor');
          parent.style.position = 'relative';
          const topOffset = cont.offsetTop + cont.offsetHeight + 10;
          // Position the Add Definition button
          addBtn.style.position = 'absolute';
          addBtn.style.top = topOffset + 'px';
          addBtn.style.left = cont.offsetLeft + 'px';
          // Make definitions span the rest of the editor width
          defCont.style.width = (parent.clientWidth - cont.offsetLeft) + 'px';
          // Position the definitions container below the button
          defCont.style.position = 'absolute';
          defCont.style.top = (topOffset + addBtn.offsetHeight + 10) + 'px';
          defCont.style.left = cont.offsetLeft + 'px';
        }
      }
      let isQuizMode = true;   // start in quiz mode by default
      let lastHintTarget = null;  // track last focused blank for hint
      let deleteMode = false;     // controls red‑X visibility, must exist before render functions run
      let quizOrder = [], quizPos = 0;  // initialize quiz sequence and position early
      let lastSectionOrder = null;
      // Track progress and random order per folder
      const quizProgress = {};  // { completed:Set, total, order:Array|null, pos:Number }
      // Progress is kept only for this session (no localStorage)

      function saveProgress() {
        // Previously saved to localStorage, but persistence was removed
      }

      function updateProgressIndicator() {
        const cont = document.getElementById('progressStatus');
        const text = document.getElementById('progressText');
        const bar  = document.getElementById('progressBar');
        const prog = quizProgress[currentFolder];
        if (!prog || !isQuizMode || quizOrder.length <= 1) {
          cont.style.display = 'none';
          return;
        }
        cont.style.display = 'block';
        text.textContent = `Progress: ${prog.completed.size} / ${prog.total}`;
        const percent = prog.total ? (prog.completed.size / prog.total) * 100 : 0;
        bar.style.width = percent + '%';
      }

      function questionCompleted() {
        const inputs = Array.from(document.querySelectorAll('#quizContent input[type="text"]'));
        if (!inputs.length) return true;
        return inputs.every(inp => inp.classList.contains('correct'));
      }

      function markQuestionCompleted() {
        let prog = quizProgress[currentFolder];
        if (!prog) {
          const total = data.folders[currentFolder].sections.length;
          prog = quizProgress[currentFolder] = { completed: new Set(), total };
        } else {
          prog.total = data.folders[currentFolder].sections.length;
        }
        if (!prog.completed.has(currentSection)) {
          prog.completed.add(currentSection);
        }
        updateProgressIndicator();
        saveProgress();
      }
      // ----- Load persistent data, with static fallback -----
      const GITHUB_JSON_URL = 'https://raw.githubusercontent.com/Ethan11San/Ethan11San.github.io/main/quizData.json';
      let data;
      let staticMode = false;
      try {
        // Attempt API fetch
        const resp = await fetch('http://localhost:5001/api/quizData', { cache: 'no-store' });
        if (resp.ok) {
          data = await resp.json();
        } else {
          throw new Error('API response not OK: ' + resp.status);
        }
      } catch (apiErr) {
        console.warn('API unavailable, falling back to quizData.json', apiErr);
        staticMode = true;
        try {
          const resp2 = await fetch('./quizData.json', { cache: 'no-store' });
          if (!resp2.ok) throw new Error('Static file response not OK');
          data = await resp2.json();
        } catch (staticErr) {
          console.warn('Local quizData.json unavailable, attempting GitHub raw', staticErr);
          try {
            const resp3 = await fetch(GITHUB_JSON_URL, { cache: 'no-store' });
            if (!resp3.ok) throw new Error('GitHub raw response not OK');
            data = await resp3.json();
          } catch (githubErr) {
            console.error('Error loading quiz data from GitHub:', githubErr);
            data = { folders: [] };
          }
        }
      }
      // Initialize currentFolder/Section based on loaded data...
      function saveData() {
        if (staticMode) {
          console.warn('Static mode: changes will not be saved to server.');
          return;
        }
        fetch('http://localhost:5001/api/quizData', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        })
        .then(resp => {
          if (!resp.ok) throw new Error('Status ' + resp.status);
        })
        .catch(err => {
          console.error('Error saving quiz data:', err);
          alert('Error saving quiz data: ' + err.message);
        });
      }

      let currentFolder = null, currentSection = null;
      let waitingForImagePaste = false;
      let isAddingDefinition = false;
      const foldersUL = document.getElementById('folders'), sectionsUL = document.getElementById('sections'),
            sectionSearch = document.getElementById('sectionSearch'),
            newFolderName = document.getElementById('newFolderName'), addFolderBtn = document.getElementById('addFolderBtn'),
            addFillBtn = document.getElementById('addFillBtn'),
            addLabelBtn = document.getElementById('addLabelBtn'),
            addAcronymBtn = document.getElementById('addAcronymBtn'),
            labelImageInput = document.getElementById('labelImageInput'),
            labelEditor = document.getElementById('labelEditor'),
            editModeBtn = document.getElementById('editModeBtn'),
            quizModeBtn = document.getElementById('quizModeBtn'),
            quizAllBtn  = document.getElementById('quizAllBtn'),
            editorArea = document.getElementById('editorArea'),
            quizArea = document.getElementById('quizArea'),
            previewDiv = document.getElementById('preview'), previewBtn = document.getElementById('previewBtn'),
            saveSectionBtn = document.getElementById('saveSectionBtn'), altContainer = document.getElementById('altContainer'),
            quizContent = document.getElementById('quizContent'), backBtn = document.getElementById('backBtn'), nextBtn = document.getElementById('nextBtn');
      const toggleDeleteBtn = document.getElementById('toggleDeleteBtn');
      const clearSearchBtn = document.getElementById('clearSearchBtn');
      const editorDiv = document.getElementById('editor');
      // Whitelist pixel sizes for Quill's size format
      const Size = Quill.import('formats/size');
      Size.whitelist = ['8px','10px','12px','14px','16px','18px','20px','24px','28px','32px'];
      Quill.register(Size, true);
      const quill = new Quill('#editor', {
        modules: {
          toolbar: '#toolbar',
          history: { delay: 1000, maxStack: 100, userOnly: true }
        },
        theme: 'snow'
      });
      // Auto‑expand the editor height to fit its content
      function adjustEditorHeight() {
        const root      = quill.root;             // editable area (ql-editor)
        const container = document.getElementById('editor'); // outer div

        // Reset to auto so we can measure natural height
        root.style.height      = 'auto';
        container.style.height = 'auto';

        // Set both elements to the new scrollHeight
        const extra = 12; // add breathing room below last line
        const newH = (root.scrollHeight + extra) + 'px';
        root.style.height      = newH;
        container.style.height = newH;
      }
      adjustEditorHeight();           // initial sizing
      quill.on('text-change', adjustEditorHeight);
      // Attach undo/redo handlers
      const toolbarModule = quill.getModule('toolbar');
      toolbarModule.addHandler('undo', () => quill.history.undo());
      toolbarModule.addHandler('redo', () => quill.history.redo());
      function syncCurrentSection(){
        if (currentFolder===null || currentSection===null) return;
        const sec = data.folders[currentFolder].sections[currentSection];
        sec.rawHtml = quill.root.innerHTML;
        sec.rawText = quill.getText();
        saveData();
      }
      // Also bind click for undo/redo in custom toolbar
      document.querySelector('#toolbar .ql-undo').addEventListener('click', () => quill.history.undo());
      document.querySelector('#toolbar .ql-redo').addEventListener('click', () => quill.history.redo());
      quill.on('text-change', () => {
        if (isQuizMode) return;
        if (!ensureSelection()) return;

        syncCurrentSection();

        const sec = data.folders[currentFolder].sections[currentSection];
        sec.rawHtml = quill.root.innerHTML;
        sec.rawText = quill.getText();
        saveData();

        // Auto-update the Preview Words area
        previewSection();
      });

      // —— Initial UI render using migrated or loaded data ——
      if (data.folders.length > 0) {
        currentFolder = 0;
        currentSection = data.folders[0].sections.length > 0 ? 0 : null;
      } else {
        currentFolder = null;
        currentSection = null;
      }
      renderFolders();
      renderSections(lastSectionOrder);
      if (currentSection !== null) {
        if (isQuizMode) {
          enterQuizQuestion();
        } else {
          enterEdit();
          loadSection();
        }
      }

      // --- Auto-resize editor textarea with content up to its max height ---
      // function adjustEditorHeight() {
      //   editorTA.style.height = 'auto';
      //   editorTA.style.height = editorTA.scrollHeight + 'px';
      // }
      // if (editorTA) editorTA.addEventListener('input', adjustEditorHeight);
      addAcronymBtn.onclick = () => {
        if (currentFolder === null) return alert('Select a folder first');
        const acr = prompt('Enter acronym (e.g. AAVIATE):');
        if (!acr) return;
        const entries = acr.split('').map(letter => ({
          letter,
          answer: '',
          extra: ''
        }));
        const q = { type: 'acronym', acronym: acr, entries };
        data.folders[currentFolder].sections.push(q);
        currentSection = data.folders[currentFolder].sections.length - 1;
        saveData();
        renderFolders();
        renderSections(lastSectionOrder);
        enterEdit();
        loadSection();
      };


      function renderFolders(){
        foldersUL.innerHTML='';
        data.folders.forEach((f,i)=>{
          let li=document.createElement('li');
          // Enable drag-and-drop reordering for folders
          li.draggable = true;
          li.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', i);
          });
          li.addEventListener('dragover', e => e.preventDefault());
          li.addEventListener('drop', e => {
            e.preventDefault();
            const from = Number(e.dataTransfer.getData('text/plain'));
            const moved = data.folders.splice(from, 1)[0];
            data.folders.splice(i, 0, moved);
            saveData();
            renderFolders();
            renderSections(lastSectionOrder);
          });
          li.textContent=f.name;
          li.className=i===currentFolder?'selected':'';
          li.onclick = () => {
            currentFolder = i;
            lastSectionOrder = null; // reset any prior search/order when switching folders
            // Default to first section in the newly selected folder
            if (data.folders[i].sections && data.folders[i].sections.length > 0) {
              currentSection = 0;
            } else {
              currentSection = null;
            }
            renderFolders();
            renderSections(lastSectionOrder);
            // If in quiz mode, handle empty folders
            if (isQuizMode) {
              if (currentSection !== null) {
                enterQuizQuestion();
              } else {
                // No questions in folder: show placeholder in quiz area
                editorArea.style.display = 'none';
                quizArea.style.display = 'block';
                quizContent.innerHTML = '<p style="color:#7f8c8d;font-style:italic;">No questions in this folder.</p>';
              }
            } else {
              // Otherwise, default to edit mode for that section
              enterEdit();
              if (currentSection !== null) {
                loadSection();
              }
            }
          };
          li.ondblclick=()=>{
            const newName = prompt('Enter new folder name:', f.name);
            if(newName && newName.trim()){
              data.folders[i].name = newName.trim();
              saveData();
              renderFolders();
            }
          };
          // Delete folder button
          const delF = document.createElement('span');
          delF.className = 'delete-icon';
          delF.textContent = '✖';
          delF.style.cursor = 'pointer';
          delF.style.color = 'red';
          delF.style.display = deleteMode ? 'inline' : 'none';
          delF.onclick = evt => {
            evt.stopPropagation();
            if (confirm(`Delete folder "${f.name}"? This cannot be undone.`)) {
              // Remove the folder
              data.folders.splice(i, 1);
              // Adjust currentFolder
              if (data.folders.length > 0) {
                const newIdx = i < data.folders.length ? i : data.folders.length - 1;
                currentFolder = newIdx;
                const secs = data.folders[currentFolder].sections;
                currentSection = secs.length > 0 ? 0 : null;
              } else {
                currentFolder = null;
                currentSection = null;
              }
              saveData();
              renderFolders();
              lastSectionOrder = null; // reset ordering after folder deletion
              renderSections(lastSectionOrder);
              enterEdit();
              if (currentSection !== null) loadSection();
            }
          };
          li.appendChild(delF);
          foldersUL.appendChild(li);
        });
      }
      function renderSections(order){
        sectionsUL.innerHTML = '';
        if (currentFolder === null) return;
        const indices = order || data.folders[currentFolder].sections.map((_,i) => i);
        indices.forEach(index => {
          const s = data.folders[currentFolder].sections[index];
          const i = index;
          let li=document.createElement('li');
          // Add a subtle left-border color to indicate question type
          li.classList.remove('type-fill', 'type-diagram', 'type-acronym');
          // Default to fill for missing or other types
          if (s.type === 'label')       li.classList.add('type-diagram');
          else if (s.type === 'acronym') li.classList.add('type-acronym');
          else                            li.classList.add('type-fill');
          // Enable drag-and-drop reordering for questions
          li.draggable = true;
          li.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', i);
          });
          li.addEventListener('dragover', e => e.preventDefault());
          li.addEventListener('drop', e => {
            e.preventDefault();
            const from = Number(e.dataTransfer.getData('text/plain'));
            const secs = data.folders[currentFolder].sections;
            const moved = secs.splice(from, 1)[0];
            const to = from < i ? i - 1 : i;
            secs.splice(to, 0, moved);
            if (currentSection === from) {
              currentSection = to;
            } else if (from < currentSection && currentSection <= to) {
              currentSection--;
            } else if (to <= currentSection && currentSection < from) {
              currentSection++;
            }
            saveData();
            renderSections(lastSectionOrder);
            if (!isQuizMode && currentSection !== null) loadSection();
          });
          let title='';
          if(s.type==='acronym') title = s.acronym;
          else if(s.type==='label') {
            const raw = s.rawText || '';
            const defaultTitle = raw.split('\n')[0].trim() || 'Label Question';
            title = s.title && s.title.trim() ? s.title : defaultTitle;
          }
          else { // fill
            const defaultTitle = (s.rawText && s.rawText.split('\n')[0].trim()) || '(untitled)';
            title = s.title && s.title.trim() ? s.title : defaultTitle;
          }
          li.textContent = title;
          // Only toggle the 'selected' class, preserving type-* classes
          if (i === currentSection) li.classList.add('selected');
          else li.classList.remove('selected');
          li.onclick = () => {
            currentSection = i;
            renderSections(lastSectionOrder);
            if (isQuizMode) {
              enterQuizQuestion();   // show quiz for this section
            } else {
              loadSection();
              enterEdit();           // show editor
            }
          };
          li.ondblclick=()=>{
            const sec = data.folders[currentFolder].sections[i];
            const defaultTitle = (sec.rawText && sec.rawText.split('\n')[0].trim()) || '(untitled)';
            const currentTitle = sec.title && sec.title.trim() ? sec.title : defaultTitle;
            const newTitle = prompt('Enter new section title:', currentTitle);
            if (newTitle !== null) {
              sec.title = newTitle.trim();
              saveData();
              renderSections(lastSectionOrder);
              enterEdit();
              loadSection();
              // No need to reload editor/rawText
            }
          };
          // Delete section/question button
          const delS = document.createElement('span');
          delS.className = 'delete-icon';
          const delTitle = title;
          delS.textContent = '✖';
          delS.style.cursor = 'pointer';
          delS.style.color = 'red';
          delS.style.display = deleteMode ? 'inline' : 'none';
          delS.onclick = evt => {
            evt.stopPropagation();
            if (confirm(`Delete question "${delTitle}"? This cannot be undone.`)) {
              // Remove the section
              data.folders[currentFolder].sections.splice(i, 1);
              // Adjust currentSection
              const secs = data.folders[currentFolder].sections;
              if (secs.length > 0) {
                currentSection = i < secs.length ? i : secs.length - 1;
              } else {
                currentSection = null;
              }
              saveData();
              renderSections(lastSectionOrder);
              enterEdit();
              if (currentSection !== null) loadSection();
            }
          };
          li.appendChild(delS);
          sectionsUL.appendChild(li);
        });
      }

      // Filter and reorder sections based on search input
      function filterSections() {
        const terms = sectionSearch.value.trim().toLowerCase().split(/\s+/).filter(Boolean);
        lastSectionOrder = null;
        if (!terms.length) {
          renderSections(lastSectionOrder);
          return;
        }
        const secs = data.folders[currentFolder].sections;
        const group1 = [], group2 = [], group3 = [];
        secs.forEach((s, idx) => {
          // Determine title and body text
          const defaultTitle = s.title?.trim() ||
            ((s.rawText||'').split('\n')[0].trim()) ||
            s.acronym ||
            '(untitled)';
          const title = defaultTitle.toLowerCase();
          let body = '';
          if (s.type === 'fill') body = s.rawText || '';
          else if (s.type === 'label')
            body = (s.rawText||'') + ' ' +
              (s.definitions||[]).map(d=>d.rawText||'').join(' ');
          else if (s.type === 'acronym') body = s.acronym;
          body = body.toLowerCase();
          const inTitleAll = terms.every(t => title.includes(t));
          const inBodyAny = terms.some(t => body.includes(t));
          if (inTitleAll) group1.push(idx);
          else if (inBodyAny) group2.push(idx);
          else group3.push(idx);
        });
        lastSectionOrder = [...group1, ...group2];
        renderSections(lastSectionOrder);
      }
      sectionSearch.oninput = () => {
        filterSections();
        clearSearchBtn.style.display = sectionSearch.value ? 'inline' : 'none';
      };
      clearSearchBtn.onclick = () => {
        sectionSearch.value = '';
        filterSections();
        clearSearchBtn.style.display = 'none';
      };

      // Toggle delete icons in folder and question lists
      toggleDeleteBtn.onclick = () => {
        deleteMode = !deleteMode;
        renderFolders();
        renderSections(lastSectionOrder);
      };

      addFolderBtn.onclick=async()=>{ let name=newFolderName.value.trim(); if(!name)return alert('Folder name cannot be empty'); data.folders.push({ name, sections: []}); newFolderName.value=''; await saveData(); renderFolders(); };
      addFillBtn.onclick=async()=>{
        if(currentFolder===null)return alert('Select a folder first');
        const fillTitle = prompt('Enter question title:');
        if (fillTitle === null) return;
        let sec={ type:'fill', title: fillTitle.trim(), rawText:'', hidden:[], alts:{} };
        data.folders[currentFolder].sections.push(sec);
        currentSection=data.folders[currentFolder].sections.length-1;
        await saveData();
        renderSections(lastSectionOrder);
        enterEdit();
        loadSection();
      };

      addLabelBtn.onclick = async () => {
        if (currentFolder === null) return alert('Select a folder first');
        const labelTitle = prompt('Enter question title:');
        if (labelTitle === null) return;
        // Create placeholder label question immediately
        const q = { type:'label', title: labelTitle.trim(), rawText:'', hidden:[], alts:{}, image:'', labels:[], definitions:[], arrows:[] };
        data.folders[currentFolder].sections.push(q);
        currentSection = data.folders[currentFolder].sections.length - 1;
        await saveData();
        renderFolders();
        renderSections(lastSectionOrder);
        enterEdit();
        loadSection();
        // Now prompt user for image input
        if (confirm('Press OK to paste an image from clipboard, or Cancel to select a file from your computer.')) {
          waitingForImagePaste = true;
          alert('Now paste the image from your clipboard.');
        } else {
          labelImageInput.click();
        }
      };
      labelImageInput.onchange = async e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async () => {
          const sec = data.folders[currentFolder].sections[currentSection];
          sec.image = reader.result;
          await saveData();
          renderFolders();
          renderSections(lastSectionOrder);
          enterEdit();
          loadSection();
        };
        reader.readAsDataURL(file);
        e.target.value = '';
      };

      // Allow pasting an image to update the current label question
      document.addEventListener('paste', async e => {
        if (!waitingForImagePaste) return;
        if (currentFolder === null) return;
        const items = e.clipboardData && e.clipboardData.items;
        if (!items) return;
        for (let item of items) {
          if (item.type.indexOf('image') !== -1) {
            const blob = item.getAsFile();
            const reader = new FileReader();
            reader.onload = async () => {
              const sec = data.folders[currentFolder].sections[currentSection];
              sec.image = reader.result;
              await saveData();
              renderFolders();
              renderSections(lastSectionOrder);
              enterEdit();
              loadSection();
            };
            reader.readAsDataURL(blob);
            waitingForImagePaste = false;
            e.preventDefault();
            break;
          }
        }
      });

      function ensureSelection(){ if(currentFolder===null||currentSection===null){ alert('Select a folder and a section first'); return false;} return true; }
      // Quill will override this function below after Quill is initialized.
      function loadSection(){
        const sec = data.folders[currentFolder].sections[currentSection];
        // Update header to show current section title
        let titleText = '';
        if (sec.type === 'acronym') {
          titleText = sec.acronym;
        } else if (sec.type === 'label') {
          const raw = sec.rawText || '';
          const defaultTitle = raw.split('\n')[0].trim() || 'Label Question';
          titleText = sec.title && sec.title.trim() ? sec.title : defaultTitle;
        } else {
          const defaultTitle = (sec.rawText && sec.rawText.split('\n')[0].trim()) || '(untitled)';
          titleText = sec.title && sec.title.trim() ? sec.title : defaultTitle;
        }
        document.getElementById('header').textContent = titleText;
        // Hide all main editors
        if (editorDiv) editorDiv.style.display = previewDiv.style.display = labelEditor.style.display = 'none';
        altContainer.style.display = 'none';

        if (sec.type === 'acronym') {
          labelEditor.style.display = 'block';
          labelEditor.innerHTML = '<h4 style="font-size:1.5rem; margin-bottom:0.75rem;">' + sec.acronym + '</h4><div id="acroEditor"></div>';
          // (rest unchanged)
          // ...acronym editor code...
          const baseCh = 12;
          const answerLengths = sec.entries.map(e => (e.answer||'').length + 2);
          const maxAnswerCh = Math.max(baseCh, ...answerLengths);
          const extraLengths = sec.entries.map(e => (e.extra||'').length + 2);
          const maxExtraCh = Math.max(baseCh, ...extraLengths);
          const acroEditor = document.getElementById('acroEditor');
          acroEditor.innerHTML = '';
          sec.entries.forEach((e, i) => {
            const row = document.createElement('div');
            row.style.marginBottom = '8px';
            row.innerHTML = `
              <strong style="display:inline-block; width:1.5em; text-align:center; margin-right:0.75em; font-size:1.2rem; line-height:1.2;">${e.letter}:</strong>
              <input type="text" placeholder="Answer" id="ans${i}" value="${e.answer}" style="font-size:1.2rem; line-height:1.2; padding:4px; width:${maxAnswerCh}ch;">
              <input type="text" placeholder="Extra info" id="ext${i}" value="${e.extra}" style="font-size:1.2rem; line-height:1.2; padding:4px; margin-left:0.75em; width:${maxExtraCh}ch;">
            `;
            acroEditor.appendChild(row);
            ['ans','ext'].forEach(pref => {
              document.getElementById(pref + i).oninput = evt => {
                if (pref === 'ans') sec.entries[i].answer = evt.target.value;
                else sec.entries[i].extra = evt.target.value;
                saveData();
              };
            });
          });
          return;
        }
        if (sec.type === 'label') {
          // (unchanged label editor code)
          // ...label editor code...
          labelEditor.style.display = 'block';
          labelEditor.innerHTML = `
            <div id="labelContainer" style="position:relative; display:inline-block; overflow:auto;">
              <img id="labelImg" src="${sec.image}" style="display:block; user-select:none;">
              <div id="labelOverlay" style="position:absolute; top:0; left:0; width:100%; height:100%;"></div>
            </div>`;
          // (rest unchanged)
          // ...rest of label editor code...
          // -- Definitions UI Start --
          const addDefBtn = document.createElement('button');
          addDefBtn.id = 'addDefinitionBtn';
          addDefBtn.textContent = 'Add Definition';
          addDefBtn.style.display = 'block';
          addDefBtn.style.padding = '6px 12px';
          addDefBtn.style.border = 'none';
          addDefBtn.style.borderRadius = '4px';
          addDefBtn.style.background = '#2980b9';
          addDefBtn.style.color = '#fff';
          addDefBtn.style.cursor = 'pointer';
          addDefBtn.addEventListener('click', () => {
            isAddingDefinition = true;
            addDefBtn.textContent = 'Click a label to define';
          });
          labelEditor.appendChild(addDefBtn);
          const defContainer = document.createElement('div');
          defContainer.id = 'labelDefinitions';
          defContainer.className = 'definition-list';
          defContainer.style.padding = '12px';
          defContainer.style.border = '1px solid #bdc3c7';
          defContainer.style.background = '#fff';
          labelEditor.appendChild(defContainer);
          updateDefPosition();
          // Render existing definitions with full mini‑fill functionality
          sec.definitions = sec.definitions || [];
          sec.definitions.forEach((def, dIndex) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'definition-wrapper';
            wrapper.draggable = true;
            // Drag-and-drop handlers to reorder definitions
            wrapper.addEventListener('dragstart', e => {
              if (e.target.tagName.toLowerCase() === 'textarea') {
                e.preventDefault();
                return;
              }
              e.dataTransfer.setData('text/plain', dIndex);
            });
            wrapper.addEventListener('dragover', e => e.preventDefault());
            wrapper.addEventListener('drop', e => {
              e.preventDefault();
              const from = Number(e.dataTransfer.getData('text/plain'));
              const to = dIndex;
              const moved = sec.definitions.splice(from, 1)[0];
              sec.definitions.splice(to, 0, moved);
              saveData();
              loadSection();
            });
            // —— title row + delete button ——
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            const h4 = document.createElement('h4');
            h4.textContent = (dIndex + 1) + '. ' + def.labelText;
            h4.style.fontSize = '1.1rem';
            h4.style.flex = '1';
            row.appendChild(h4);
            const del = document.createElement('span');
            del.textContent = '✖';
            del.style.cursor = 'pointer';
            del.style.color  = 'red';
            del.onclick = evt => {
              evt.stopPropagation();
              if (confirm('Delete this definition?')) {
                sec.definitions.splice(dIndex, 1);
                saveData();
                loadSection();
              }
            };
            row.appendChild(del);
            wrapper.appendChild(row);
            const ta = document.createElement('textarea');
            ta.style.width = '100%';
            ta.style.minHeight = '60px';
            ta.style.height = 'auto';
            ta.style.overflow = 'hidden';
            ta.style.fontSize = '1.1rem';
            ta.value = def.rawText;
            ta.addEventListener('mousedown', () => { wrapper.draggable = false; });
            ta.addEventListener('mouseup',   () => { wrapper.draggable = true; });
            const prevDiv = document.createElement('div');
            prevDiv.style.marginTop = '8px';
            const altDiv  = document.createElement('div');
            altDiv.style.marginTop  = '12px';
            function adjustDefHeight() {
              ta.style.height = 'auto';
              ta.style.height = ta.scrollHeight + 'px';
            }
            ta.addEventListener('input', () => {
              adjustDefHeight();
              def.rawText = ta.value;
              saveData();
              buildDefinitionPreview(def, prevDiv, altDiv);
            });
            adjustDefHeight();
            wrapper.appendChild(ta);
            wrapper.appendChild(prevDiv);
            wrapper.appendChild(altDiv);
            buildDefinitionPreview(def, prevDiv, altDiv);
            defContainer.appendChild(wrapper);
          });
          // (rest unchanged, image/label/arrow logic)
          const img = document.getElementById('labelImg');
          const overlay = document.getElementById('labelOverlay');
          const container = document.getElementById('labelContainer');
          if (window.ResizeObserver) {
            new ResizeObserver(updateDefPosition).observe(container);
          }
          container.style.resize = 'none';
          if (sec.imgX != null && sec.imgY != null) {
            container.style.position = 'absolute';
            container.style.left = sec.imgX + 'px';
            container.style.top = sec.imgY + 'px';
          } else {
            container.style.position = 'relative';
          }
          let lastContextTime = 0;
          container.addEventListener('contextmenu', e => {
            e.preventDefault();
            const now = Date.now();
            if (now - lastContextTime < 400) {
              const existing = container.querySelector('#resizeHandle');
              if (existing) {
                existing.remove();
              } else {
                const handle = document.createElement('div');
                handle.id = 'resizeHandle';
                handle.style.position = 'absolute';
                handle.style.width = '16px';
                handle.style.height = '16px';
                handle.style.bottom = '0';
                handle.style.right = '0';
                handle.style.background = '#3498db';
                handle.style.cursor = 'se-resize';
                handle.style.zIndex = '1000';
                container.appendChild(handle);
                handle.addEventListener('mousedown', ev => {
                  ev.preventDefault();
                  const startX = ev.clientX;
                  const startY = ev.clientY;
                  const startW = container.offsetWidth;
                  const startH = container.offsetHeight;
                  function onMouseMove(moveEv) {
                    container.style.width = (startW + (moveEv.clientX - startX)) + 'px';
                    container.style.height = (startH + (moveEv.clientY - startY)) + 'px';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                  }
                  function onMouseUp() {
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    sec.imgWidth = container.offsetWidth;
                    sec.imgHeight = container.offsetHeight;
                    saveData();
                    updateDefPosition();
                  }
                  document.addEventListener('mousemove', onMouseMove);
                  document.addEventListener('mouseup', onMouseUp);
                });
              }
            }
            lastContextTime = now;
          });
          container.addEventListener('mousedown', e => {
            if (e.button !== 0 || e.target !== container) return;
            e.preventDefault();
            let startX = e.clientX, startY = e.clientY;
            let origLeft = parseInt(container.style.left) || 0;
            let origTop = parseInt(container.style.top) || 0;
            function onMouseMove(ev) {
              container.style.left = origLeft + (ev.clientX - startX) + 'px';
              container.style.top = origTop + (ev.clientY - startY) + 'px';
            }
            function onMouseUp() {
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              sec.imgX = parseInt(container.style.left) || 0;
              sec.imgY = parseInt(container.style.top) || 0;
              saveData();
              updateDefPosition();
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          });
          img.onload = () => {
            if (sec.imgWidth && sec.imgHeight) {
              container.style.width = sec.imgWidth + 'px';
              container.style.height = sec.imgHeight + 'px';
              img.style.width = '100%';
              img.style.height = 'auto';
            } else {
              container.style.width = img.naturalWidth + 'px';
              container.style.height = img.naturalHeight + 'px';
            }
            updateDefPosition();
          };
          overlay.ondblclick = evt => {
            if (evt.metaKey) return;
            const rect = img.getBoundingClientRect();
            const x = evt.clientX - rect.left;
            const y = evt.clientY - rect.top;
            const text = prompt('Enter label text:');
            if (text) {
              sec.labels.push({ x, y, text, fontSize: 16 });
              saveData();
              loadSection();
            }
          };
          sec.labels.forEach(lbl => {
            const mark = document.createElement('div');
            mark.textContent = lbl.text;
            mark.style.position = 'absolute';
            mark.style.display = 'inline-block';
            mark.style.padding = '2px 4px';
            mark.style.left = lbl.x + 'px';
            mark.style.top = lbl.y + 'px';
            mark.style.background = '#ffffff';
            mark.style.border        = '1px solid #7f8c8d';
            mark.style.overflow      = 'auto';
            mark.style.whiteSpace    = 'nowrap';
            mark.style.textOverflow  = 'ellipsis';
            mark.style.cursor = 'move';
            mark.style.resize = 'both';
            mark.style.userSelect = 'none';
            mark.style.webkitUserSelect = 'none';
            mark.style.msUserSelect = 'none';
            let defIdx = -1;
            if (sec.definitions && sec.definitions.length) {
              defIdx = sec.definitions.findIndex(d => d.labelText === lbl.text);
            }
            if (defIdx >= 0) {
              const num = document.createElement('span');
              num.textContent = defIdx + 1;
              num.style.position = 'absolute';
              num.style.left = '-18px';
              num.style.top = '0';
              num.style.width = '16px';
              num.style.height = '16px';
              num.style.borderRadius = '50%';
              num.style.background = '#1abc9c';
              num.style.color = '#fff';
              num.style.fontSize = '10px';
              num.style.display = 'flex';
              num.style.alignItems = 'center';
              num.style.justifyContent = 'center';
              num.style.pointerEvents = 'none';
              mark.appendChild(num);
            }
            mark.addEventListener('click', evt => {
              if (!isAddingDefinition) return;
              evt.stopPropagation();
              sec.definitions = sec.definitions || [];
              sec.definitions.push({
                labelText: lbl.text,
                rawText: '',
                hidden: [],
                alts: {}
              });
              saveData();
              isAddingDefinition = false;
              addDefBtn.textContent = 'Add Definition';
              loadSection();
            });
            overlay.appendChild(mark);
            mark.style.width = (lbl.w || mark.offsetWidth) + 'px';
            mark.style.height = (lbl.h || mark.offsetHeight) + 'px';
            mark.style.fontSize = lbl.fontSize + 'px';
            mark.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
            mark.addEventListener('mouseup', () => {
              lbl.w = mark.offsetWidth;
              lbl.h = mark.offsetHeight;
              saveData();
            });
            mark.ondblclick = evt => {
              evt.stopPropagation();
              evt.preventDefault();
              const newText = prompt('Edit label text:', lbl.text);
              if (newText !== null) {
                lbl.text = newText;
                mark.textContent = lbl.text;
                lbl.w = mark.offsetWidth;
                lbl.h = mark.offsetHeight;
                mark.style.width = lbl.w + 'px';
                mark.style.height = lbl.h + 'px';
                saveData();
              }
            };
            mark.oncontextmenu = evt => {
              evt.preventDefault();
              evt.stopPropagation();
              const input = prompt('Font size in px:', lbl.fontSize);
              const newSize = parseInt(input, 10);
              if (!isNaN(newSize) && newSize > 0) {
                lbl.fontSize = newSize;
                mark.style.fontSize = lbl.fontSize + 'px';
                lbl.w = mark.offsetWidth;
                lbl.h = mark.offsetHeight;
                mark.style.width = lbl.w + 'px';
                mark.style.height = lbl.h + 'px';
                saveData();
              }
            };
            mark.onmousedown = evt => {
              if (evt.button !== 0) return;
              evt.preventDefault();
              let startX = evt.clientX, startY = evt.clientY;
              const origX = lbl.x, origY = lbl.y;
              function onMouseMove(e) {
                lbl.x = origX + (e.clientX - startX);
                lbl.y = origY + (e.clientY - startY);
                mark.style.left = lbl.x + 'px';
                mark.style.top = lbl.y + 'px';
              }
              function onMouseUp(e) {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                saveData();
              }
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            };
          });
          let svgOverlay = overlay.querySelector('svg');
          if (!svgOverlay) {
            svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svgOverlay.setAttribute('style', 'position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;');
            overlay.appendChild(svgOverlay);
          } else {
            while (svgOverlay.firstChild) svgOverlay.removeChild(svgOverlay.firstChild);
          }
          if (sec.arrows) {
            sec.arrows.forEach((a, idx) => {
              const angle = Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
              const arrowLength = a.width * 3;
              const arrowWidth = a.width * 2;
              const lineEndX = a.x2 - arrowLength * Math.cos(angle);
              const lineEndY = a.y2 - arrowLength * Math.sin(angle);
              const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              line.setAttribute('x1', a.x1);
              line.setAttribute('y1', a.y1);
              line.setAttribute('x2', lineEndX);
              line.setAttribute('y2', lineEndY);
              line.setAttribute('stroke', a.color);
              line.setAttribute('stroke-width', a.width);
              line.setAttribute('pointer-events', 'all');
              svgOverlay.appendChild(line);
              const xBase1 = a.x2 - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
              const yBase1 = a.y2 - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);
              const xBase2 = a.x2 - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
              const yBase2 = a.y2 - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
              const points = `${a.x2},${a.y2} ${xBase1},${yBase1} ${xBase2},${yBase2}`;
              const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
              polygon.setAttribute('points', points);
              polygon.setAttribute('fill', a.color);
              polygon.setAttribute('pointer-events', 'all');
              svgOverlay.appendChild(polygon);
              [line, polygon].forEach(el => {
                el.addEventListener('contextmenu', evt => {
                  if (!evt.metaKey) return;
                  evt.preventDefault();
                  if (confirm('Delete this arrow?')) {
                    sec.arrows.splice(idx, 1);
                    saveData();
                    loadSection();
                    return;
                  }
                });
                el.addEventListener('dblclick', evt => {
                  try {
                    if (!evt.metaKey) return;
                    evt.preventDefault();
                    const existingPopup = document.getElementById('arrowEditPopup');
                    if (existingPopup) existingPopup.remove();
                    const popup = document.createElement('div');
                    popup.id = 'arrowEditPopup';
                    popup.style.position = 'absolute';
                    const overlayRect = overlay.getBoundingClientRect();
                    const fixedLeft = overlayRect.left + 50;
                    const fixedTop = overlayRect.top + 50;
                    popup.style.left = `${fixedLeft}px`;
                    popup.style.top = `${fixedTop}px`;
                    popup.style.transform = 'translate(-50%, -100%)';
                    popup.style.transformOrigin = 'bottom center';
                    popup.style.background = '#fff';
                    popup.style.border = '1px solid #7f8c8d';
                    popup.style.borderRadius = '4px';
                    popup.style.padding = '8px';
                    popup.style.zIndex = '10000';
                    popup.innerHTML = `
                      <label style="display:block;font-size:0.9rem;margin-bottom:4px;">
                        Color: <input type="color" id="arrowColorPicker" value="${a.color}">
                      </label>
                      <label style="display:block;font-size:0.9rem;margin-bottom:4px;">
                        Width: <input type="number" id="arrowWidthPicker" min="1" value="${a.width}" style="width:50px;">
                      </label>
                      <div style="text-align:right;">
                        <button id="arrowSaveBtn" style="margin-right:4px;">Save</button>
                        <button id="arrowCancelBtn">Cancel</button>
                      </div>
                    `;
                    popup.addEventListener('dblclick', evt2 => {
                      evt2.stopPropagation();
                    });
                    overlay.appendChild(popup);
                    document.getElementById('arrowSaveBtn').onclick = () => {
                      const colorVal = document.getElementById('arrowColorPicker').value;
                      const widthVal = parseFloat(document.getElementById('arrowWidthPicker').value);
                      if (colorVal && !isNaN(widthVal) && widthVal > 0) {
                        sec.arrows[idx].color = colorVal;
                        sec.arrows[idx].width = widthVal;
                        saveData();
                        loadSection();
                      }
                    };
                    document.getElementById('arrowCancelBtn').onclick = () => {
                      popup.remove();
                    };
                  } catch (err) {
                    console.error('Arrow popup handler error:', err);
                  }
                });
              });
            });
          }
          let drawing = false;
          let startX = 0, startY = 0;
          let tempLine = null;
          overlay.addEventListener('mousedown', evt => {
            if (!evt.metaKey || evt.button !== 0) return;
            const rect = img.getBoundingClientRect();
            startX = evt.clientX - rect.left;
            startY = evt.clientY - rect.top;
            drawing = true;
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempLine.setAttribute('x1', startX);
            tempLine.setAttribute('y1', startY);
            tempLine.setAttribute('x2', startX);
            tempLine.setAttribute('y2', startY);
            tempLine.setAttribute('stroke', '#e74c3c');
            tempLine.setAttribute('stroke-width', '2');
            svgOverlay.appendChild(tempLine);
            evt.preventDefault();
          });
          overlay.addEventListener('mousemove', evt => {
            if (!drawing) return;
            const rect = img.getBoundingClientRect();
            const currX = evt.clientX - rect.left;
            const currY = evt.clientY - rect.top;
            tempLine.setAttribute('x2', currX);
            tempLine.setAttribute('y2', currY);
          });
          document.addEventListener('mouseup', evt => {
            if (!drawing) return;
            drawing = false;
            const rect = img.getBoundingClientRect();
            const endX = evt.clientX - rect.left;
            const endY = evt.clientY - rect.top;
            svgOverlay.removeChild(tempLine);
            tempLine = null;
            if (endX !== startX || endY !== startY) {
              if (!sec.arrows) sec.arrows = [];
              sec.arrows.push({ x1: startX, y1: startY, x2: endX, y2: endY, color: '#e74c3c', width: 2 });
              saveData();
              loadSection();
            }
          });
          return;
        }
        // Reset Quill history *before* loading new content
        quill.history.clear();
        const html = sec.rawHtml || sec.rawText || '';
        // Load the HTML silently so it does not create an undo entry
        quill.setContents(quill.clipboard.convert(html), 'silent');
        adjustEditorHeight();  // ensure editor resizes for existing content
        // Run a second resize on next tick so Quill gets a chance to lay out its HTML
        setTimeout(() => requestAnimationFrame(adjustEditorHeight), 0);
        previewSection();
        // Migrate old sections using rawText into rawHtml for new formatting features
        if (!sec.rawHtml && sec.rawText) {
          sec.rawHtml = quill.root.innerHTML;
          saveData();
        }
        if (editorDiv) editorDiv.style.display = 'block';
        previewDiv.style.display = 'block';
        // The Quill version of loadSection will override the editor loading.
      }
      previewBtn.onclick=()=>{ if(!ensureSelection())return; previewSection(); };
      // Normalize sec.hidden entries to objects { word, occ }
      function getHiddenEntries(sec, tokens) {
        const entries = Array.isArray(sec.hidden) ? sec.hidden : [];
        const wordCounts = {};
        tokens.forEach(t => {
          const w = t.trim();
          if (w) wordCounts[w] = (wordCounts[w] || 0) + 1;
        });

        const cleaned = [];
        entries.forEach(entry => {
          let obj = null;
          if (typeof entry === 'number') {
            if (entry >= 0 && entry < tokens.length) {
              const word = tokens[entry].trim();
              let occ = 0;
              for (let i = 0; i <= entry; i++) {
                if (tokens[i].trim() === word) occ++;
              }
              obj = { word, occ };
            }
          } else if (entry && typeof entry.word === 'string' && Number.isInteger(entry.occ)) {
            obj = entry;
          }
          if (!obj) return;
          const count = wordCounts[obj.word] || 0;
          if (obj.occ <= count) {
            cleaned.push(obj);
          } else if (sec.alts) {
            delete sec.alts[`${obj.word}_${obj.occ}`];
          }
        });

        const seen = new Set();
        const result = [];
        cleaned.forEach(o => {
          const key = `${o.word}_${o.occ}`;
          if (!seen.has(key)) {
            seen.add(key);
            result.push(o);
          }
        });
        sec.hidden = result;
        return result;
      }

      // Extract tokens from a section's rawHtml/rawText the same way the preview
      // builder does, so blank occurrence counts stay consistent across modes
      function extractTokens(sec) {
        if (sec.rawHtml) {
          const tmp = document.createElement('div');
          tmp.innerHTML = sec.rawHtml;
          let toks = [];
          tmp.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
              toks.push(...node.textContent.split(/(\s+)/));
            } else if (node.nodeType === Node.ELEMENT_NODE) {
              if (node.tagName === 'P' || node.tagName === 'DIV') {
                node.childNodes.forEach(child => {
                  if (child.nodeType === Node.TEXT_NODE) {
                    toks.push(...child.textContent.split(/(\s+)/));
                  } else if (child.nodeType === Node.ELEMENT_NODE && child.tagName === 'BR') {
                    toks.push('\n');
                  } else if (child.nodeType === Node.ELEMENT_NODE) {
                    toks.push(...(child.innerText || '').split(/(\s+)/));
                  }
                });
                toks.push('\n');
              } else if (node.tagName === 'BR') {
                toks.push('\n');
              } else if (node.tagName === 'UL') {
                node.childNodes.forEach(li => {
                  if (li.nodeType !== Node.ELEMENT_NODE || li.tagName !== 'LI') return;
                  const liTokens = (li.innerText || '').split(/(\s+)/);
                  liTokens.forEach(t => {
                    const trimmed = t.trim();
                    if (!trimmed || trimmed === '•') return;
                    toks.push(t);
                  });
                });
              } else {
                toks.push(...(node.innerText || '').split(/(\s+)/));
              }
            }
          });
          return toks.filter(t => t.length > 0);
        }
        return (sec.rawText || '').split(/(\s+)/).filter(t => t.length > 0);
      }

      function previewSection() {
        const sec = data.folders[currentFolder].sections[currentSection];
        // Use rawHtml if present, otherwise convert rawText to HTML with paragraphs
        const text = sec.rawHtml
          ? (new DOMParser().parseFromString(sec.rawHtml, 'text/html')).body.innerHTML
          : (sec.rawText || '').split('\n').map(line => `<p>${line}</p>`).join('');
        // Now render the preview preserving <p> and <br> structure
        previewDiv.innerHTML = '';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;

        let counts = {};
        sec.hidden = sec.hidden || [];
        sec.alts = sec.alts || {};
        // Helper to get hidden entries for a flat list of tokens
        function getHiddenEntriesForTokens(tokens) {
          return getHiddenEntries(sec, tokens);
        }

        // Collect all tokens for hidden word occurrence counting
        let allTokens = [];
        tempDiv.childNodes.forEach(node => {
          if (node.nodeType === Node.TEXT_NODE) {
            // Split text by whitespace for tokens
            allTokens.push(...node.textContent.split(/(\s+)/));
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.tagName === 'P' || node.tagName === 'DIV') {
              node.childNodes.forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                  allTokens.push(...child.textContent.split(/(\s+)/));
                } else if (child.nodeType === Node.ELEMENT_NODE && child.tagName === 'BR') {
                  allTokens.push('\n');
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                  allTokens.push(...(child.innerText||'').split(/(\s+)/));
                }
              });
              allTokens.push('\n');
            } else if (node.tagName === 'BR') {
              allTokens.push('\n');
            } else if (node.tagName === 'UL') {
              // Add tokens from each list item, skipping the leading bullet glyph
              node.childNodes.forEach(liNode => {
                if (liNode.nodeType !== Node.ELEMENT_NODE || liNode.tagName !== 'LI') return;
                const toks = (liNode.innerText || '').split(/(\s+)/);
                toks.forEach(t => {
                  const trimmed = t.trim();
                  if (!trimmed || trimmed === '•') return;
                  allTokens.push(t);
                });
              });
            } else {
              allTokens.push(...(node.innerText||'').split(/(\s+)/));
            }
          }
        });
        // Remove empty tokens
        allTokens = allTokens.filter(t => t.length > 0);
        const hiddenEntries = getHiddenEntries(sec, allTokens);
        // We'll use a running count per word for the preview rendering
        let globalCounts = {};

        tempDiv.childNodes.forEach(node => {
          if (node.nodeType === Node.TEXT_NODE) {
            // Render text node tokens
            const tokens = node.textContent.split(/(\s+)/);
            tokens.forEach(tok => {
              if (!tok.trim()) {
                previewDiv.appendChild(document.createTextNode(tok));
              } else {
                const w = tok.trim();
                globalCounts[w] = (globalCounts[w] || 0) + 1;
                const occ = globalCounts[w];
                const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);
                const span = document.createElement('span');
                span.className = 'word' + (isHidden ? ' hidden' : '');
                span.textContent = isHidden ? '_'.repeat(tok.length) : tok;
                span.onclick = () => {
                  const idx = hiddenEntries.findIndex(e => e.word === w && e.occ === occ);
                  if (idx >= 0) hiddenEntries.splice(idx, 1);
                  else hiddenEntries.push({ word: w, occ });
                  sec.hidden = hiddenEntries;
                  saveData();
                  previewSection();
                };
                previewDiv.appendChild(span);
              }
            });
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.tagName === 'UL') {
              // Flatten each list item into its own preview line with a bullet
              node.childNodes.forEach(liNode => {
                if (liNode.nodeType !== Node.ELEMENT_NODE || liNode.tagName !== 'LI') return;

                const line = document.createElement('p');
                line.className = 'preview-line';

                // Actual bullet character
                const bulletSpan = document.createElement('span');
                bulletSpan.textContent = '• ';
                line.appendChild(bulletSpan);

                const liTokens = (liNode.innerText || '').split(/(\s+)/);
                liTokens.forEach(tok => {
                  if (!tok.trim()) {
                    line.appendChild(document.createTextNode(tok));
                  } else {
                    const w = tok.trim();
                    globalCounts[w] = (globalCounts[w] || 0) + 1;
                    const occ = globalCounts[w];
                    const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);

                    const span = document.createElement('span');
                    span.className = 'word' + (isHidden ? ' hidden' : '');
                    span.textContent = isHidden ? '_'.repeat(tok.length) : tok;
                    span.onclick = () => {
                      const idx = hiddenEntries.findIndex(e => e.word === w && e.occ === occ);
                      if (idx >= 0) hiddenEntries.splice(idx, 1);
                      else hiddenEntries.push({ word: w, occ });
                      sec.hidden = hiddenEntries;
                      saveData();
                      previewSection();
                    };
                    line.appendChild(span);
                  }
                });

                previewDiv.appendChild(line);
              });
            } else if (node.tagName === 'P' || node.tagName === 'DIV') {
              const para = document.createElement('p');
              para.className = 'preview-line';
              node.childNodes.forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                  // Render tokens in text node
                  const tokens = child.textContent.split(/(\s+)/);
                  tokens.forEach(tok => {
                    if (!tok.trim()) {
                      para.appendChild(document.createTextNode(tok));
                    } else {
                      const w = tok.trim();
                      globalCounts[w] = (globalCounts[w] || 0) + 1;
                      const occ = globalCounts[w];
                      const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);
                      const span = document.createElement('span');
                      span.className = 'word' + (isHidden ? ' hidden' : '');
                      span.textContent = isHidden ? '_'.repeat(tok.length) : tok;
                      span.onclick = () => {
                        const idx = hiddenEntries.findIndex(e => e.word === w && e.occ === occ);
                        if (idx >= 0) hiddenEntries.splice(idx, 1);
                        else hiddenEntries.push({ word: w, occ });
                        sec.hidden = hiddenEntries;
                        saveData();
                        previewSection();
                      };
                      para.appendChild(span);
                    }
                  });
                } else if (child.nodeType === Node.ELEMENT_NODE && child.tagName === 'BR') {
                  para.appendChild(document.createElement('br'));
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                  // For inline elements: render as text
                  const tokens = (child.innerText||'').split(/(\s+)/);
                  tokens.forEach(tok => {
                    if (!tok.trim()) {
                      para.appendChild(document.createTextNode(tok));
                    } else {
                      const w = tok.trim();
                      globalCounts[w] = (globalCounts[w] || 0) + 1;
                      const occ = globalCounts[w];
                      const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);
                      const span = document.createElement('span');
                      span.className = 'word' + (isHidden ? ' hidden' : '');
                      span.textContent = isHidden ? '_'.repeat(tok.length) : tok;
                      span.onclick = () => {
                        const idx = hiddenEntries.findIndex(e => e.word === w && e.occ === occ);
                        if (idx >= 0) hiddenEntries.splice(idx, 1);
                        else hiddenEntries.push({ word: w, occ });
                        sec.hidden = hiddenEntries;
                        saveData();
                        previewSection();
                      };
                      para.appendChild(span);
                    }
                  });
                }
              });
              previewDiv.appendChild(para);
              // Do not add <br> after each block, as spacing is handled by .preview-line
            } else if (node.tagName === 'BR') {
              previewDiv.appendChild(document.createElement('br'));
            }
          }
        });

        // Build alternate-answer inputs for hidden words
        altContainer.innerHTML = '<h4>Alternate answers for blanks (comma-separated):</h4>';
        altContainer.style.display = 'block';
        // For each unique hidden entry (by word+occurrence), show input
        const sortedAlts = hiddenEntries.slice().sort((a,b)=>{
          const wComp = a.word.localeCompare(b.word);
          if (wComp !== 0) return wComp;
          return a.occ - b.occ;
        });
        let altCounts = {};
        sortedAlts.forEach(({ word, occ }) => {
          altCounts[word] = (altCounts[word] || 0) + 1;
          if (altCounts[word] === occ) {
            const key = `${word}_${occ}`;
            const label = document.createElement('label');
            label.textContent = `${word} #${occ}: `;
            const ai = document.createElement('input');
            ai.className = 'alt-input';
            ai.placeholder = 'alt1, alt2, …';
            ai.value = (sec.alts[key] || []).join(', ');
            ai.oninput = () => {
              sec.alts[key] = ai.value.split(',').map(s => s.trim()).filter(Boolean);
              saveData();
            };
            altContainer.appendChild(label);
            altContainer.appendChild(ai);
          }
        });
      }

      // —— Helper: build preview & alternate‑answer UI for a single definition ——
      function buildDefinitionPreview(defObj, previewDiv, altDiv) {
        const tokens = (defObj.rawText || '').split(/(\s+)/);
        defObj.hidden = defObj.hidden || [];
        defObj.alts   = defObj.alts   || {};

        const hiddenEntries = getHiddenEntries(defObj, tokens);
        previewDiv.innerHTML = '';
        altDiv.innerHTML     = '<h4>Alternate answers (comma‑separated):</h4>';

        // clickable words
        let counts = {};
        tokens.forEach(tok => {
          if (!tok.trim()) {
            // Preserve newlines
            if (tok.includes('\n')) {
              const lines = tok.split('\n');
              lines.forEach((ln, idx) => {
                if (ln) previewDiv.appendChild(document.createTextNode(ln));
                if (idx < lines.length - 1) previewDiv.appendChild(document.createElement('br'));
              });
            } else {
              previewDiv.appendChild(document.createTextNode(tok));
            }
            return;
          }
          const w = tok.trim();
          counts[w] = (counts[w] || 0) + 1;
          const occ = counts[w];
          const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);

          const span = document.createElement('span');
          span.className = 'word' + (isHidden ? ' hidden' : '');
          span.textContent = isHidden ? '_'.repeat(tok.length) : tok;
          span.onclick = () => {
            const idx = hiddenEntries.findIndex(e => e.word === w && e.occ === occ);
            (idx >= 0)
              ? hiddenEntries.splice(idx, 1)
              : hiddenEntries.push({ word: w, occ });
            defObj.hidden = hiddenEntries;
            saveData();
            buildDefinitionPreview(defObj, previewDiv, altDiv); // re-render
          };
          previewDiv.appendChild(span);
        });

        // alternate‑answer inputs
        counts = {};
        tokens.forEach(tok => {
          if (!tok.trim()) return;
          const w = tok.trim();
          counts[w] = (counts[w] || 0) + 1;
          const occ = counts[w];
          const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);
          if (!isHidden) return;

          const key = `${w}_${occ}`;
          const label = document.createElement('label');
          label.textContent = `${w} #${occ}: `;
          const ai = document.createElement('input');
          ai.className  = 'alt-input';
          ai.placeholder = 'alt1, alt2 …';
          ai.value      = (defObj.alts[key] || []).join(', ');
          ai.oninput = () => {
            defObj.alts[key] = ai.value.split(',').map(s => s.trim()).filter(Boolean);
            saveData();
          };
          altDiv.appendChild(label);
          altDiv.appendChild(ai);
        });
      }
      saveSectionBtn.onclick = async () => {
        if (!ensureSelection()) return;
        // For fill-in, rawHtml is already updated live on input.
        // Only update rawText for non-label if needed (for legacy support)
        const sec = data.folders[currentFolder].sections[currentSection];
        if (sec.type !== 'label' && !sec.rawHtml) {
          sec.rawText = editorDiv.innerText || '';
        }
        // sec.hidden is already updated in previewSection's click handler
        await saveData();
        renderSections(lastSectionOrder);
        loadSection();
        alert('Section saved ✔️');
      };


      editModeBtn.onclick = () => {
        isQuizMode = false;
        enterEdit();
        // Reload the current section in edit mode if one is selected
        if (currentSection !== null) {
          loadSection();
          previewSection();
        }
      };

      function enterEdit(){
        editorArea.style.display = 'block';
        quizArea.style.display = 'none';
        renderSections(lastSectionOrder);
        updateProgressIndicator();
      }
      function enterQuiz(){
          if(!isQuizMode) syncCurrentSection();
        if (currentFolder === null) {
          alert('Select a folder first');
          return;
        }
        editorArea.style.display = 'none';
        quizArea.style.display = 'block';
        startQuiz();
        updateProgressIndicator();
      }

      // Starts a random-order quiz across all sections in the current folder
      function enterRandomQuiz() {
          if(!isQuizMode) syncCurrentSection();
        isQuizMode = true;
        if (currentFolder === null) {
          alert('Select a folder first');
          return;
        }
        editorArea.style.display = 'none';
        quizArea.style.display = 'block';
        const total = data.folders[currentFolder].sections.length;
        let prog = quizProgress[currentFolder];
        if (!prog) {
          prog = quizProgress[currentFolder] = { completed: new Set(), total, order: null, pos: 0 };
        } else {
          prog.total = total;
        }

        if (prog.order && prog.order.length && prog.pos < prog.order.length) {
          quizOrder = prog.order;
          quizPos   = prog.pos;
        } else {
          const done = prog.completed;
          const order = data.folders[currentFolder].sections
            .map((_, i) => i)
            .filter(i => !done.has(i))
            .sort(() => Math.random() - 0.5);
          if (order.length === 0) {
            alert('All questions in this section already complete!');
            updateProgressIndicator();
            return;
          }
          prog.order = order;
          prog.pos   = 0;
          quizOrder   = order;
          quizPos     = 0;
        }
        saveProgress();

        updateProgressIndicator();
        showQuiz();
      }

      function enterQuizQuestion(){
        if(!ensureSelection()) return;
        editorArea.style.display='none';
        quizArea.style.display='block';
        quizOrder = [currentSection];
        quizPos = 0;
        updateProgressIndicator();
        showQuiz();
      }
      quizModeBtn.onclick = () => {
        if(!isQuizMode) syncCurrentSection();
        isQuizMode = true;
        // Show quiz for the currently selected section
        if (currentSection !== null) {
          enterQuizQuestion();
        } else {
          enterQuiz();
        }
      };
      quizAllBtn .onclick = enterRandomQuiz;

      function wrapQuizBlanks(container, hiddenEntries) {
        // Filter out invalid hidden entries (word/occ not present in text)
        const sec = data.folders[currentFolder].sections[currentSection];

        // Tokenize the section text exactly like previewSection/extractTokens
        const tokens = extractTokens(sec).map(t => t.trim()).filter(Boolean);

        const validEntries = (hiddenEntries || []).filter(({ word, occ }) => {
          const matches = tokens.filter(t => t === word);
          const isValid = occ <= matches.length;
          if (!isValid && sec.alts) {
            delete sec.alts[`${word}_${occ}`];
          }
          return isValid;
        });
        sec.hidden = validEntries;

        const sortedEntries = validEntries.slice().sort((a, b) => {
          const wComp = a.word.localeCompare(b.word);
          if (wComp !== 0) return wComp;
          return b.occ - a.occ;
        });

        sortedEntries.forEach(({ word, occ }) => {
          
          const matches = [];
          const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
          while (walker.nextNode()) {
            const node = walker.currentNode;
            if (node.parentElement.closest('.quiz-title-word')) continue;
            // Build a regex that matches the word with optional trailing punctuation
            const escaped = word.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&');
            const startsWordChar = /\w/.test(word[0]);
            const endsWordChar   = /\w/.test(word[word.length - 1]);
            let pattern = escaped;
            if (startsWordChar) pattern = '\\b' + pattern;
            if (endsWordChar)   pattern = pattern + '\\b';
            const regex = new RegExp(pattern, 'gi');
            let match;
            while ((match = regex.exec(node.textContent)) !== null) {
              // DEBUG: Log each matched node and match index
              
              matches.push({ node, index: match.index, length: match[0].length });
            }
          }

          const targetMatch = matches[occ - 1];
          // DEBUG: Log the target match for this word/occurrence
          
          if (targetMatch) {
            const { node, index, length } = targetMatch;
            const before = node.textContent.slice(0, index);
            const target = node.textContent.slice(index, index + length);
            const after = node.textContent.slice(index + length);

            const span = document.createElement('span');
            span.className = 'blank';
            span.dataset.word = target;
            span.dataset.occ = occ;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'blank-input';
            const altKey = `${word}_${occ}`;
            const answers = [word, ...(sec.alts[altKey] || [])];
            input.setAttribute('data-answer', JSON.stringify(answers));
            input.addEventListener('focus', () => { lastHintTarget = input; });
            // Removed fixed em width here

            span.appendChild(input);

            const parent = node.parentNode;
            parent.insertBefore(document.createTextNode(before), node);
            parent.insertBefore(span, node);
            parent.insertBefore(document.createTextNode(after), node);
            parent.removeChild(node);
          }
        });
      }

        function showQuiz() {
          // Advance to the correct section
          currentSection = quizOrder[quizPos];
          const prog = quizProgress[currentFolder];
          if (prog && quizOrder.length > 1) {
            prog.pos = quizPos;
            saveProgress();
          }
        // Now load that section’s data
        let sec = data.folders[currentFolder].sections[currentSection];
        updateProgressIndicator();
        // Insert consistent title at top of quizContent
        const titleText = sec.title?.trim() || sec.acronym || (sec.rawText?.split('\n')[0].trim()) || '(untitled)';
        const titleElem = document.createElement('h3');
        titleElem.innerHTML = titleText
          .split(/\s+/)
          .map(w => `<span class="quiz-title-word">${w}</span>`)
          .join(' ');
        titleElem.style.marginBottom = '16px';
        quizContent.innerHTML = '';
        quizContent.style.borderColor = '';
        quizContent.appendChild(titleElem);
        
        // Highlight current section in left panel
        renderSections(lastSectionOrder);

        if (sec.type === 'fill') {
          // quizContent already cleared and title appended above
          // Now append the fill content
          quizContent.innerHTML = '';
          quizContent.appendChild(titleElem);
          quizContent.innerHTML += sec.rawHtml || sec.rawText || '';
          const tokensArr = extractTokens(sec);
          const hiddenEntries = getHiddenEntries(sec, tokensArr);
          wrapQuizBlanks(quizContent, hiddenEntries);
          // --- Improved blank sizing using text width measurement ---
          // Create a hidden span for measuring text width
          const measure = document.createElement('span');
          Object.assign(measure.style, {
            position: 'absolute',
            visibility: 'hidden',
            whiteSpace: 'pre',
            left: '-9999px',
            top: '-9999px',
          });
          document.body.appendChild(measure);
          quizContent.querySelectorAll('.blank').forEach(wrapper => {
            const input = wrapper.querySelector('input');
            const word = wrapper.dataset.word || '';
            // Ensure measure span uses the same font metrics
            const computeFont = () => {
              measure.style.font = window.getComputedStyle(input).font;
            };
            computeFont();
            // Function to resize input based on value
            const resize = val => {
              measure.textContent = val;
              const extra = 6; // slight padding so the box isn't too tight
              input.style.width = (measure.getBoundingClientRect().width + extra) + 'px';
            };
            // Initial sizing
            resize(word);
            // Resize on each keystroke
            input.addEventListener('input', () => {
              computeFont();
              resize(input.value || wrapper.dataset.word);
            });
          });
          // Attach grading and navigation to all blanks
          quizContent.querySelectorAll('.blank input').forEach(input => {
            input.addEventListener('input', () => {
              const enteredRaw   = input.value.trim();
              const correctWord  = input.parentElement.dataset.word;
              const occ          = input.parentElement.dataset.occ;
              const section      = data.folders[currentFolder].sections[currentSection];
              const altKey       = `${correctWord}_${occ}`;
              const alts         = section.alts[altKey] || [];

              const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/g, '');
              const enteredNorm = normalize(enteredRaw);
              const correctNorm = normalize(correctWord);
              const isCorrect   = enteredNorm === correctNorm ||
                                  alts.some(a => normalize(a) === enteredNorm);

              if (enteredRaw.length === 0) {
                input.classList.remove('correct', 'incorrect');
              } else if (isCorrect) {
                input.classList.add('correct');
                input.classList.remove('incorrect');
              } else {
                input.classList.add('incorrect');
                input.classList.remove('correct');
              }

              const allInputs = Array.from(quizContent.querySelectorAll('.blank input'));
              if (allInputs.length && allInputs.every(i => i.classList.contains('correct'))) {
                quizContent.style.borderColor = '#27ae60';
                markQuestionCompleted();
              } else {
                quizContent.style.borderColor = '';
              }
            });

            input.addEventListener('keydown', e => {
              const inputs = Array.from(quizContent.querySelectorAll('.blank input'));
              const idx = inputs.indexOf(input);
              if (e.key === ' ') {
                e.preventDefault();
                if (input.classList.contains('correct') && idx < inputs.length - 1) {
                  inputs[idx + 1].focus();
                }
              }
              if (e.key === 'Backspace' && input.selectionStart === 0 && input.selectionEnd === 0 && input.value === '' && idx > 0) {
                e.preventDefault();
                const prev = inputs[idx - 1];
                prev.focus();
                const len = prev.value.length;
                prev.setSelectionRange(len, len);
              }
            });
          });
          return;
        }
        // Compute title logic for all types (already done above)
        // Update the main header to match the quiz question's title
        document.getElementById('header').textContent = titleText;
        if (sec.type === 'acronym') {
          quizContent.innerHTML = '';
          quizContent.appendChild(titleElem);
          quizContent.innerHTML += '<h4 style="font-size:1.5rem; margin-bottom:0.75rem;">' + sec.acronym + '</h4>';
          // Compute uniform widths for acronym inputs based on base and longest answer/extra
          const baseCh = 12;
          const answerLengths = sec.entries.map(e => (e.answer||'').length + 2);
          const maxAnswerCh = Math.max(baseCh, ...answerLengths);
          const extraLengths = sec.entries.map(e => (e.extra||'').length + 2);
          const maxExtraCh = Math.max(baseCh, ...extraLengths);
          sec.entries.forEach((e, i) => {
            const div = document.createElement('div');
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.margin = '4px 0';
            // Build inputs array
            let html = `<strong style="display:inline-block; width:1.5em; text-align:center; margin-right:0.75em; font-size:1.2rem; line-height:1.2;">${e.letter}:</strong>
              <input type="text" placeholder="Answer" id="qans${i}" style="padding:4px; font-size:1.2rem; line-height:1.2;">`;
            if (e.extra && e.extra.trim()) {
              html += `<input type="text" placeholder="Extra info" id="qext${i}" style="margin-left:8px; padding:4px; font-size:1.2rem; line-height:1.2;">`;
            }
            div.innerHTML = html;
            quizContent.appendChild(div);
            const inp = document.getElementById('qans' + i);
            inp.style.width = maxAnswerCh + 'ch';
            inp.oninput = () => {
              const ok = inp.value.trim().toLowerCase() === e.answer.trim().toLowerCase();
              inp.classList.toggle('correct', ok);
              inp.classList.toggle('incorrect', !ok);
            };
            let extInp = null;
            if (e.extra && e.extra.trim()) {
              extInp = document.getElementById('qext' + i);
              extInp.style.width = maxExtraCh + 'ch';
              extInp.oninput = () => {
                const okX = extInp.value.trim().toLowerCase() === e.extra.trim().toLowerCase();
                extInp.classList.toggle('correct', okX);
                extInp.classList.toggle('incorrect', !okX);
              };
            }
          });
          return;
        }
        if (sec.type === 'label') {
          quizContent.innerHTML = '';
          quizContent.appendChild(titleElem);
          const wrapper = document.createElement('div');
          wrapper.style.position = 'relative';
          const img = document.createElement('img');
          img.src = sec.image;
          if (sec.imgWidth) {
            img.style.width = sec.imgWidth + 'px';
            img.style.height = 'auto';
          } else {
            img.style.maxWidth = '100%';
          }
          wrapper.appendChild(img);

          // Create SVG overlay for arrows
          const svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svgOverlay.style.position = 'absolute';
          svgOverlay.style.top = '0';
          svgOverlay.style.left = '0';
          svgOverlay.style.width = '100%';
          svgOverlay.style.height = '100%';
          svgOverlay.style.pointerEvents = 'none';
          wrapper.appendChild(svgOverlay);

          // Draw saved arrows
          if (sec.arrows) {
            sec.arrows.forEach(a => {
              const angle = Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
              const arrowLength = a.width * 3;
              const arrowWidth = a.width * 2;
              // Compute line endpoint at base of arrowhead
              const lineEndX = a.x2 - arrowLength * Math.cos(angle);
              const lineEndY = a.y2 - arrowLength * Math.sin(angle);
              // Create line element
              const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              line.setAttribute('x1', a.x1);
              line.setAttribute('y1', a.y1);
              line.setAttribute('x2', lineEndX);
              line.setAttribute('y2', lineEndY);
              line.setAttribute('stroke', a.color);
              line.setAttribute('stroke-width', a.width);
              svgOverlay.appendChild(line);
              // Compute arrowhead points
              const xBase1 = a.x2 - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
              const yBase1 = a.y2 - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);
              const xBase2 = a.x2 - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
              const yBase2 = a.y2 - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
              const points = `${a.x2},${a.y2} ${xBase1},${yBase1} ${xBase2},${yBase2}`;
              const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
              polygon.setAttribute('points', points);
              polygon.setAttribute('fill', a.color);
              svgOverlay.appendChild(polygon);
            });
          }

          // Map labelText → { el: titleElement, idx }
          const titleMap = {};
          // Render inline inputs
          sec.labels.forEach(lbl => {
            const inp = document.createElement('input');
            inp.classList.add('blank-input');
            inp.setAttribute('data-answer', JSON.stringify([lbl.text]));
            inp.dataset.label = "1";          // mark as picture‑label blank
            inp.type = 'text';
            inp.style.position = 'absolute';
            inp.style.left = lbl.x + 'px';
            inp.style.top = lbl.y + 'px';
            // border, bg, font, etc.
            inp.style.border = '1px solid #7f8c8d';
            inp.style.background = '#ffffff';
            inp.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
            inp.style.fontSize = lbl.fontSize + 'px';
            inp.style.padding = '0';
            inp.style.boxSizing = 'border-box';
            inp.style.minWidth = '0';
            inp.style.borderRadius = '2px';
            // record focus so Hint button targets the last‑selected box
            inp.addEventListener('focus', () => { lastHintTarget = inp; });
            // size width/height to match the saved label size, or fallback to measured width
            const measSpan = document.createElement('span');
            measSpan.style.visibility = 'hidden';
            measSpan.style.position   = 'absolute';
            measSpan.style.whiteSpace = 'pre';
            measSpan.style.fontFamily = inp.style.fontFamily;
            measSpan.style.fontSize   = inp.style.fontSize;
            measSpan.textContent = lbl.text.toUpperCase();
            document.body.appendChild(measSpan);
            const calcW = lbl.w ? lbl.w : (measSpan.offsetWidth + 4);
            inp.style.width  = calcW + 'px';
            document.body.removeChild(measSpan);
            inp.style.height = (lbl.h || inp.offsetHeight) + 'px';
            inp.oninput = () => {
              const val = inp.value.trim().toLowerCase();
              const ok = val === lbl.text.trim().toLowerCase();

              if (ok) {
                // Replace the input with the revealed label text
                const txt = document.createElement('span');
                txt.textContent = lbl.text;
                txt.style.position = 'absolute';
                txt.style.left = lbl.x + 'px';
                txt.style.top  = lbl.y + 'px';
                txt.style.fontSize   = lbl.fontSize + 'px';
                txt.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                txt.style.background = '#ffffff';
                txt.style.border     = '1px solid #27ae60';
                txt.style.padding    = '0 2px';
                txt.style.borderRadius = '2px';
                if (lbl.w) txt.style.width  = lbl.w + 'px';
                if (lbl.h) txt.style.height = lbl.h + 'px';
                txt.style.display = 'inline-block';
                wrapper.appendChild(txt);
                inp.remove();               // get rid of the input box
                // Auto‑focus the next remaining picture‑label blank
                setTimeout(() => {
                  const next = wrapper.querySelector('input[data-label="1"]');
                  if (next) next.focus();
                }, 0);

                // Reveal corresponding definition title now that this label is correct
                const entry = titleMap[lbl.text];
                if (entry && !entry.revealed) {
                  entry.el.textContent = (entry.idx + 1) + '. ' + lbl.text + ': ';
                  entry.revealed = true;
                }
              } else {
                // keep feedback colours while user is typing
                inp.classList.remove('correct');
                inp.classList.add('incorrect');
                inp.style.borderColor = '#c0392b';
              }

              // Re‑evaluate overall correctness outline
              const remainingInputs = Array.from(wrapper.querySelectorAll('input'));
              if (remainingInputs.length === 0) {
                img.style.outline = '2px solid #27ae60';
              } else {
                img.style.outline = '';
              }
            };
            wrapper.appendChild(inp);
            // Number badge that matches the definition list
            let defIdx = -1;
            if (sec.definitions && sec.definitions.length) {
              defIdx = sec.definitions.findIndex(d => d.labelText === lbl.text);
            }
            if (defIdx >= 0) {
              const badge = document.createElement('div');
              badge.textContent = defIdx + 1;
              badge.style.position = 'absolute';
              badge.style.left = (lbl.x - 18) + 'px';
              badge.style.top = lbl.y + 'px';
              badge.style.width = '16px';
              badge.style.height = '16px';
              badge.style.borderRadius = '50%';
              badge.style.background = '#1abc9c';
              badge.style.color = '#fff';
              badge.style.fontSize = '10px';
              badge.style.display = 'flex';
              badge.style.alignItems = 'center';
              badge.style.justifyContent = 'center';
              badge.style.pointerEvents = 'none';
              wrapper.appendChild(badge);
            }
          });

          quizContent.appendChild(wrapper);
          // ---- Render mini‑fill definitions under the image ----
          if (sec.definitions && sec.definitions.length) {
            const defsHdr = document.createElement('h4');
            defsHdr.textContent = 'Definitions';
            defsHdr.style.marginTop = '20px';
            quizContent.appendChild(defsHdr);

            sec.definitions.forEach((def, dIndex) => {
              // Prefix each definition with its number – label name stays hidden until solved
              const para = document.createElement('p');
              para.style.marginBottom = '12px';
              const title = document.createElement('strong');
              title.textContent = (dIndex + 1) + '. ';
              para.appendChild(title);
              // Register this definition's title for reveal
              titleMap[def.labelText] = { el: title, idx: dIndex };
              const tokens = (def.rawText || '').split(/(\s+)/);
              const hiddenEntries = getHiddenEntries(def, tokens);
              let counts = {};
              tokens.forEach(tok => {
                if (!tok.trim()) {
                  para.appendChild(document.createTextNode(tok));
                  return;
                }
                const w = tok.trim();
                counts[w] = (counts[w] || 0) + 1;
                const occ = counts[w];
                const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);

                if (!isHidden) {
                  para.appendChild(document.createTextNode(tok));
                  return;
                }

                const key = `${w}_${occ}`;
                const answers = [w, ...(def.alts[key] || [])];

                const span = document.createElement('span');
                span.className = 'blank';
                const inp = document.createElement('input');
                inp.className = 'blank-input';
                inp.setAttribute('data-answer', JSON.stringify(answers));
                // Track focus for definition blanks too
                inp.addEventListener('focus', () => { lastHintTarget = inp; });
                // keep track of blanks for this definition
                if (!para._inputs) para._inputs = [];
                para._inputs.push(inp);
                // Match font family & size to regular fill‑in blanks
                const qcStyle = window.getComputedStyle(quizContent);
                inp.style.fontFamily = qcStyle.fontFamily;
                inp.style.fontSize   = qcStyle.fontSize;
                inp.style.padding    = '0 2px';
                // Space → next blank (if correct); Tab → previous; Backspace at start → previous
                inp.addEventListener('keydown', e => {
                  const inputs = Array.from(quizContent.querySelectorAll('input.blank-input'));
                  const idx = inputs.indexOf(inp);
                  if (e.key === ' ') {
                    e.preventDefault();
                    if (inp.classList.contains('correct') && idx < inputs.length - 1) {
                      inputs[idx + 1].focus();
                    }
                  }
                  if (e.key === 'Tab') {
                    e.preventDefault();
                    if (idx > 0) inputs[idx - 1].focus();
                  }
                  if (e.key === 'Backspace' && inp.selectionStart === 0 && inp.selectionEnd === 0 && inp.value === '' && idx > 0) {
                    e.preventDefault();
                    const prev = inputs[idx - 1];
                    prev.focus();
                    const len = prev.value.length;
                    prev.setSelectionRange(len, len);
                  }
                });

                // width sizing identical to regular fill‑ins
                const meas = document.createElement('span');
                meas.style.visibility = 'hidden';
                meas.style.position   = 'absolute';
                meas.style.whiteSpace = 'pre';
                meas.textContent = w.toUpperCase();
                document.body.appendChild(meas);
                inp.style.width = meas.offsetWidth + 4 + 'px';
                document.body.removeChild(meas);

                inp.oninput = () => {
                  const ok = answers.some(a => a.toLowerCase() === inp.value.trim().toLowerCase());
                  inp.classList.toggle('correct', ok);
                  inp.classList.toggle('incorrect', !ok);
                  const allInputs = Array.from(quizContent.querySelectorAll('input.blank-input'));
                  if (allInputs.length && allInputs.every(i => i.classList.contains('correct'))) {
                    quizContent.style.borderColor = '#27ae60';
                    markQuestionCompleted();
                  } else {
                    quizContent.style.borderColor = '';
                  }
                };

                span.appendChild(inp);
                para.appendChild(span);
              });
              quizContent.appendChild(para);
            });
          }
          return;
        }
        // existing fill-in logic follows
        quizContent.style.borderColor = '';
        // Use the same tokenization approach as the preview
        const tokensArr = extractTokens(sec);
        const hiddenEntries = getHiddenEntries(sec, tokensArr);
        let counts = {};
        tokensArr.forEach((tok, i) => {
          if (!tok.trim()) {
            quizContent.appendChild(document.createTextNode(tok));
            return;
          }
          const w = tok.trim();
          counts[w] = (counts[w] || 0) + 1;
          const occ = counts[w];
          const isHidden = hiddenEntries.some(e => e.word === w && e.occ === occ);
          if (isHidden) {
            const key = `${w}_${occ}`;
            let answers = [w, ...(sec.alts[key]||[])];
            let wrapper = document.createElement('span');
            wrapper.className = 'blank';
            // Always size based on uppercase text width with extra room
            const blankText = w.toUpperCase();
            wrapper.setAttribute('data-scrambled', '_'.repeat(blankText.length || 1));
            let inp = document.createElement('input');
            inp.className = 'blank-input';
            inp.addEventListener('focus', () => { lastHintTarget = inp; });
            // store correct answers for hint feature
            inp.setAttribute('data-answer', JSON.stringify(answers));
            // Match quiz section font
            const qcStyle = window.getComputedStyle(quizContent);
            inp.style.fontFamily = qcStyle.fontFamily;
            inp.style.fontSize = qcStyle.fontSize;
            inp.style.padding = '0 2px';
            inp.style.boxSizing = 'content-box';
            // Measure text width using hidden span
            const measurer = document.createElement('span');
            measurer.style.visibility = 'hidden';
            measurer.style.position = 'absolute';
            measurer.style.whiteSpace = 'pre';
            measurer.style.font = `${qcStyle.fontSize} ${qcStyle.fontFamily}`;
            measurer.textContent = blankText;
            document.body.appendChild(measurer);
            inp.style.width = (measurer.offsetWidth + 4) + 'px';
            document.body.removeChild(measurer);
            // Space → next (if correct); Tab → previous; Backspace at start → previous
            inp.addEventListener('keydown', e => {
              const inputs = Array.from(document.querySelectorAll('#quizContent input.blank-input'));
              const idx = inputs.indexOf(inp);
              if (e.key === ' ') {
                e.preventDefault();
                if (inp.classList.contains('correct') && idx < inputs.length - 1) {
                  inputs[idx + 1].focus();
                }
              }
              if (e.key === 'Tab') {
                e.preventDefault();
                if (idx > 0) {
                  inputs[idx - 1].focus();
                }
              }
              if (e.key === 'Backspace' && inp.selectionStart === 0 && inp.selectionEnd === 0 && inp.value === '' && idx > 0) {
                e.preventDefault();
                const prev = inputs[idx - 1];
                prev.focus();
                const len = prev.value.length;
                prev.setSelectionRange(len, len);
              }
            });
            // Simplified input handler: just correctness, outline if all correct
            inp.oninput = () => {
              const val = inp.value.trim().toLowerCase();
              const ok = answers.some(a => a.toLowerCase() === val);
              inp.classList.toggle('correct', ok);
              inp.classList.toggle('incorrect', !ok);
              const allInputs = Array.from(document.querySelectorAll('#quizContent input.blank-input'));
              if (allInputs.length && allInputs.every(i => i.classList.contains('correct'))) {
                quizContent.style.borderColor = '#27ae60';
                markQuestionCompleted();
              } else {
                quizContent.style.borderColor = '';
              }
            };
            wrapper.appendChild(inp);
            quizContent.appendChild(wrapper);
          } else {
            quizContent.appendChild(document.createTextNode(tok));
          }
        });
      }
      nextBtn.onclick = () => {
        const secs = data.folders[currentFolder].sections;
        const total = secs.length;
        if (quizOrder.length > 1 && questionCompleted()) {
          markQuestionCompleted();
          const prog = quizProgress[currentFolder];
          if (prog && prog.completed.size === prog.total) {
            alert('🎉 Section complete!');
          }
        }
        // If in Quiz All mode sequence, advance within that sequence first
        if (isQuizMode && quizOrder.length > 1 && quizPos < quizOrder.length - 1) {
          quizPos++;
          const prog = quizProgress[currentFolder];
          if (prog) prog.pos = quizPos;
          showQuiz();
          updateProgressIndicator();
          return;
        }
        // Otherwise, move to the next section by index
        if (currentSection < total - 1) {
          currentSection++;
          renderSections();
          enterQuizQuestion();
        } else {
          alert('🎉 All done!');
          enterEdit();
        }
        updateProgressIndicator();
      };
      backBtn.onclick = () => {
        const secs = data.folders[currentFolder].sections;
        if (isQuizMode && quizOrder.length > 1 && quizPos > 0) {
          quizPos--;
          const prog = quizProgress[currentFolder];
          if (prog) prog.pos = quizPos;
          showQuiz();
          updateProgressIndicator();
          return;
        }
        if (currentSection > 0) {
          currentSection--;
          renderSections();
          if (isQuizMode) {
            enterQuizQuestion();
          } else {
            loadSection();
            previewSection();
          }
        }
        updateProgressIndicator();
      };
      // --- Hint button logic ---
      const hintBtn = document.getElementById('hintBtn');
      hintBtn.onclick = () => {
        // Determine target: last focused blank, then active focus, then first incomplete
        let target = null;
        if (lastHintTarget && lastHintTarget.dataset.answer) {
          target = lastHintTarget;
        } else {
          const active = document.activeElement;
          if (active && active.classList.contains('blank-input') && active.dataset.answer) {
            target = active;
          } else {
            const inputs = Array.from(document.querySelectorAll('#quizContent input.blank-input'));
            target = inputs.find(i => !i.classList.contains('correct')) || null;
          }
        }
        if (target && target.dataset.answer) {
          const answers = JSON.parse(target.getAttribute('data-answer'));
          const correct = answers[0] || '';
          target.value = correct;

          if (!target.dataset.label) {
            // Regular blank – use normal correctness logic
            target.dispatchEvent(new Event('input'));
          } else {
            // Picture‑label blank: show temporarily, don’t trigger permanent reveal
            target.classList.add('correct');
            // size to fit if user previously shrank
            target.style.width = correct.length + 1 + 'ch';
          }

          target.focus();
          setTimeout(() => {
            // Clear only if user hasn’t typed something else
            if (target.value.trim().toLowerCase() === correct.toLowerCase()) {
              target.value = '';
              target.classList.remove('correct');
            }
          }, 1000);
        }
      };

    } catch (err) {
      console.error(err);
      alert('Unhandled error: ' + err.message);
    }
  })();
  </script>
</body>
</html>
